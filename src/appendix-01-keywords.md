## পরিশিষ্ট ক: কীওয়ার্ড

নিচের তালিকায় এমন সব কীওয়ার্ড রয়েছে যা Rust ল্যাঙ্গুয়েজ দ্বারা বর্তমান বা ভবিষ্যতের ব্যবহারের জন্য সংরক্ষিত। তাই, এগুলো আইডেন্টিফায়ার (identifier) হিসেবে ব্যবহার করা যাবে না (ব্যতিক্রম হিসেবে 'র আইডেন্টিফায়ার' ব্যবহার করা যেতে পারে, যা আমরা '[র আইডেন্টিফায়ার][raw-identifiers]' বিভাগে আলোচনা করব)। আইডেন্টিফায়ার হলো ফাংশন, ভেরিয়েবল, প্যারামিটার, স্ট্রাকট ফিল্ড, মডিউল, ক্রেট, কনস্ট্যান্ট, ম্যাক্রো, স্ট্যাটিক ভ্যালু, অ্যাট্রিবিউট, টাইপ, ট্রেইট বা লাইফটাইমের নাম।

[raw-identifiers]: #raw-identifiers

### বর্তমানে ব্যবহৃত কীওয়ার্ড

নিচে বর্তমানে ব্যবহৃত কীওয়ার্ডগুলোর একটি তালিকা এবং তাদের কার্যকারিতার বর্ণনা দেওয়া হলো।

-   `as` - প্রিমিটিভ কাস্টিং করতে, কোনো আইটেম ধারণকারী নির্দিষ্ট ট্রেইটকে দ্ব্যর্থহীন করতে, অথবা `use` স্টেটমেন্টে আইটেমগুলোর নতুন নাম দিতে ব্যবহৃত হয়।
-   `async` - বর্তমান থ্রেডকে ব্লক না করে একটি `Future` রিটার্ন করে।
-   `await` - একটি `Future`-এর ফলাফল প্রস্তুত না হওয়া পর্যন্ত এক্সিকিউশন স্থগিত রাখে।
-   `break` - একটি লুপ থেকে অবিলম্বে বেরিয়ে যায়।
-   `const` - কনস্ট্যান্ট আইটেম বা কনস্ট্যান্ট র পয়েন্টার ডিফাইন করে।
-   `continue` - লুপের পরবর্তী ইটারেশনে চলে যায়।
-   `crate` - একটি মডিউল পাথে, ক্রেটের রুটকে বোঝায়।
-   `dyn` - একটি ট্রেইট অবজেক্টে ডাইনামিক ডিসপ্যাচ করে।
-   `else` - `if` এবং `if let` কন্ট্রোল ফ্লো কনস্ট্রাক্টের ফলব্যাক।
-   `enum` - একটি enumeration ডিফাইন করে।
-   `extern` - একটি এক্সটার্নাল ফাংশন বা ভেরিয়েবল লিঙ্ক করে।
-   `false` - বুলিয়ান `false` লিটারাল।
-   `fn` - একটি ফাংশন বা ফাংশন পয়েন্টার টাইপ ডিফাইন করে।
-   `for` - একটি ইটারেটরের আইটেমগুলোর উপর লুপ চালানো, একটি ট্রেইট ইমপ্লিমেন্ট করা, বা একটি হায়ার-র‍্যাঙ্কড লাইফটাইম নির্দিষ্ট করার জন্য ব্যবহৃত হয়।
-   `if` - একটি শর্তাধীন এক্সপ্রেশনের ফলাফলের উপর ভিত্তি করে ব্রাঞ্চ তৈরি করে।
-   `impl` - ইনহেরেন্ট বা ট্রেইট কার্যকারিতা ইমপ্লিমেন্ট করে।
-   `in` - `for` লুপ সিনট্যাক্সের অংশ।
-   `let` - একটি ভেরিয়েবল বাইন্ড করে।
-   `loop` - শর্তহীনভাবে লুপ চালায়।
-   `match` - একটি ভ্যালুকে প্যাটার্নের সাথে ম্যাচ করে।
-   `mod` - একটি মডিউল ডিফাইন করে।
-   `move` - একটি ক্লোজারকে তার সমস্ত ক্যাপচারের মালিকানা নিতে বাধ্য করে।
-   `mut` - রেফারেন্স, র পয়েন্টার, বা প্যাটার্ন বাইন্ডিং-এ মিউটেবিলিটি বোঝায়।
-   `pub` - স্ট্রাকট ফিল্ড, `impl` ব্লক, বা মডিউলে পাবলিক ভিজিবিলিটি বোঝায়।
-   `ref` - রেফারেন্স দ্বারা বাইন্ড করে।
-   `return` - ফাংশন থেকে রিটার্ন করে।
-   `Self` - যে টাইপটি আমরা ডিফাইন বা ইমপ্লিমেন্ট করছি তার জন্য একটি টাইপ এলিয়াস।
-   `self` - মেথডের সাবজেক্ট বা বর্তমান মডিউল।
-   `static` - গ্লোবাল ভেরিয়েবল বা পুরো প্রোগ্রাম এক্সিকিউশন পর্যন্ত স্থায়ী লাইফটাইম।
-   `struct` - একটি স্ট্রাকচার ডিফাইন করে।
-   `super` - বর্তমান মডিউলের প্যারেন্ট মডিউল।
-   `trait` - একটি ট্রেইট ডিফাইন করে।
-   `true` - বুলিয়ান `true` লিটারাল।
-   `type` - একটি টাইপ এলিয়াস বা অ্যাসোসিয়েটেড টাইপ ডিফাইন করে।
-   `union` - একটি [union][union] ডিফাইন করে; এটি শুধুমাত্র একটি union ডিক্লারেশনে ব্যবহৃত হলেই কীওয়ার্ড হিসেবে গণ্য হয়।
-   `unsafe` - আনসেফ কোড, ফাংশন, ট্রেইট, বা ইমপ্লিমেন্টেশন বোঝায়।
-   `use` - স্কোপে সিম্বল নিয়ে আসে; জেনেরিক এবং লাইফটাইম বাউন্ডের জন্য সুনির্দিষ্ট ক্যাপচার নির্দিষ্ট করে।
-   `where` - এমন ক্লজ বোঝায় যা একটি টাইপকে সীমাবদ্ধ করে।
-   `while` - একটি এক্সপ্রেশনের ফলাফলের উপর ভিত্তি করে শর্তসাপেক্ষে লুপ চালায়।

[union]: ../reference/items/unions.html

### ভবিষ্যৎ ব্যবহারের জন্য সংরক্ষিত কীওয়ার্ড

নিচের কীওয়ার্ডগুলোর এখনো কোনো কার্যকারিতা নেই, কিন্তু Rust ভবিষ্যতে ব্যবহারের সম্ভাবনার জন্য এগুলোকে সংরক্ষিত রেখেছে।

-   `abstract`
-   `become`
-   `box`
-   `do`
-   `final`
-   `gen`
-   `macro`
-   `override`
-   `priv`
-   `try`
-   `typeof`
-   `unsized`
-   `virtual`
-   `yield`

### র আইডেন্টিফায়ার

_র আইডেন্টিফায়ার_ হলো এমন একটি সিনট্যাক্স যা আপনাকে সেইসব জায়গায় কীওয়ার্ড ব্যবহার করতে দেয় যেখানে সাধারণত তা অনুমোদিত নয়। আপনি একটি কীওয়ার্ডের আগে `r#` উপসর্গ যোগ করে একটি র আইডেন্টিফায়ার ব্যবহার করতে পারেন।

উদাহরণস্বরূপ, `match` একটি কীওয়ার্ড। আপনি যদি `match` নামটি ব্যবহার করে নিচের ফাংশনটি কম্পাইল করার চেষ্টা করেন:

<span class="filename">ফাইলের নাম: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

আপনি এই এররটি পাবেন:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

এররটি দেখাচ্ছে যে আপনি `match` কীওয়ার্ডটি ফাংশন আইডেন্টিফায়ার হিসেবে ব্যবহার করতে পারবেন না। `match` কে ফাংশনের নাম হিসেবে ব্যবহার করতে হলে আপনাকে র আইডেন্টিফায়ার সিনট্যাক্স ব্যবহার করতে হবে, যেমন:

<span class="filename">ফাইলের নাম: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

এই কোডটি কোনো এরর ছাড়াই কম্পাইল হবে। লক্ষ্য করুন, ফাংশনের সংজ্ঞায় এবং `main`-এ যেখানে ফাংশনটি কল করা হয়েছে, উভয় স্থানেই ফাংশনের নামের আগে `r#` উপসর্গটি রয়েছে।

র আইডেন্টিফায়ার আপনাকে আপনার পছন্দের যেকোনো শব্দকে আইডেন্টিফায়ার হিসেবে ব্যবহার করার অনুমতি দেয়, এমনকি যদি সেই শব্দটি একটি সংরক্ষিত কীওয়ার্ডও হয়। এটি আমাদের আইডেন্টিফায়ারের নাম বেছে নেওয়ার ক্ষেত্রে আরও স্বাধীনতা দেয়, এবং এমন প্রোগ্রামের সাথে ইন্টিগ্রেট করতে সাহায্য করে যা এমন ভাষায় লেখা যেখানে এই শব্দগুলো কীওয়ার্ড নয়। এছাড়াও, র আইডেন্টিফায়ার আপনাকে আপনার ক্রেটের চেয়ে ভিন্ন Rust এডিশনে লেখা লাইব্রেরি ব্যবহার করার সুযোগ দেয়। উদাহরণস্বরূপ, `try` 2015 এডিশনে কোনো কীওয়ার্ড নয়, কিন্তু 2018, 2021 এবং 2024 এডিশনে এটি একটি কীওয়ার্ড। আপনি যদি 2015 এডিশন ব্যবহার করে লেখা একটি লাইব্রেরির উপর নির্ভর করেন এবং সেখানে একটি `try` ফাংশন থাকে, তবে পরবর্তী এডিশনগুলোতে আপনার কোড থেকে সেই ফাংশনটি কল করার জন্য আপনাকে র আইডেন্টিফায়ার সিনট্যাক্স, এক্ষেত্রে `r#try`, ব্যবহার করতে হবে। এডিশন সম্পর্কে আরও তথ্যের জন্য [পরিশিষ্ট ঙ][appendix-e] দেখুন।

[appendix-e]: appendix-05-editions.html