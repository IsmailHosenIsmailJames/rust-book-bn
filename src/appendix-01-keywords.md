## পরিশিষ্ট A: Key ওয়ার্ড

নিচের তালিকায় সেই Key ওয়ার্ডগুলো আছে যা Rust ভাষা বর্তমানে অথবা ভবিষ্যতে ব্যবহারের জন্য সংরক্ষিত রেখেছে। এই কারণে, এগুলোকে আইডেন্টিফায়ার হিসেবে ব্যবহার করা যাবে না ( "Raw Identifiers" অংশে আলোচনা করা "raw identifiers" বাদে)। আইডেন্টিফায়ার হলো ফাংশন, ভেরিয়েবল, প্যারামিটার, struct ফিল্ড, মডিউল, crate, কনস্ট্যান্ট, ম্যাক্রো, static ভ্যালু, attribute, টাইপ, trait অথবা লাইফটাইমের নাম।

### বর্তমানে ব্যবহৃত Key ওয়ার্ড

নিচে বর্তমানে ব্যবহৃত Key ওয়ার্ডগুলোর তালিকা দেওয়া হল, এবং এদের কাজও বর্ণনা করা হল।

- `as` -  প্রিমিটিভ কাস্টিং করার জন্য, অথবা কোনো আইটেম ধারণকারী কোনো বিশেষ trait-কে আলাদা করার জন্য, অথবা `use` স্টেটমেন্টে আইটেমের নাম পরিবর্তন করার জন্য।
- `async` - কারেন্ট থ্রেড ব্লক না করে `Future` রিটার্ন করে।
- `await` - `Future`-এর রেজাল্ট প্রস্তুত না হওয়া পর্যন্ত execution স্থগিত করে।
- `break` - লুপ থেকে তৎক্ষণাৎ বের হয়ে যায়।
- `const` - কনস্ট্যান্ট আইটেম অথবা কনস্ট্যান্ট raw পয়েন্টার define করে।
- `continue` - লুপের পরবর্তী iteration-এ চলে যায়।
- `crate` - মডিউল পাথে, crate-এর রুট বোঝায়।
- `dyn` - trait অবজেক্টে ডাইনামিক ডিসপ্যাচ করে।
- `else` - `if` এবং `if let` কন্ট্রোল ফ্লো কনস্ট্রাক্টের ফলব্যাক।
- `enum` - enum বা তালিকা define করে।
- `extern` - কোনো এক্সটার্নাল ফাংশন বা ভেরিয়েবলের সাথে লিঙ্ক করে।
- `false` - বুলিয়ান false লিটারেল।
- `fn` - ফাংশন অথবা ফাংশন পয়েন্টার টাইপ define করে।
- `for` - কোনো iterator থেকে আইটেমগুলোর ওপর লুপ করে, অথবা কোনো trait implement করে, অথবা higher-ranked লাইফটাইম স্পেসিফাই করে।
- `if` - কন্ডিশনাল এক্সপ্রেশনের ফলাফলের ওপর ভিত্তি করে branch করে।
- `impl` -  inherent অথবা trait এর কার্যকারিতা implement করে।
- `in` - `for` লুপ সিনট্যাক্সের অংশ।
- `let` - একটি ভেরিয়েবল বাইন্ড করে।
- `loop` - শর্তহীনভাবে লুপ করে।
- `match` - কোনো ভ্যালুকে প্যাটার্নের সাথে ম্যাচ করে।
- `mod` - একটি মডিউল define করে।
- `move` - ক্লোজারকে তার সমস্ত ক্যাপচারের মালিকানা নিতে বাধ্য করে।
- `mut` - রেফারেন্স, raw পয়েন্টার বা প্যাটার্ন বাইন্ডিং-এ মিউটেবিলিটি বোঝায়।
- `pub` - struct ফিল্ড, `impl` ব্লক অথবা মডিউলে পাবলিক ভিজিবিলিটি বোঝায়।
- `ref` - রেফারেন্স দ্বারা বাইন্ড করে।
- `return` - ফাংশন থেকে রিটার্ন করে।
- `Self` - যে টাইপ define বা implement করা হচ্ছে তার জন্য একটি টাইপ অ্যালিয়াস।
- `self` - মেথড সাবজেক্ট অথবা কারেন্ট মডিউল।
- `static` - গ্লোবাল ভেরিয়েবল অথবা প্রোগ্রাম এক্সিকিউশন পর্যন্ত স্থায়ী লাইফটাইম।
- `struct` - একটি স্ট্রাকচার define করে।
- `super` - কারেন্ট মডিউলের প্যারেন্ট মডিউল।
- `trait` - একটি trait define করে।
- `true` - বুলিয়ান true লিটারেল।
- `type` - টাইপ অ্যালিয়াস অথবা অ্যাসোসিয়েটেড টাইপ define করে।
- `union` - একটি [union][union] define করে; union ডিক্লারেশনে ব্যবহার হলেই এটি একটি কিওয়ার্ড।
- `unsafe` - আনসেইফ কোড, ফাংশন, trait অথবা ইমপ্লিমেন্টেশন বোঝায়।
- `use` - সিম্বলগুলোকে স্কোপে আনে; জেনেরিক এবং লাইফটাইম বাউন্ডের জন্য সুনির্দিষ্ট ক্যাপচার স্পেসিফাই করে।
- `where` - ক্লজ বোঝায় যা একটি টাইপকে সীমাবদ্ধ করে।
- `while` - কোনো এক্সপ্রেশনের ফলাফলের ওপর ভিত্তি করে শর্তসাপেক্ষে লুপ করে।

[union]: ../reference/items/unions.html

### ভবিষ্যতে ব্যবহারের জন্য সংরক্ষিত Key ওয়ার্ড

নিচের Key ওয়ার্ডগুলির এখনও কোনো কার্যকারিতা নেই, কিন্তু Rust ভবিষ্যতে ব্যবহারের জন্য এগুলোকে সংরক্ষিত রেখেছে।

- `abstract`
- `become`
- `box`
- `do`
- `final`
- `gen`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### Raw আইডেন্টিফায়ার

_Raw identifiers_ হলো সিনট্যাক্স যা আপনাকে Key ওয়ার্ডগুলি ব্যবহার করতে দেয় যেখানে সেগুলি সাধারণত ব্যবহারের অনুমতি নেই। Key ওয়ার্ডের আগে `r#` উপসর্গ যোগ করে আপনি একটি raw identifier ব্যবহার করতে পারেন।

উদাহরণস্বরূপ, `match` একটি Key ওয়ার্ড। আপনি যদি নিম্নলিখিত ফাংশনটি কম্পাইল করার চেষ্টা করেন যেখানে `match` কে এর নাম হিসেবে ব্যবহার করা হয়েছে:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

আপনি এই এররটি পাবেন:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

এররটি দেখাচ্ছে যে আপনি `match` Key ওয়ার্ডটিকে ফাংশন আইডেন্টিফায়ার হিসেবে ব্যবহার করতে পারবেন না। `match` কে ফাংশনের নাম হিসেবে ব্যবহার করতে, আপনাকে raw identifier সিনট্যাক্স ব্যবহার করতে হবে, যেমন:

<span class="filename">Filename: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

এই কোডটি কোনো এরর ছাড়াই কম্পাইল হবে। ফাংশনের সংজ্ঞাতে এবং `main`-এ যেখানে ফাংশনটি কল করা হয়েছে সেখানে ফাংশনের নামের `r#` উপসর্গটি লক্ষ্য করুন।

Raw identifiers আপনাকে যেকোনো শব্দকে আইডেন্টিফায়ার হিসেবে ব্যবহার করার অনুমতি দেয়, এমনকি যদি সেই শব্দটি একটি সংরক্ষিত Key ওয়ার্ডও হয়। এটি আমাদেরকে আইডেন্টিফায়ারের নাম বেছে নেওয়ার ক্ষেত্রে আরও স্বাধীনতা দেয়, সেইসাথে অন্য ভাষায় লেখা প্রোগ্রামগুলোর সাথে ইন্টিগ্রেট করতে দেয় যেখানে এই শব্দগুলো Key ওয়ার্ড নয়। এছাড়াও, raw identifiers আপনাকে আপনার crate ব্যবহার করা থেকে আলাদা Rust edition-এ লেখা লাইব্রেরি ব্যবহার করতে দেয়। উদাহরণস্বরূপ, `try` 2015 edition-এ Key ওয়ার্ড ছিল না কিন্তু 2018, 2021 এবং 2024 edition-এ আছে। আপনি যদি এমন কোনো লাইব্রেরির ওপর নির্ভরশীল হন যা 2015 edition ব্যবহার করে লেখা এবং যার `try` ফাংশন আছে, তাহলে আপনাকে 2018 edition কোড থেকে সেই ফাংশন কল করতে raw identifier সিনট্যাক্স ব্যবহার করতে হবে, এক্ষেত্রে `r#try`। Editions সম্পর্কে আরও তথ্যের জন্য [Appendix E][appendix-e] দেখুন।

[appendix-e]: appendix-05-editions.html
