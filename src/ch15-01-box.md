## হিপের ডেটা নির্দেশ করতে `Box<T>` ব্যবহার করা

সবচেয়ে সহজবোধ্য স্মার্ট পয়েন্টার হল একটি _box_, যার টাইপ লেখা হয় `Box<T>`। Boxes আপনাকে স্ট্যাকের পরিবর্তে হিপে ডেটা সংরক্ষণ করতে দেয়। স্ট্যাকে যা থাকে তা হল হিপ ডেটার পয়েন্টার। স্ট্যাক এবং হিপের মধ্যে পার্থক্য পর্যালোচনা করতে অধ্যায় 4 দেখুন।

Boxes এর পারফরম্যান্স overhead নেই, শুধুমাত্র তাদের ডেটা স্ট্যাকের পরিবর্তে হিপে সংরক্ষণ করা ছাড়া। তবে তাদের খুব বেশি অতিরিক্ত ক্ষমতাও নেই। আপনি এগুলি প্রায়শই এই পরিস্থিতিতে ব্যবহার করবেন:

- যখন আপনার এমন একটি প্রকার থাকে যার আকার compile time-এ জানা যায় না এবং আপনি সেই প্রকারের মান ব্যবহার করতে চান এমন পরিস্থিতিতে যেখানে একটি সঠিক আকারের প্রয়োজন
- যখন আপনার প্রচুর ডেটা থাকে এবং আপনি ownership স্থানান্তর করতে চান কিন্তু নিশ্চিত করতে চান যে আপনি যখন তা করেন তখন ডেটা কপি করা হবে না
- যখন আপনি একটি মানের মালিক হতে চান এবং আপনি শুধুমাত্র এই বিষয়ে আগ্রহী যে এটি একটি নির্দিষ্ট প্রকারের হওয়ার পরিবর্তে একটি বিশেষ trait implement করে

আমরা [“Boxes সহ Recursive প্রকারগুলি সক্ষম করা”](#enabling-recursive-types-with-boxes)<!-- ignore --> বিভাগে প্রথম পরিস্থিতিটি প্রদর্শন করব। দ্বিতীয় ক্ষেত্রে, প্রচুর পরিমাণে ডেটার ownership স্থানান্তর করতে বেশি সময় লাগতে পারে কারণ ডেটা স্ট্যাকের চারপাশে কপি করা হয়। এই পরিস্থিতিতে কর্মক্ষমতা উন্নত করতে, আমরা হিপে প্রচুর পরিমাণে ডেটা একটি বক্সে সংরক্ষণ করতে পারি। তারপর, স্ট্যাকে শুধুমাত্র অল্প পরিমাণে পয়েন্টার ডেটা কপি করা হয়, যখন এটি যে ডেটাকে রেফারেন্স করে সেটি হিপে এক জায়গায় থাকে। তৃতীয় ক্ষেত্রটিকে _trait object_ বলা হয় এবং অধ্যায় 18 [“বিভিন্ন প্রকারের মানের জন্য অনুমতি দেয় এমন Trait Object ব্যবহার করা,”][trait-objects]<!-- ignore -->-এর সম্পূর্ণ একটি বিভাগ শুধুমাত্র সেই বিষয়ের জন্যই উৎসর্গীকৃত। তাই আপনি এখানে যা শিখবেন তা আপনি অধ্যায় 18-এ আবার প্রয়োগ করবেন!

### হিপে ডেটা সংরক্ষণের জন্য একটি `Box<T>` ব্যবহার করা

আমরা `Box<T>`-এর হিপ স্টোরেজ ব্যবহারের ক্ষেত্রটি নিয়ে আলোচনা করার আগে, আমরা সিনট্যাক্স এবং `Box<T>`-এর মধ্যে সংরক্ষিত মানগুলির সাথে কীভাবে ইন্টারঅ্যাক্ট করতে হয় তা নিয়ে আলোচনা করব।

Listing 15-1 দেখায় কিভাবে হিপে একটি `i32` মান সংরক্ষণ করতে একটি বক্স ব্যবহার করতে হয়:

<Listing number="15-1" file-name="src/main.rs" caption="একটি বক্স ব্যবহার করে হিপে একটি `i32` মান সংরক্ষণ করা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-01/src/main.rs}}
```

</Listing>

আমরা ভেরিয়েবল `b` কে একটি `Box` এর মান হিসাবে সংজ্ঞায়িত করি যা হিপে বরাদ্দ করা মান `5` কে নির্দেশ করে। এই প্রোগ্রামটি প্রিন্ট করবে `b = 5`; এই ক্ষেত্রে, আমরা বক্সে থাকা ডেটা অ্যাক্সেস করতে পারি যেন এই ডেটা স্ট্যাকে ছিল। যেকোনো owned মানের মতোই, যখন একটি বক্স scope-এর বাইরে চলে যায়, যেমন `main`-এর শেষে `b` করে, তখন এটিকে deallocate করা হবে। deallocation বক্সের (স্ট্যাকে সংরক্ষিত) এবং এটি যে ডেটাকে নির্দেশ করে তার (হিপে সংরক্ষিত) উভয়ের জন্যই ঘটে।

হিপে একটি একক মান রাখা খুব একটা দরকারী নয়, তাই আপনি প্রায়শই এই উপায়ে বক্সগুলি ব্যবহার করবেন না। স্ট্যাকে একটি একক `i32` এর মতো মান থাকা, যেখানে সেগুলি ডিফল্টভাবে সংরক্ষিত হয়, বেশিরভাগ পরিস্থিতিতে আরও উপযুক্ত। আসুন এমন একটি ক্ষেত্র দেখি যেখানে বক্সগুলি আমাদের এমন প্রকারগুলি সংজ্ঞায়িত করতে দেয় যা বক্স না থাকলে আমাদের অনুমতি দেওয়া হত না।

### Boxes সহ Recursive প্রকারগুলি সক্ষম করা

_Recursive টাইপের_ একটি মানের নিজের অংশ হিসাবে একই ধরনের অন্য মান থাকতে পারে। Recursive প্রকারগুলি একটি সমস্যা তৈরি করে কারণ compile time-এ Rust-কে জানতে হবে একটি প্রকার কতটা জায়গা নেয়। যাইহোক, recursive প্রকারের মানগুলির nesting তাত্ত্বিকভাবে অসীমভাবে চলতে পারে, তাই Rust জানতে পারে না যে মানের কতটা জায়গা প্রয়োজন। যেহেতু boxes এর একটি পরিচিত আকার আছে, তাই আমরা recursive প্রকার সংজ্ঞার মধ্যে একটি বক্স প্রবেশ করিয়ে recursive প্রকারগুলি সক্ষম করতে পারি।

Recursive প্রকারের উদাহরণ হিসাবে, আসুন _cons list_ অন্বেষণ করি। এটি একটি ডেটা প্রকার যা সাধারণত functional প্রোগ্রামিং ভাষাগুলিতে পাওয়া যায়। আমরা যে cons list প্রকারটি সংজ্ঞায়িত করব সেটি recursion ছাড়া সোজা, তাই আমরা যে উদাহরণটি নিয়ে কাজ করব তার ধারণাগুলি recursive প্রকারের সাথে জড়িত আরও জটিল পরিস্থিতিতে যেকোনো সময় কাজে লাগবে।

#### Cons List সম্পর্কে আরও তথ্য

_Cons list_ হল একটি ডেটা স্ট্রাকচার যা Lisp প্রোগ্রামিং ভাষা এবং এর উপভাষা থেকে এসেছে এবং নেস্টেড জোড়া দিয়ে গঠিত, এবং এটি একটি linked list-এর Lisp সংস্করণ। এর নামটি এসেছে Lisp-এর `cons` ফাংশন থেকে (যার অর্থ "construct function"), যা তার দুটি আর্গুমেন্ট থেকে একটি নতুন জোড়া তৈরি করে। একটি মান এবং অন্য জোড়া নিয়ে গঠিত একটি জোড়ার উপর `cons` কল করে, আমরা recursive জোড়া দিয়ে তৈরি cons list তৈরি করতে পারি।

উদাহরণস্বরূপ, এখানে বন্ধনীর মধ্যে প্রতিটি জোড়া সহ 1, 2, 3 তালিকা ধারণকারী একটি cons list-এর একটি সিউডোকোড উপস্থাপনা রয়েছে:

```text
(1, (2, (3, Nil)))
```

একটি cons list-এর প্রতিটি আইটেমে দুটি উপাদান থাকে: বর্তমান আইটেমের মান এবং পরবর্তী আইটেম। তালিকার শেষ আইটেমটিতে পরবর্তী আইটেম ছাড়াই `Nil` নামের একটি মান থাকে। cons list তৈরি হয় `cons` ফাংশনটিকে recursive ভাবে কল করে। recursion-এর base case বোঝাতে canonical নাম হল `Nil`। মনে রাখবেন যে এটি অধ্যায় 6-এর "null" বা "nil" ধারণার মতো নয়, যা একটি অবৈধ বা অনুপস্থিত মান।

cons list Rust-এ একটি সাধারণভাবে ব্যবহৃত ডেটা স্ট্রাকচার নয়। Rust-এ আপনার যখন আইটেমের একটি তালিকা থাকে, তখন `Vec<T>` ব্যবহার করা আরও ভাল পছন্দ। অন্যান্য, আরও জটিল recursive ডেটা প্রকার বিভিন্ন পরিস্থিতিতে কাজে লাগে, তবে এই অধ্যায়ে cons list দিয়ে শুরু করে, আমরা অন্বেষণ করতে পারি যে কীভাবে boxes আমাদের খুব বেশি বিভ্রান্তি ছাড়াই একটি recursive ডেটা প্রকার সংজ্ঞায়িত করতে দেয়।

Listing 15-2 একটি cons list-এর জন্য একটি enum সংজ্ঞা ধারণ করে। মনে রাখবেন যে এই কোডটি এখনও compile হবে না কারণ `List` টাইপের পরিচিত আকার নেই, যা আমরা প্রদর্শন করব।

<Listing number="15-2" file-name="src/main.rs" caption="`i32` মানগুলির একটি cons list ডেটা স্ট্রাকচার উপস্থাপন করার জন্য একটি enum সংজ্ঞায়িত করার প্রথম প্রচেষ্টা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-02/src/main.rs:here}}
```

</Listing>

> দ্রষ্টব্য: আমরা এই উদাহরণের উদ্দেশ্যে শুধুমাত্র `i32` মান ধারণ করে এমন একটি cons list implement করছি। আমরা যে কোনো প্রকারের মান সংরক্ষণ করতে পারে এমন একটি cons list প্রকার সংজ্ঞায়িত করার জন্য, অধ্যায় 10-এ আমরা আলোচনা করেছি, সেই অনুযায়ী জেনেরিক ব্যবহার করে এটিকে implement করতে পারতাম।

`1, 2, 3` তালিকাটি সংরক্ষণ করতে `List` প্রকারটি ব্যবহার করলে Listing 15-3-এর কোডের মতো দেখাবে:

<Listing number="15-3" file-name="src/main.rs" caption="`1, 2, 3` তালিকাটি সংরক্ষণ করতে `List` enum ব্যবহার করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-03/src/main.rs:here}}
```

</Listing>

প্রথম `Cons` মানটি `1` এবং অন্য একটি `List` মান ধারণ করে। এই `List` মানটি অন্য একটি `Cons` মান যা `2` এবং অন্য একটি `List` মান ধারণ করে। এই `List` মানটি আরও একটি `Cons` মান যা `3` এবং একটি `List` মান ধারণ করে, যা অবশেষে `Nil`, নন-recursive প্রকার যা তালিকার শেষ নির্দেশ করে।

যদি আমরা Listing 15-3-এর কোড compile করার চেষ্টা করি, তাহলে আমরা Listing 15-4-এ দেখানো error পাব:

<Listing number="15-4" file-name="output.txt" caption="একটি recursive enum সংজ্ঞায়িত করার চেষ্টা করার সময় আমরা যে error পাই">

```console
{{#include ../listings/ch15-smart-pointers/listing-15-03/output.txt}}
```

</Listing>

error টি দেখায় এই প্রকারের "অসীম আকার রয়েছে"। এর কারণ হল আমরা একটি variant দিয়ে `List` সংজ্ঞায়িত করেছি যা recursive: এটি সরাসরি নিজের অন্য মান ধারণ করে। ফলস্বরূপ, Rust একটি `List` মান সংরক্ষণ করার জন্য কতটা জায়গা প্রয়োজন তা বের করতে পারে না। আসুন ভেঙে দেখি কেন আমরা এই error পাই। প্রথমে, আমরা দেখব যে Rust কীভাবে সিদ্ধান্ত নেয় যে recursive নয় এমন প্রকারের মান সংরক্ষণ করার জন্য কতটা জায়গা প্রয়োজন।

#### Recursive নয় এমন প্রকারের আকার গণনা করা

অধ্যায় 6-এ enum সংজ্ঞা নিয়ে আলোচনা করার সময় আমরা Listing 6-2-এ সংজ্ঞায়িত করা `Message` enum-টি মনে করুন:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
```

`Message` মানের জন্য কতটা জায়গা বরাদ্দ করতে হবে তা নির্ধারণ করতে, Rust প্রতিটি variant-এর মধ্য দিয়ে যায় যাতে দেখা যায় কোন variant-এর সবচেয়ে বেশি জায়গার প্রয়োজন। Rust দেখে যে `Message::Quit`-এর কোনো জায়গার প্রয়োজন নেই, `Message::Move`-এর দুটি `i32` মান সংরক্ষণ করার জন্য যথেষ্ট জায়গার প্রয়োজন, এবং ইত্যাদি। যেহেতু শুধুমাত্র একটি variant ব্যবহার করা হবে, `Message` মানের জন্য সবচেয়ে বেশি জায়গার প্রয়োজন হবে তার variant গুলোর মধ্যে সবচেয়ে বড় variant সংরক্ষণে প্রয়োজনীয় স্থান।

এর বিপরীতে, Rust যখন Listing 15-2-এর `List` enum-এর মতো একটি recursive প্রকারের জন্য কতটা জায়গা প্রয়োজন তা নির্ধারণ করার চেষ্টা করে তখন কী ঘটে। কম্পাইলার `Cons` variant দেখে শুরু করে, যা `i32` প্রকারের একটি মান এবং `List` প্রকারের একটি মান ধারণ করে। অতএব, `Cons`-এর `i32`-এর আকারের সমান স্থান এবং একটি `List`-এর আকার প্রয়োজন। `List` প্রকারের জন্য কতটা মেমরির প্রয়োজন তা বের করার জন্য, কম্পাইলার `Cons` variant দিয়ে শুরু করে variant গুলোর দিকে তাকায়। `Cons` variant `i32` প্রকারের একটি মান এবং `List` প্রকারের একটি মান ধারণ করে এবং এই প্রক্রিয়াটি অসীমভাবে চলতে থাকে, যেমনটি চিত্র 15-1-এ দেখানো হয়েছে।

<img alt="একটি অসীম Cons list" src="img/trpl15-01.svg" class="center" style="width: 50%;" />

<span class="caption">চিত্র 15-1: অসীম `Cons` variant নিয়ে গঠিত একটি অসীম `List`</span>

#### একটি পরিচিত আকারের Recursive প্রকার পেতে `Box<T>` ব্যবহার করা

যেহেতু Rust recursive ভাবে সংজ্ঞায়িত প্রকারের জন্য কতটা জায়গা বরাদ্দ করতে হবে তা বের করতে পারে না, তাই কম্পাইলার এই সহায়ক পরামর্শ দিয়ে একটি error দেয়:

<!-- manual-regeneration
after doing automatic regeneration, look at listings/ch15-smart-pointers/listing-15-03/output.txt and copy the relevant line
-->

```text
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
  |
2 |     Cons(i32, Box<List>),
  |               ++++    +
```

এই পরামর্শে, "indirection" মানে হল সরাসরি একটি মান সংরক্ষণ করার পরিবর্তে, আমাদের মানটির পরিবর্তে মানের একটি পয়েন্টার সংরক্ষণ করে পরোক্ষভাবে মানটিকে সংরক্ষণ করতে ডেটা স্ট্রাকচার পরিবর্তন করা উচিত।

যেহেতু একটি `Box<T>` একটি পয়েন্টার, Rust সবসময় জানে একটি `Box<T>`-এর জন্য কতটা জায়গা প্রয়োজন: একটি পয়েন্টারের আকার এটি যে ডেটাকে নির্দেশ করে তার পরিমাণের উপর ভিত্তি করে পরিবর্তিত হয় না। এর মানে হল আমরা সরাসরি অন্য একটি `List` মানের পরিবর্তে `Cons` variant-এর ভিতরে একটি `Box<T>` রাখতে পারি। `Box<T>` পরবর্তী `List` মানটিকে নির্দেশ করবে যা `Cons` variant-এর ভিতরে থাকার পরিবর্তে হিপে থাকবে। ধারণাগতভাবে, আমাদের এখনও একটি তালিকা রয়েছে, যা অন্যান্য তালিকা ধারণকারী তালিকা দিয়ে তৈরি, তবে এই implementation এখন একটির ভিতরে অন্যটিকে রাখার পরিবর্তে আইটেমগুলিকে একে অপরের পাশে রাখার মতো।

আমরা Listing 15-2-এর `List` enum-এর সংজ্ঞা এবং Listing 15-3-এ `List`-এর ব্যবহার পরিবর্তন করে Listing 15-5-এর কোড করতে পারি, যা compile হবে:

<Listing number="15-5" file-name="src/main.rs" caption="`List`-এর সংজ্ঞা যা একটি পরিচিত আকার পেতে `Box<T>` ব্যবহার করে">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-05/src/main.rs}}
```

</Listing>

`Cons` variant-এর একটি `i32`-এর আকার এবং বক্সের পয়েন্টার ডেটা সংরক্ষণের জন্য স্থান প্রয়োজন। `Nil` variant কোনো মান সংরক্ষণ করে না, তাই এটির `Cons` variant-এর চেয়ে কম জায়গার প্রয়োজন। আমরা এখন জানি যে কোনো `List` মান একটি `i32`-এর আকার এবং একটি বক্সের পয়েন্টার ডেটার আকারের স্থান নেবে। একটি বক্স ব্যবহার করে, আমরা অসীম, recursive chain ভেঙে দিয়েছি, তাই কম্পাইলার একটি `List` মান সংরক্ষণ করার জন্য প্রয়োজনীয় আকার বের করতে পারে। চিত্র 15-2 দেখায় `Cons` variant টি এখন কেমন দেখাচ্ছে।

<img alt="একটি সসীম Cons list" src="img/trpl15-02.svg" class="center" />

<span class="caption">চিত্র 15-2: একটি `List` যা অসীম আকারের নয় কারণ `Cons` একটি `Box` ধারণ করে</span>

Boxes শুধুমাত্র indirection এবং হিপ বরাদ্দ প্রদান করে; তাদের অন্য কোনো বিশেষ ক্ষমতা নেই, যেমন আমরা অন্যান্য স্মার্ট পয়েন্টার প্রকারের সাথে দেখব। তাদের পারফরম্যান্স overhead ও নেই যা এই বিশেষ ক্ষমতাগুলির কারণে হয়, তাই cons list-এর মতো ক্ষেত্রে সেগুলি কার্যকর হতে পারে যেখানে indirection হল একমাত্র বৈশিষ্ট্য যা আমাদের প্রয়োজন। আমরা অধ্যায় 18-এও boxes-এর আরও ব্যবহারের ক্ষেত্র দেখব।

`Box<T>` টাইপটি একটি স্মার্ট পয়েন্টার কারণ এটি `Deref` trait implement করে, যা `Box<T>` মানগুলিকে রেফারেন্সের মতো ব্যবহার করার অনুমতি দেয়। যখন একটি `Box<T>` মান scope-এর বাইরে চলে যায়, তখন সেই হিপ ডেটাটিও পরিষ্কার করা হয় যেটিকে বক্স নির্দেশ করছে, `Drop` trait implementation-এর কারণে। এই দুটি trait এই অধ্যায়ের বাকি অংশে আমরা যে অন্যান্য স্মার্ট পয়েন্টার প্রকারগুলি নিয়ে আলোচনা করব সেগুলির কার্যকারিতার জন্য আরও গুরুত্বপূর্ণ হবে। আসুন এই দুটি trait আরও বিস্তারিতভাবে অন্বেষণ করি।

[trait-objects]: ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
