## রেফারেন্স সাইকেল মেমরি লিক করতে পারে

Rust-এর মেমরি সুরক্ষার নিশ্চয়তাগুলি দুর্ঘটনাজনিতভাবে এমন মেমরি তৈরি করা কঠিন করে তোলে, তবে অসম্ভব নয়, যা কখনই পরিষ্কার করা হয় না (যা _মেমরি লিক_ নামে পরিচিত)। মেমরি লিক সম্পূর্ণরূপে প্রতিরোধ করা Rust-এর নিশ্চয়তাগুলির মধ্যে একটি নয়, যার মানে মেমরি লিকগুলি Rust-এ মেমরি নিরাপদ। আমরা দেখতে পাচ্ছি যে Rust `Rc<T>` এবং `RefCell<T>` ব্যবহার করে মেমরি লিকের অনুমতি দেয়: এমন রেফারেন্স তৈরি করা সম্ভব যেখানে আইটেমগুলি একটি চক্রে একে অপরের সাথে সম্পর্কিত। এটি মেমরি লিক তৈরি করে কারণ চক্রের প্রতিটি আইটেমের রেফারেন্স গণনা কখনই 0-এ পৌঁছাবে না এবং মানগুলি কখনই ড্রপ করা হবে না।

### একটি রেফারেন্স সাইকেল তৈরি করা

আসুন দেখে নেওয়া যাক কীভাবে একটি রেফারেন্স সাইকেল ঘটতে পারে এবং কীভাবে এটি প্রতিরোধ করা যায়, Listing 15-25-এ `List` enum-এর সংজ্ঞা এবং `tail` পদ্ধতি দিয়ে শুরু করা যাক:

<Listing number="15-25" file-name="src/main.rs" caption="একটি কন্স তালিকা সংজ্ঞা যা একটি `RefCell<T>` ধরে রাখে যাতে আমরা একটি `Cons` ভেরিয়েন্ট কী উল্লেখ করছে তা পরিবর্তন করতে পারি">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-25/src/main.rs}}
```

</Listing>

আমরা Listing 15-5 থেকে `List` সংজ্ঞার আরেকটি ভিন্নতা ব্যবহার করছি। `Cons` ভেরিয়েন্টের দ্বিতীয় উপাদানটি এখন `RefCell<Rc<List>>`, যার অর্থ Listing 15-24-এর মতো `i32` মান পরিবর্তন করার ক্ষমতা থাকার পরিবর্তে, আমরা `Cons` ভেরিয়েন্টটি যে `List` মানটির দিকে নির্দেশ করছে তা পরিবর্তন করতে চাই। আমরা একটি `tail` পদ্ধতিও যুক্ত করছি যাতে আমাদের `Cons` ভেরিয়েন্ট থাকলে দ্বিতীয় আইটেমটি অ্যাক্সেস করা আমাদের জন্য সুবিধাজনক হয়।

Listing 15-26-এ, আমরা একটি `main` ফাংশন যোগ করছি যা Listing 15-25-এর সংজ্ঞাগুলি ব্যবহার করে। এই কোডটি `a`-এ একটি তালিকা এবং `b`-এ একটি তালিকা তৈরি করে যা `a`-এর তালিকায় নির্দেশ করে। তারপর এটি `a`-এর তালিকাটিকে `b`-এর দিকে নির্দেশ করার জন্য পরিবর্তন করে, একটি রেফারেন্স সাইকেল তৈরি করে। এই প্রক্রিয়ার বিভিন্ন সময়ে রেফারেন্স গণনা কী তা দেখানোর জন্য পথে `println!` স্টেটমেন্ট রয়েছে।

<Listing number="15-26" file-name="src/main.rs" caption="দুটি `List` মানের একটি রেফারেন্স সাইকেল তৈরি করা যা একে অপরের দিকে নির্দেশ করে">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-26/src/main.rs:here}}
```

</Listing>

আমরা ভেরিয়েবল `a`-এ একটি `List` মান ধারণ করে একটি `Rc<List>` উদাহরণ তৈরি করি যার প্রাথমিক তালিকা হল `5, Nil`। তারপরে আমরা ভেরিয়েবল `b`-এ আরেকটি `List` মান ধারণ করে একটি `Rc<List>` উদাহরণ তৈরি করি যাতে 10 মান রয়েছে এবং `a`-এর তালিকায় নির্দেশ করে।

আমরা `a`-কে পরিবর্তন করি যাতে এটি `Nil`-এর পরিবর্তে `b`-এর দিকে নির্দেশ করে, একটি চক্র তৈরি করে। আমরা `a`-এর `RefCell<Rc<List>>`-এর একটি রেফারেন্স পেতে `tail` পদ্ধতিটি ব্যবহার করে তা করি, যা আমরা ভেরিয়েবল `link`-এ রাখি। তারপর আমরা `RefCell<Rc<List>>`-এ `borrow_mut` পদ্ধতি ব্যবহার করি ভিতরের মানটিকে একটি `Rc<List>` থেকে পরিবর্তন করতে যা একটি `Nil` মান ধারণ করে `b`-এর `Rc<List>`-এ।

যখন আমরা এই কোডটি চালাই, তখন শেষ `println!` আপাতত কমেন্ট আউট রেখে, আমরা এই আউটপুটটি পাব:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-26/output.txt}}
```

`a` এবং `b` উভয় ক্ষেত্রেই `Rc<List>` উদাহরণের রেফারেন্স গণনা 2 যখন আমরা `a`-এর তালিকা পরিবর্তন করে `b`-এর দিকে নির্দেশ করি। `main`-এর শেষে, Rust ভেরিয়েবল `b` ড্রপ করে, যা `b` `Rc<List>` উদাহরণের রেফারেন্স গণনা 2 থেকে কমিয়ে 1 করে। হিপে `Rc<List>`-এর থাকা মেমরিটি এই সময়ে ড্রপ করা হবে না, কারণ এর রেফারেন্স গণনা 1, 0 নয়। তারপর Rust `a` ড্রপ করে, যা `a` `Rc<List>` উদাহরণের রেফারেন্স গণনাও 2 থেকে কমিয়ে 1 করে। এই উদাহরণের মেমরিও ড্রপ করা যাবে না, কারণ অন্য `Rc<List>` উদাহরণটি এখনও এটিকে উল্লেখ করে। তালিকার জন্য বরাদ্দ করা মেমরি চিরকালের জন্য অসংগৃহীত থাকবে। এই রেফারেন্স চক্রটিকে কল্পনা করার জন্য, আমরা চিত্র 15-4-এ একটি ডায়াগ্রাম তৈরি করেছি।

<img alt="তালিকার রেফারেন্স চক্র" src="img/trpl15-04.svg" class="center" />

<span class="caption">চিত্র 15-4: তালিকা `a` এবং `b`-এর একটি রেফারেন্স চক্র যা একে অপরের দিকে নির্দেশ করছে</span>

আপনি যদি শেষ `println!` আনকমেন্ট করেন এবং প্রোগ্রামটি চালান, তাহলে Rust এই চক্রটি প্রিন্ট করার চেষ্টা করবে যেখানে `a` `b`-এর দিকে নির্দেশ করছে এবং `b` `a`-এর দিকে নির্দেশ করছে এবং যতক্ষণ না এটি স্ট্যাক উপচে পড়ে ততক্ষণ পর্যন্ত চলতে থাকবে।

একটি বাস্তব-বিশ্ব প্রোগ্রামের তুলনায়, এই উদাহরণে একটি রেফারেন্স সাইকেল তৈরি করার পরিণতি খুব ভয়াবহ নয়: রেফারেন্স সাইকেল তৈরি করার সাথে সাথেই প্রোগ্রামটি শেষ হয়ে যায়। যাইহোক, যদি একটি আরও জটিল প্রোগ্রাম একটি চক্রে প্রচুর মেমরি বরাদ্দ করে এবং এটিকে দীর্ঘ সময়ের জন্য ধরে রাখে, তাহলে প্রোগ্রামটি তার প্রয়োজনীয়তার চেয়ে বেশি মেমরি ব্যবহার করবে এবং সিস্টেমকে অভিভূত করতে পারে, যার ফলে উপলব্ধ মেমরি ফুরিয়ে যেতে পারে।

রেফারেন্স সাইকেল তৈরি করা সহজে হয় না, তবে এটি অসম্ভবও নয়। যদি আপনার `RefCell<T>` মান থাকে যাতে `Rc<T>` মান থাকে বা অভ্যন্তরীণ পরিবর্তনশীলতা এবং রেফারেন্স গণনার সাথে টাইপগুলির অনুরূপ নেস্টেড সংমিশ্রণ থাকে তবে আপনাকে নিশ্চিত করতে হবে যে আপনি চক্র তৈরি করছেন না; আপনি তাদের ধরার জন্য Rust-এর উপর নির্ভর করতে পারবেন না। একটি রেফারেন্স সাইকেল তৈরি করা আপনার প্রোগ্রামের একটি লজিক বাগ হবে যা কমানোর জন্য আপনার স্বয়ংক্রিয় পরীক্ষা, কোড পর্যালোচনা এবং অন্যান্য সফ্টওয়্যার বিকাশ অনুশীলন ব্যবহার করা উচিত।

রেফারেন্স সাইকেল এড়ানোর আরেকটি সমাধান হল আপনার ডেটা স্ট্রাকচারগুলিকে পুনরায় সংগঠিত করা যাতে কিছু রেফারেন্স মালিকানা প্রকাশ করে এবং কিছু রেফারেন্স না করে। ফলস্বরূপ, আপনার কিছু মালিকানার সম্পর্ক এবং কিছু অ-মালিকানার সম্পর্ক দিয়ে গঠিত চক্র থাকতে পারে এবং শুধুমাত্র মালিকানার সম্পর্কগুলিই একটি মান ড্রপ করা যেতে পারে কিনা তা প্রভাবিত করে। Listing 15-25-এ, আমরা সবসময় চাই `Cons` ভেরিয়েন্টগুলি তাদের তালিকার মালিক হোক, তাই ডেটা স্ট্রাকচারটিকে পুনরায় সংগঠিত করা সম্ভব নয়। আসুন প্যারেন্ট নোড এবং চাইল্ড নোড দিয়ে গঠিত গ্রাফ ব্যবহার করে একটি উদাহরণ দেখি যখন অ-মালিকানার সম্পর্কগুলি রেফারেন্স চক্র প্রতিরোধ করার একটি উপযুক্ত উপায়।

### রেফারেন্স চক্র প্রতিরোধ করা: একটি `Rc<T>`-কে একটি `Weak<T>`-এ পরিণত করা

এখন পর্যন্ত, আমরা প্রমাণ করেছি যে `Rc::clone` কল করলে `Rc<T>` উদাহরণের `strong_count` বৃদ্ধি পায়, এবং `Rc<T>` উদাহরণ তখনই পরিষ্কার করা হয় যদি এর `strong_count` 0 হয়। আপনি `Rc::downgrade` কল করে এবং `Rc<T>`-এর একটি রেফারেন্স পাস করে `Rc<T>` উদাহরণের ভিতরের মানের একটি _দুর্বল রেফারেন্সও_ তৈরি করতে পারেন। শক্তিশালী রেফারেন্সগুলি হল আপনি কীভাবে একটি `Rc<T>` উদাহরণের মালিকানা ভাগ করতে পারেন। দুর্বল রেফারেন্সগুলি একটি মালিকানার সম্পর্ক প্রকাশ করে না এবং তাদের গণনা `Rc<T>` উদাহরণ কখন পরিষ্কার করা হবে তা প্রভাবিত করে না। তারা একটি রেফারেন্স চক্র তৈরি করবে না কারণ কিছু দুর্বল রেফারেন্স জড়িত যেকোনো চক্র ভেঙে যাবে একবার জড়িত মানগুলির শক্তিশালী রেফারেন্স গণনা 0 হয়ে গেলে।

আপনি যখন `Rc::downgrade` কল করেন, তখন আপনি `Weak<T>` টাইপের একটি স্মার্ট পয়েন্টার পান। `Rc<T>` উদাহরণের `strong_count` 1 করে বাড়ানোর পরিবর্তে, `Rc::downgrade` কল করলে `weak_count` 1 করে বৃদ্ধি পায়। `Rc<T>` টাইপটি `Weak<T>` রেফারেন্স কতগুলি বিদ্যমান তা ট্র্যাক করতে `weak_count` ব্যবহার করে, `strong_count`-এর মতোই। পার্থক্য হল `Rc<T>` উদাহরণটিকে পরিষ্কার করার জন্য `weak_count` 0 হওয়ার প্রয়োজন নেই।

যেহেতু `Weak<T>` যে মানটিকে উল্লেখ করে তা ড্রপ করা হতে পারে, তাই `Weak<T>` যে মানটির দিকে নির্দেশ করছে সেই মানটি দিয়ে কিছু করতে, আপনাকে নিশ্চিত করতে হবে যে মানটি এখনও বিদ্যমান। একটি `Weak<T>` উদাহরণের উপর `upgrade` পদ্ধতি কল করে এটি করুন, যা একটি `Option<Rc<T>>` রিটার্ন করবে। যদি `Rc<T>` মানটি এখনও ড্রপ না হয়ে থাকে তবে আপনি `Some`-এর একটি ফলাফল পাবেন এবং যদি `Rc<T>` মান ড্রপ হয়ে যায় তবে `None`-এর ফলাফল পাবেন। যেহেতু `upgrade` একটি `Option<Rc<T>>` রিটার্ন করে, Rust নিশ্চিত করবে যে `Some` কেস এবং `None` কেস পরিচালনা করা হয়েছে এবং কোনও অবৈধ পয়েন্টার থাকবে না।

উদাহরণস্বরূপ, এমন একটি তালিকা ব্যবহার করার পরিবর্তে যার আইটেমগুলি শুধুমাত্র পরবর্তী আইটেম সম্পর্কে জানে, আমরা একটি গাছ তৈরি করব যার আইটেমগুলি তাদের চাইল্ড আইটেমগুলি _এবং_ তাদের প্যারেন্ট আইটেমগুলি সম্পর্কে জানে।

#### একটি ট্রি ডেটা স্ট্রাকচার তৈরি করা: চাইল্ড নোড সহ একটি `Node`

শুরু করার জন্য, আমরা এমন নোডগুলির সাথে একটি গাছ তৈরি করব যা তাদের চাইল্ড নোডগুলি সম্পর্কে জানে। আমরা `Node` নামের একটি স্ট্রাক্ট তৈরি করব যা এর নিজস্ব `i32` মান এবং এর চাইল্ড `Node` মানগুলির রেফারেন্স ধারণ করে:

<span class="filename">ফাইলের নাম: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:here}}
```

আমরা চাই একটি `Node` যেন তার চাইল্ডদের মালিক হয় এবং আমরা সেই মালিকানা ভেরিয়েবলের সাথে শেয়ার করতে চাই যাতে আমরা সরাসরি গাছের প্রতিটি `Node` অ্যাক্সেস করতে পারি। এটি করার জন্য, আমরা `Vec<T>` আইটেমগুলিকে `Rc<Node>` টাইপের মান হিসাবে সংজ্ঞায়িত করি। আমরা কোন নোডগুলি অন্য নোডের চাইল্ড তাও পরিবর্তন করতে চাই, তাই আমাদের `children`-এ `Vec<Rc<Node>>` এর চারপাশে একটি `RefCell<T>` আছে।

এরপরে, আমরা আমাদের স্ট্রাক্ট সংজ্ঞা ব্যবহার করব এবং 3 মান এবং কোনো চাইল্ড ছাড়া `leaf` নামের একটি `Node` উদাহরণ এবং 5 মান এবং `leaf`-কে তার চাইল্ডদের মধ্যে একটি হিসাবে `branch` নামের আরেকটি উদাহরণ তৈরি করব, যেমন Listing 15-27-এ দেখানো হয়েছে:

<Listing number="15-27" file-name="src/main.rs" caption="কোনো চাইল্ড ছাড়া একটি `leaf` নোড তৈরি করা এবং `leaf`-কে তার চাইল্ডদের মধ্যে একটি হিসাবে একটি `branch` নোড তৈরি করা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-27/src/main.rs:there}}
```

</Listing>

আমরা `leaf`-এর `Rc<Node>` ক্লোন করি এবং তা `branch`-এ সংরক্ষণ করি, যার মানে `leaf`-এর `Node`-এর এখন দুটি মালিক আছে: `leaf` এবং `branch`। আমরা `branch.children`-এর মাধ্যমে `branch` থেকে `leaf`-এ যেতে পারি, কিন্তু `leaf` থেকে `branch`-এ যাওয়ার কোনো উপায় নেই। কারণ হল `leaf`-এর `branch`-এর কোনো রেফারেন্স নেই এবং তারা সম্পর্কিত কিনা তা জানে না। আমরা চাই `leaf` জানুক যে `branch` হল এর প্যারেন্ট। আমরা এরপর সেটি করব।

#### চাইল্ড থেকে প্যারেন্টের রেফারেন্স যোগ করা

চাইল্ড নোডকে তার প্যারেন্ট সম্পর্কে সচেতন করতে, আমাদের `Node` স্ট্রাক্ট সংজ্ঞায় একটি `parent` ফিল্ড যোগ করতে হবে। সমস্যা হল `parent`-এর টাইপ কী হওয়া উচিত তা নির্ধারণ করা। আমরা জানি যে এটি একটি `Rc<T>` ধারণ করতে পারে না, কারণ এটি `leaf.parent` `branch`-এর দিকে নির্দেশ করে এবং `branch.children` `leaf`-এর দিকে নির্দেশ করে একটি রেফারেন্স চক্র তৈরি করবে, যার কারণে তাদের `strong_count` মান কখনই 0 হবে না।

সম্পর্কগুলিকে অন্যভাবে চিন্তা করলে, একটি প্যারেন্ট নোডের তার চাইল্ডদের মালিক হওয়া উচিত: যদি একটি প্যারেন্ট নোড ড্রপ করা হয়, তবে তার চাইল্ড নোডগুলিও ড্রপ করা উচিত। যাইহোক, একটি চাইল্ডের তার প্যারেন্টের মালিক হওয়া উচিত নয়: যদি আমরা একটি চাইল্ড নোড ড্রপ করি, তাহলে প্যারেন্টটি এখনও বিদ্যমান থাকা উচিত। এটি দুর্বল রেফারেন্সের জন্য একটি ক্ষেত্র!

সুতরাং `Rc<T>`-এর পরিবর্তে, আমরা `parent`-এর টাইপকে `Weak<T>` ব্যবহার করব, বিশেষভাবে একটি `RefCell<Weak<Node>>`। এখন আমাদের `Node` স্ট্রাক্ট সংজ্ঞাটি এইরকম দেখাচ্ছে:

<span class="filename">ফাইলের নাম: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:here}}
```

একটি নোড তার প্যারেন্ট নোডকে উল্লেখ করতে সক্ষম হবে কিন্তু তার প্যারেন্টের মালিক নয়। Listing 15-28-এ, আমরা `main` আপডেট করি এই নতুন সংজ্ঞাটি ব্যবহার করতে যাতে `leaf` নোডের তার প্যারেন্ট, `branch`-কে উল্লেখ করার একটি উপায় থাকে:

<Listing number="15-28" file-name="src/main.rs" caption="একটি `leaf` নোড যার প্যারেন্ট নোড `branch`-এর দুর্বল রেফারেন্স রয়েছে">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-28/src/main.rs:there}}
```

</Listing>

`leaf` নোড তৈরি করা `parent` ফিল্ডটি ছাড়া Listing 15-27-এর মতোই দেখায়: `leaf` একটি প্যারেন্ট ছাড়াই শুরু হয়, তাই আমরা একটি নতুন, খালি `Weak<Node>` রেফারেন্স উদাহরণ তৈরি করি।

এই মুহুর্তে, যখন আমরা `upgrade` পদ্ধতি ব্যবহার করে `leaf`-এর প্যারেন্টের একটি রেফারেন্স পাওয়ার চেষ্টা করি, তখন আমরা একটি `None` মান পাই। আমরা প্রথম `println!` স্টেটমেন্ট থেকে আউটপুটে এটি দেখতে পাই:

```text
leaf parent = None
```

যখন আমরা `branch` নোড তৈরি করি, তখন এর `parent` ফিল্ডেও একটি নতুন `Weak<Node>` রেফারেন্স থাকবে, কারণ `branch`-এর কোনো প্যারেন্ট নোড নেই। আমাদের এখনও `leaf` `branch`-এর চাইল্ডদের মধ্যে একজন হিসাবে আছে। একবার `branch`-এ `Node` উদাহরণটি হয়ে গেলে, আমরা `leaf`-কে পরিবর্তন করতে পারি এটিকে তার প্যারেন্টের একটি `Weak<Node>` রেফারেন্স দিতে। আমরা `leaf`-এর `parent` ফিল্ডে থাকা `RefCell<Weak<Node>>`-এ `borrow_mut` পদ্ধতিটি ব্যবহার করি এবং তারপরে আমরা `branch`-এর `Rc<Node>` থেকে `branch`-এর একটি `Weak<Node>` রেফারেন্স তৈরি করতে `Rc::downgrade` ফাংশনটি ব্যবহার করি।

যখন আমরা আবার `leaf`-এর প্যারেন্ট প্রিন্ট করি, তখন আমরা `branch` ধারণ করে একটি `Some` ভেরিয়েন্ট পাব: এখন `leaf` তার প্যারেন্ট অ্যাক্সেস করতে পারে! যখন আমরা `leaf` প্রিন্ট করি, তখন আমরা সেই চক্রটিকেও এড়িয়ে যাই যা অবশেষে Listing 15-26-এর মতো স্ট্যাক উপচে পড়ার মাধ্যমে শেষ হয়েছিল; `Weak<Node>` রেফারেন্সগুলি `(Weak)` হিসাবে প্রিন্ট করা হয়:

```text
leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
```

অসীম আউটপুটের অভাব ইঙ্গিত করে যে এই কোডটি একটি রেফারেন্স চক্র তৈরি করেনি। আমরা `Rc::strong_count` এবং `Rc::weak_count` কল করে যে মানগুলি পাই তাও দেখে এটি বলতে পারি।

#### `strong_count` এবং `weak_count`-এ পরিবর্তনের ভিজ্যুয়ালাইজেশন

আসুন দেখে নেওয়া যাক `Rc<Node>` উদাহরণের `strong_count` এবং `weak_count` মানগুলি একটি নতুন ভিতরের স্কোপ তৈরি করে এবং সেই স্কোপে `branch` তৈরি করার মাধ্যমে কীভাবে পরিবর্তিত হয়। এটি করার মাধ্যমে, আমরা দেখতে পারি যখন `branch` তৈরি করা হয় এবং তারপরে যখন এটি স্কোপের বাইরে চলে যায় তখন কী ঘটে। পরিবর্তনগুলি Listing 15-29-এ দেখানো হয়েছে:

<Listing number="15-29" file-name="src/main.rs" caption="একটি ভিতরের স্কোপে `branch` তৈরি করা এবং শক্তিশালী ও দুর্বল রেফারেন্স গণনা পরীক্ষা করা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-29/src/main.rs:here}}
```

</Listing>

`leaf` তৈরি হওয়ার পরে, এর `Rc<Node>`-এর একটি শক্তিশালী গণনা 1 এবং একটি দুর্বল গণনা 0। ভিতরের স্কোপে, আমরা `branch` তৈরি করি এবং এটিকে `leaf`-এর সাথে যুক্ত করি, সেই সময়ে যখন আমরা গণনাগুলি প্রিন্ট করি, তখন `branch`-এর `Rc<Node>`-এর একটি শক্তিশালী গণনা 1 এবং একটি দুর্বল গণনা 1 থাকবে (`Weak<Node>` দিয়ে `branch`-এর দিকে নির্দেশিত `leaf.parent`-এর জন্য)। যখন আমরা `leaf`-এ গণনা প্রিন্ট করি, তখন আমরা দেখতে পাব যে এটির একটি শক্তিশালী গণনা 2 থাকবে, কারণ `branch` এখন `branch.children`-এ সংরক্ষিত `leaf`-এর `Rc<Node>`-এর একটি ক্লোন রয়েছে, তবে এটির দুর্বল গণনা এখনও 0 থাকবে।

যখন ভিতরের স্কোপ শেষ হয়, তখন `branch` স্কোপের বাইরে চলে যায় এবং `Rc<Node>`-এর শক্তিশালী গণনা 0-এ কমে যায়, তাই এর `Node` ড্রপ করা হয়। `leaf.parent` থেকে দুর্বল গণনা 1 এর `Node` ড্রপ করা হবে কিনা তার উপর কোনো প্রভাব নেই, তাই আমরা কোনো মেমরি লিক পাই না!

যদি আমরা স্কোপের শেষের পরে `leaf`-এর প্যারেন্ট অ্যাক্সেস করার চেষ্টা করি, তাহলে আমরা আবার `None` পাব। প্রোগ্রামের শেষে, `leaf`-এর `Rc<Node>`-এর একটি শক্তিশালী গণনা 1 এবং একটি দুর্বল গণনা 0 রয়েছে, কারণ ভেরিয়েবল `leaf` এখন আবার `Rc<Node>`-এর একমাত্র রেফারেন্স।

গণনা এবং মান ড্রপ করার জন্য যে সমস্ত লজিক পরিচালনা করে তা `Rc<T>` এবং `Weak<T>` এবং `Drop` trait-এর তাদের বাস্তবায়নে তৈরি করা হয়েছে। `Node`-এর সংজ্ঞায় একটি চাইল্ড থেকে তার প্যারেন্টের সম্পর্ককে একটি `Weak<T>` রেফারেন্স হিসাবে নির্দিষ্ট করে, আপনি একটি রেফারেন্স চক্র এবং মেমরি লিক তৈরি না করেই প্যারেন্ট নোডগুলিকে চাইল্ড নোডগুলির দিকে নির্দেশ করতে এবং এর বিপরীতে সক্ষম করতে পারেন।

## সারসংক্ষেপ

এই অধ্যায়ে আলোচনা করা হয়েছে কিভাবে নিয়মিত রেফারেন্সের সাথে ডিফল্টভাবে Rust যা তৈরি করে তার থেকে আলাদা গ্যারান্টি এবং ট্রেড-অফ করতে স্মার্ট পয়েন্টার ব্যবহার করতে হয়। `Box<T>` টাইপের একটি পরিচিত আকার আছে এবং এটি হিপে বরাদ্দ করা ডেটার দিকে নির্দেশ করে। `Rc<T>` টাইপ হিপের ডেটার রেফারেন্সের সংখ্যা ট্র্যাক করে যাতে ডেটার একাধিক মালিক থাকতে পারে। `RefCell<T>` টাইপ তার অভ্যন্তরীণ পরিবর্তনশীলতার সাথে আমাদের এমন একটি টাইপ দেয় যা আমরা ব্যবহার করতে পারি যখন আমাদের একটি অপরিবর্তনীয় টাইপের প্রয়োজন হয় কিন্তু সেই টাইপের একটি ভিতরের মান পরিবর্তন করতে হয়; এটি কম্পাইল করার সময়ের পরিবর্তে রানটাইমে ধার করার নিয়মগুলিও প্রয়োগ করে।

`Deref` এবং `Drop` traitগুলিও আলোচনা করা হয়েছিল, যা স্মার্ট পয়েন্টারগুলির অনেক কার্যকারিতা সক্ষম করে। আমরা রেফারেন্স চক্রগুলি নিয়ে আলোচনা করেছি যা মেমরি লিক ঘটাতে পারে এবং কীভাবে `Weak<T>` ব্যবহার করে সেগুলি প্রতিরোধ করা যায়।

যদি এই অধ্যায়টি আপনার আগ্রহ জাগিয়ে তোলে এবং আপনি নিজের স্মার্ট পয়েন্টারগুলি বাস্তবায়ন করতে চান, তবে আরও দরকারী তথ্যের জন্য [“The Rustonomicon”][nomicon] দেখুন।

পরবর্তীতে, আমরা Rust-এ কনকারেন্সি নিয়ে কথা বলব। আপনি এমনকি কয়েকটি নতুন স্মার্ট পয়েন্টার সম্পর্কেও জানতে পারবেন।

[nomicon]: ../nomicon/index.html
