## `panic!` এর সাথে অপুনরুদ্ধারযোগ্য ত্রুটি

মাঝে মাঝে আপনার কোডে খারাপ কিছু ঘটে এবং আপনি সে সম্পর্কে কিছুই করতে পারেন না। এই ক্ষেত্রে, Rust এ `panic!` macro আছে। বাস্তবে panic সৃষ্টি করার দুটি উপায় আছে: এমন একটি কাজ করা যা আমাদের কোডটিকে panic করে (যেমন একটি অ্যারের শেষ সীমার বাইরে অ্যাক্সেস করা) অথবা স্পষ্টভাবে `panic!` macro কল করা। উভয় ক্ষেত্রেই, আমরা আমাদের প্রোগ্রামে panic সৃষ্টি করি। ডিফল্টরূপে, এই panic গুলি একটি ব্যর্থতার বার্তা প্রিন্ট করবে, unwind করবে, স্ট্যাক পরিষ্কার করবে এবং প্রস্থান করবে। একটি এনভায়রনমেন্ট ভেরিয়েবলের মাধ্যমে, Rust একটি panic ঘটলে কল স্ট্যাক প্রদর্শন করতে পারে যাতে panic এর উৎস খুঁজে বের করা সহজ হয়।

> ### একটি Panic এর প্রতিক্রিয়ায় স্ট্যাক আনওয়াইন্ডিং বা বাতিল করা
>
> ডিফল্টরূপে, যখন একটি panic ঘটে তখন প্রোগ্রামটি _unwinding_ শুরু করে, যার মানে Rust স্ট্যাকের পিছনের দিকে হেঁটে এবং এটির সম্মুখীন হওয়া প্রতিটি ফাংশন থেকে ডেটা পরিষ্কার করে। যাইহোক, পিছনে হেঁটে পরিষ্কার করা অনেক কাজ। তাই Rust আপনাকে অবিলম্বে _aborting_ এর বিকল্প বেছে নিতে দেয়, যা পরিষ্কার না করেই প্রোগ্রামটি শেষ করে।
>
> প্রোগ্রামটি যে মেমরি ব্যবহার করছিল তা তখন অপারেটিং সিস্টেম দ্বারা পরিষ্কার করতে হবে। আপনার প্রজেক্টে যদি আপনি ফলস্বরূপ বাইনারিটিকে যতটা সম্ভব ছোট করতে চান তবে আপনি আপনার _Cargo.toml_ ফাইলের উপযুক্ত `[profile]` বিভাগে `panic = 'abort'` যোগ করে একটি panic এর পরে unwinding থেকে aborting এ স্যুইচ করতে পারেন। উদাহরণস্বরূপ, আপনি যদি রিলিজ মোডে panic এর উপর abort করতে চান তবে এটি যোগ করুন:
>
> ```toml
> [profile.release]
> panic = 'abort'
> ```

আসুন একটি সাধারণ প্রোগ্রামে `panic!` কল করার চেষ্টা করি:

<Listing file-name="src/main.rs">

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-01-panic/src/main.rs}}
```

</Listing>

যখন আপনি প্রোগ্রামটি চালান, তখন আপনি এইরকম কিছু দেখতে পাবেন:

```console
{{#include ../listings/ch09-error-handling/no-listing-01-panic/output.txt}}
```

`panic!` এ কল করা শেষ দুটি লাইনে থাকা ত্রুটি বার্তার কারণ। প্রথম লাইনটি আমাদের panic বার্তা এবং আমাদের সোর্স কোডের সেই স্থানটি দেখায় যেখানে panic ঘটেছে: _src/main.rs:2:5_ নির্দেশ করে যে এটি আমাদের _src/main.rs_ ফাইলের দ্বিতীয় লাইন, পঞ্চম অক্ষর।

এই ক্ষেত্রে, নির্দেশিত লাইনটি আমাদের কোডের অংশ, এবং যদি আমরা সেই লাইনে যাই, তবে আমরা `panic!` macro কলটি দেখতে পাই। অন্যান্য ক্ষেত্রে, `panic!` কলটি এমন কোডে থাকতে পারে যা আমাদের কোড কল করে, এবং ত্রুটি বার্তায় রিপোর্ট করা ফাইল এবং লাইন নম্বরটি অন্য কারো কোড হবে যেখানে `panic!` macro কল করা হয়েছে, আমাদের কোডের সেই লাইনটি নয় যা শেষ পর্যন্ত `panic!` কল করার দিকে নিয়ে গেছে।

<!-- Old heading. Do not remove or links may break. -->

<a id="using-a-panic-backtrace"></a>

আমরা `panic!` কলটি কোথা থেকে এসেছে সেই ফাংশনগুলির ব্যাকট্রেস ব্যবহার করতে পারি আমাদের কোডের সেই অংশটি বের করার জন্য যা সমস্যার কারণ। `panic!` backtrace কিভাবে ব্যবহার করতে হয় তা বোঝার জন্য, আসুন অন্য একটি উদাহরণ দেখি এবং দেখি যখন আমাদের কোডের সরাসরি macro কল করার পরিবর্তে আমাদের কোডে বাগের কারণে একটি লাইব্রেরি থেকে `panic!` কল আসে তখন এটি কেমন হয়। Listing 9-1 এ এমন কিছু কোড রয়েছে যা বৈধ ইন্ডেক্সের সীমার বাইরে একটি ভেক্টরের একটি ইন্ডেক্স অ্যাক্সেস করার চেষ্টা করে।

<Listing number="9-1" file-name="src/main.rs" caption="একটি ভেক্টরের শেষ সীমার বাইরের একটি উপাদান অ্যাক্সেস করার চেষ্টা, যা `panic!` এ কল করার কারণ হবে">

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-01/src/main.rs}}
```

</Listing>

এখানে, আমরা আমাদের ভেক্টরের 100 তম উপাদানটি অ্যাক্সেস করার চেষ্টা করছি (যা 99 নম্বর ইন্ডেক্সে কারণ ইন্ডেক্সিং শূন্য থেকে শুরু হয়), তবে ভেক্টরটিতে মাত্র তিনটি উপাদান রয়েছে। এই পরিস্থিতিতে, Rust panic করবে। `[]` একটি উপাদান ফেরত দেওয়ার কথা, তবে আপনি যদি একটি অবৈধ ইন্ডেক্স পাস করেন, তবে Rust এখানে এমন কোনো উপাদান ফেরত দিতে পারবে না যা সঠিক হবে।

C তে, ডেটা স্ট্রাকচারের শেষ সীমার বাইরে পড়তে চেষ্টা করা undefined আচরণ। আপনি সেই মেমরির অবস্থানে যা আছে তাই পেতে পারেন যা ডেটা স্ট্রাকচারে সেই উপাদানের সাথে সঙ্গতিপূর্ণ, যদিও মেমরি সেই কাঠামোর অন্তর্গত নয়। এটিকে _buffer overread_ বলা হয় এবং এটি নিরাপত্তা দুর্বলতার দিকে নিয়ে যেতে পারে যদি কোনো আক্রমণকারী এমনভাবে ইন্ডেক্সটিকে ম্যানিপুলেট করতে সক্ষম হয় যাতে তারা ডেটা স্ট্রাকচারের পরে স্টোর করা উচিত নয় এমন ডেটা পড়তে পারে।

আপনার প্রোগ্রামটিকে এই ধরনের দুর্বলতা থেকে রক্ষা করার জন্য, আপনি যদি এমন একটি ইন্ডেক্সে একটি উপাদান পড়ার চেষ্টা করেন যা বিদ্যমান নেই, Rust এক্সিকিউশন বন্ধ করে দেবে এবং চালিয়ে যেতে অস্বীকার করবে। আসুন চেষ্টা করে দেখি:

```console
{{#include ../listings/ch09-error-handling/listing-09-01/output.txt}}
```

এই ত্রুটিটি আমাদের _main.rs_ এর 4 নম্বর লাইনের দিকে নির্দেশ করে যেখানে আমরা `v`-এ ভেক্টরের `99` নম্বর ইন্ডেক্সটি অ্যাক্সেস করার চেষ্টা করি।

`note:` লাইনটি আমাদের জানায় যে আমরা কী কারণে ত্রুটি ঘটেছে তা জানতে `RUST_BACKTRACE` এনভায়রনমেন্ট ভেরিয়েবল সেট করতে পারি। একটি _backtrace_ হল সেই সমস্ত ফাংশনের একটি তালিকা যা এই পয়েন্টে পৌঁছানোর জন্য কল করা হয়েছে। Rust এ ব্যাকট্রেস অন্যান্য ভাষার মতোই কাজ করে: ব্যাকট্রেস পড়ার মূল বিষয় হল উপরে থেকে শুরু করা এবং আপনি নিজের লেখা ফাইলগুলি না দেখা পর্যন্ত পড়া। সেখানেই সমস্যার উৎপত্তি। সেই স্থানের উপরের লাইনগুলি হল কোড যা আপনার কোড কল করেছে; নীচের লাইনগুলি হল সেই কোড যা আপনার কোডকে কল করেছে। এই আগের এবং পরের লাইনগুলিতে মূল Rust কোড, standard library কোড বা আপনি যে crates ব্যবহার করছেন সেগুলি অন্তর্ভুক্ত থাকতে পারে। আসুন `RUST_BACKTRACE` এনভায়রনমেন্ট ভেরিয়েবলটিকে `0` ব্যতীত অন্য যেকোনো মান সেট করে একটি ব্যাকট্রেস পাওয়ার চেষ্টা করি। Listing 9-2 এ আপনি যা দেখবেন তার মতো আউটপুট দেখানো হয়েছে।

<!-- manual-regeneration
cd listings/ch09-error-handling/listing-09-01
RUST_BACKTRACE=1 cargo run
copy the backtrace output below
check the backtrace number mentioned in the text below the listing
-->

<Listing number="9-2" caption="পরিবেশ ভেরিয়েবল `RUST_BACKTRACE` সেট করা হলে `panic!` এ কল করার মাধ্যমে তৈরি ব্যাকট্রেস প্রদর্শিত হয়">

```console
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/std/src/panicking.rs:662:5
   1: core::panicking::panic_fmt
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/panicking.rs:74:14
   2: core::panicking::panic_bounds_check
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/panicking.rs:276:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/slice/index.rs:302:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/slice/index.rs:16:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/alloc/src/vec/mod.rs:2920:9
   6: panic::main
             at ./src/main.rs:4:6
   7: core::ops::function::FnOnce::call_once
             at /rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

</Listing>

এটা অনেক আউটপুট! আপনি যে সঠিক আউটপুটটি দেখছেন তা আপনার অপারেটিং সিস্টেম এবং Rust সংস্করণের উপর নির্ভর করে ভিন্ন হতে পারে। এই তথ্য সহ ব্যাকট্রেস পেতে, ডিবাগ চিহ্নগুলি সক্ষম করতে হবে। আমরা এখানে যেভাবে করেছি `--release` ফ্ল্যাগ ছাড়াই `cargo build` বা `cargo run` ব্যবহার করার সময় ডিবাগ চিহ্নগুলি ডিফল্টরূপে সক্ষম করা হয়।

Listing 9-2 এর আউটপুটে, backtrace এর 6 নম্বর লাইনটি আমাদের প্রজেক্টের সেই লাইনটিকে নির্দেশ করে যা সমস্যার কারণ: _src/main.rs_ এর 4 নম্বর লাইন। যদি আমরা আমাদের প্রোগ্রামটিকে panic করতে না দিতে চাই, তাহলে আমাদের এমন জায়গা থেকে আমাদের অনুসন্ধান শুরু করা উচিত যেখানে আমরা লিখেছি এমন একটি ফাইল উল্লেখ করা প্রথম লাইনটি নির্দেশ করে। Listing 9-1 এ, যেখানে আমরা ইচ্ছাকৃতভাবে এমন কোড লিখেছি যা panic করবে, panic ঠিক করার উপায় হল ভেক্টর ইন্ডেক্সের সীমার বাইরের কোনো উপাদানের জন্য অনুরোধ না করা। ভবিষ্যতে আপনার কোড panic করলে, panic এর কারণ হওয়ার জন্য কোডটি কী মান দিয়ে কী পদক্ষেপ নিচ্ছে এবং পরিবর্তে কোডটির কী করা উচিত তা আপনাকে খুঁজে বের করতে হবে।

আমরা `panic!` এবং কখন আমাদের ত্রুটি পরিস্থিতি পরিচালনা করার জন্য `panic!` ব্যবহার করা উচিত এবং কখন করা উচিত নয় সে বিষয়ে এই অধ্যায়ের পরে [“To `panic!` or Not to `panic!`”][to-panic-or-not-to-panic]<!-- ignore --> বিভাগে ফিরে আসব। এরপরে, আমরা `Result` ব্যবহার করে কিভাবে একটি ত্রুটি থেকে পুনরুদ্ধার করতে হয় তা দেখব।

[to-panic-or-not-to-panic]: ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic
