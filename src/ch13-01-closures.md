<!-- Old heading. Do not remove or links may break. -->

<a id="closures-anonymous-functions-that-can-capture-their-environment"></a>

## ক্লোজার: বেনামী ফাংশন যা তাদের এনভায়রনমেন্ট ক্যাপচার করতে পারে

রাস্টের ক্লোজারগুলো হল বেনামী ফাংশন যা আপনি একটি ভেরিয়েবলে সেভ করতে পারেন বা অন্যান্য ফাংশনে আর্গুমেন্ট হিসাবে পাস করতে পারেন। আপনি এক জায়গায় ক্লোজার তৈরি করতে পারেন এবং তারপরে অন্য জায়গায় ক্লোজারটিকে কল করতে পারেন অন্য একটি প্রেক্ষাপটে এটিকে মূল্যায়ন করতে। ফাংশনগুলোর বিপরীতে, ক্লোজারগুলো যে স্কোপে সংজ্ঞায়িত করা হয়েছে সেই স্কোপ থেকে ভ্যালু ক্যাপচার করতে পারে। আমরা দেখাব কিভাবে এই ক্লোজার বৈশিষ্ট্যগুলো কোড পুনর্ব্যবহার এবং আচরণ কাস্টমাইজেশনের অনুমতি দেয়।

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a>

### ক্লোজার দিয়ে এনভায়রনমেন্ট ক্যাপচার করা

আমরা প্রথমে পরীক্ষা করব যে কিভাবে আমরা পরবর্তীতে ব্যবহারের জন্য সংজ্ঞায়িত করা এনভায়রনমেন্ট থেকে ভ্যালু ক্যাপচার করতে ক্লোজারগুলো ব্যবহার করতে পারি। এখানে পরিস্থিতিটি দেওয়া হল: আমাদের টি-শার্ট কোম্পানিটি মাঝে মাঝে আমাদের মেইলিং তালিকার কারোকে একটি বিশেষ, সীমিত সংস্করণের শার্ট উপহার হিসেবে দেয়। মেইলিং তালিকার লোকেরা ঐচ্ছিকভাবে তাদের প্রোফাইলে তাদের পছন্দের রঙ যোগ করতে পারে। বিনামূল্যে শার্টের জন্য নির্বাচিত ব্যক্তির যদি তার পছন্দের রঙ সেট করা থাকে, তবে তারা সেই রঙের শার্ট পায়। যদি ব্যক্তিটি কোনো পছন্দের রঙ নির্দিষ্ট না করে থাকে, তবে কোম্পানি বর্তমানে যে রঙের শার্ট সবচেয়ে বেশি পরিমাণে মজুদ রাখে সেই রঙের শার্ট পায়।

এটি বাস্তবায়নের অনেক উপায় আছে। এই উদাহরণের জন্য, আমরা `ShirtColor` নামের একটি enum ব্যবহার করতে যাচ্ছি, যার ভেরিয়েন্টগুলো হল `Red` এবং `Blue` (সরলতার জন্য উপলব্ধ রঙের সংখ্যা সীমিত করা হয়েছে)। আমরা কোম্পানির ইনভেন্টরিকে `Inventory` struct দিয়ে উপস্থাপন করি যার `shirts` নামের একটি ফিল্ড আছে যাতে স্টকে থাকা শার্টের রঙগুলো উপস্থাপন করে এমন একটি `Vec<ShirtColor>` থাকে। `Inventory`-তে সংজ্ঞায়িত মেথড `giveaway` বিনামূল্যে শার্ট বিজয়ীর ঐচ্ছিক শার্ট রঙের পছন্দটি পায় এবং ব্যক্তিটি কোন রঙের শার্ট পাবে তা রিটার্ন করে। এই সেটআপটি Listing 13-1-এ দেখানো হয়েছে:

<Listing number="13-1" file-name="src/main.rs" caption="শার্ট কোম্পানির উপহারের পরিস্থিতি">

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}
```

</Listing>

`main`-এ সংজ্ঞায়িত `store`-এ এই সীমিত সংস্করণের প্রচারের জন্য বিতরণ করার জন্য দুটি নীল শার্ট এবং একটি লাল শার্ট অবশিষ্ট আছে। আমরা লাল শার্টের পছন্দের একজন ব্যবহারকারী এবং কোনো পছন্দ নেই এমন একজন ব্যবহারকারীর জন্য `giveaway` মেথড কল করি।

আবারও বলছি, এই কোডটি অনেক উপায়ে প্রয়োগ করা যেতে পারত, এবং এখানে, ক্লোজারের উপর ফোকাস করার জন্য, আমরা ক্লোজার ব্যবহার করে `giveaway` মেথডের বডি ছাড়া আপনি ইতিমধ্যে শিখেছেন এমন ধারণাগুলোর সাথেই আটকে আছি। `giveaway` মেথডে, আমরা ব্যবহারকারীর পছন্দ `Option<ShirtColor>` টাইপের প্যারামিটার হিসাবে পাই এবং `user_preference`-এ `unwrap_or_else` মেথড কল করি। [`Option<T>`-এ `unwrap_or_else` মেথড][unwrap-or-else]<!-- ignore --> স্ট্যান্ডার্ড লাইব্রেরি দ্বারা সংজ্ঞায়িত করা হয়েছে। এটি একটি আর্গুমেন্ট নেয়: কোনো আর্গুমেন্ট ছাড়াই একটি ক্লোজার যা একটি ভ্যালু `T` রিটার্ন করে (`Option<T>`-এর `Some` ভেরিয়েন্টে স্টোর করা একই টাইপ, এই ক্ষেত্রে `ShirtColor`)। যদি `Option<T>` `Some` ভেরিয়েন্ট হয়, `unwrap_or_else` `Some`-এর ভিতরের ভ্যালুটি রিটার্ন করে। যদি `Option<T>` `None` ভেরিয়েন্ট হয়, `unwrap_or_else` ক্লোজারটিকে কল করে এবং ক্লোজার দ্বারা রিটার্ন করা ভ্যালুটি রিটার্ন করে।

আমরা ক্লোজার এক্সপ্রেশন `|| self.most_stocked()` `unwrap_or_else`-এর আর্গুমেন্ট হিসাবে উল্লেখ করি। এটি এমন একটি ক্লোজার যা নিজে থেকে কোনো প্যারামিটার নেয় না (ক্লোজারের প্যারামিটার থাকলে, সেগুলো দুটি উল্লম্ব বারের মধ্যে প্রদর্শিত হত)। ক্লোজারের বডি `self.most_stocked()` কল করে। আমরা এখানে ক্লোজারটি সংজ্ঞায়িত করছি এবং `unwrap_or_else`-এর বাস্তবায়নটি ফলাফলের প্রয়োজন হলে পরে ক্লোজারটিকে মূল্যায়ন করবে।

এই কোডটি চালালে প্রিন্ট হবে:

```console
{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
```

এখানে একটি আকর্ষণীয় দিক হল যে আমরা এমন একটি ক্লোজার পাস করেছি যা বর্তমান `Inventory` ইনস্ট্যান্সে `self.most_stocked()` কল করে। স্ট্যান্ডার্ড লাইব্রেরিকে আমাদের সংজ্ঞায়িত করা `Inventory` বা `ShirtColor` টাইপ বা এই পরিস্থিতিতে আমরা যে লজিক ব্যবহার করতে চাইছি সে সম্পর্কে কিছুই জানার প্রয়োজন ছিল না। ক্লোজার `self` `Inventory` ইনস্ট্যান্সের একটি ইমিউটেবল রেফারেন্স ক্যাপচার করে এবং এটিকে `unwrap_or_else` মেথডে আমরা নির্দিষ্ট করা কোডের সাথে পাস করে। অন্যদিকে, ফাংশনগুলো এইভাবে তাদের এনভায়রনমেন্ট ক্যাপচার করতে সক্ষম নয়।

### ক্লোজার টাইপ অনুমান এবং টীকা

ফাংশন এবং ক্লোজারের মধ্যে আরও পার্থক্য রয়েছে। ক্লোজারগুলোর সাধারণত `fn` ফাংশনগুলোর মতো প্যারামিটার বা রিটার্ন ভ্যালুর প্রকারগুলো টীকা করার প্রয়োজন হয় না। ফাংশনগুলোতে টাইপ টীকাগুলোর প্রয়োজন হয় কারণ প্রকারগুলো আপনার ব্যবহারকারীদের কাছে উন্মুক্ত একটি সুস্পষ্ট ইন্টারফেসের অংশ। এই ইন্টারফেসটিকে কঠোরভাবে সংজ্ঞায়িত করা গুরুত্বপূর্ণ যাতে সবাই একটি ফাংশন কোন ধরনের ভ্যালু ব্যবহার করে এবং রিটার্ন করে সে সম্পর্কে একমত হতে পারে। অন্যদিকে, ক্লোজারগুলো এইরকম একটি উন্মুক্ত ইন্টারফেসে ব্যবহার করা হয় না: সেগুলোকে ভেরিয়েবলে স্টোর করা হয় এবং সেগুলোকে নাম না দিয়ে এবং আমাদের লাইব্রেরির ব্যবহারকারীদের কাছে প্রকাশ না করেই ব্যবহার করা হয়।

ক্লোজারগুলো সাধারণত ছোট হয় এবং কোনো নির্বিচারে পরিস্থিতির পরিবর্তে শুধুমাত্র সংকীর্ণ প্রেক্ষাপটের মধ্যেই প্রাসঙ্গিক। এই সীমিত প্রেক্ষাপটের মধ্যে, কম্পাইলার প্যারামিটার এবং রিটার্ন টাইপের প্রকারগুলো অনুমান করতে পারে, অনেকটা যেভাবে এটি বেশিরভাগ ভেরিয়েবলের প্রকারগুলো অনুমান করতে সক্ষম (এমন কিছু বিরল ক্ষেত্র রয়েছে যেখানে কম্পাইলারের ক্লোজার টাইপ টীকাগুলোরও প্রয়োজন হয়)।

ভেরিয়েবলের মতো, আমরা চাইলে আরও বেশি সুস্পষ্টতা এবং স্বচ্ছতার জন্য টাইপ টীকা যোগ করতে পারি এবং এর জন্য কঠোরভাবে প্রয়োজনীয়তার চেয়ে বেশি বিস্তারিত হতে পারি। ক্লোজারের জন্য টাইপ টীকা করলে Listing 13-2-এ দেখানো সংজ্ঞার মতো দেখাবে। এই উদাহরণে, আমরা একটি ক্লোজার সংজ্ঞায়িত করছি এবং এটিকে একটি ভেরিয়েবলে স্টোর করছি, Listing 13-1-এর মতো আর্গুমেন্ট হিসাবে পাস করার জায়গায় ক্লোজারটিকে সংজ্ঞায়িত করার পরিবর্তে।

<Listing number="13-2" file-name="src/main.rs" caption="ক্লোজারে প্যারামিটার এবং রিটার্ন ভ্যালু টাইপের ঐচ্ছিক টাইপ টীকা যোগ করা">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
```

</Listing>

টাইপ টীকা যোগ করার সাথে, ক্লোজারের সিনট্যাক্স ফাংশনের সিনট্যাক্সের মতো আরও বেশি দেখায়। এখানে আমরা একটি ফাংশন সংজ্ঞায়িত করি যা এর প্যারামিটারে 1 যোগ করে এবং একটি ক্লোজার যা তুলনার জন্য একই আচরণ করে। প্রাসঙ্গিক অংশগুলোকে সারিবদ্ধ করতে আমরা কিছু স্পেস যোগ করেছি। এটি দেখায় যে পাইপগুলোর ব্যবহার এবং ঐচ্ছিক সিনট্যাক্সের পরিমাণ ছাড়া ক্লোজার সিনট্যাক্স ফাংশন সিনট্যাক্সের সাথে কতটা মিল:

```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

প্রথম লাইনটি একটি ফাংশনের সংজ্ঞা দেখায় এবং দ্বিতীয় লাইনটি সম্পূর্ণরূপে টীকা করা একটি ক্লোজারের সংজ্ঞা দেখায়। তৃতীয় লাইনে, আমরা ক্লোজার সংজ্ঞা থেকে টাইপ টীকাগুলো সরিয়ে দিই। চতুর্থ লাইনে, আমরা বন্ধনীগুলো সরিয়ে দিই, যেগুলো ঐচ্ছিক কারণ ক্লোজারের বডিতে শুধুমাত্র একটি এক্সপ্রেশন আছে। এগুলো সবই বৈধ সংজ্ঞা যা কল করার সময় একই আচরণ তৈরি করবে। `add_one_v3` এবং `add_one_v4` লাইনগুলোর কম্পাইল করার জন্য ক্লোজারগুলোর মূল্যায়ন করা প্রয়োজন কারণ প্রকারগুলো তাদের ব্যবহার থেকে অনুমান করা হবে। এটি `let v = Vec::new();`-এর মতোই, যার জন্য রাস্টের টাইপ অনুমান করার জন্য হয় টাইপ টীকা বা `Vec`-এ কোনো টাইপের ভ্যালু ঢোকানোর প্রয়োজন।

ক্লোজার সংজ্ঞাগুলোর জন্য, কম্পাইলার তাদের প্যারামিটারগুলোর প্রত্যেকটির জন্য এবং তাদের রিটার্ন ভ্যালুর জন্য একটি কংক্রিট টাইপ অনুমান করবে। উদাহরণস্বরূপ, Listing 13-3-এ একটি ছোট ক্লোজারের সংজ্ঞা দেখানো হয়েছে যা প্যারামিটার হিসাবে প্রাপ্ত ভ্যালুটি রিটার্ন করে। এই ক্লোজারটি এই উদাহরণের উদ্দেশ্য ছাড়া খুব বেশি কাজে লাগে না। মনে রাখবেন যে আমরা সংজ্ঞাতে কোনো টাইপ টীকা যোগ করিনি। যেহেতু কোনো টাইপ টীকা নেই, তাই আমরা ক্লোজারটিকে যেকোনো টাইপ দিয়ে কল করতে পারি, যা আমরা এখানে প্রথমবার `String` দিয়ে করেছি। এর পরে যদি আমরা একটি পূর্ণসংখ্যা দিয়ে `example_closure` কল করার চেষ্টা করি, তাহলে আমরা একটি এরর পাব।

<Listing number="13-3" file-name="src/main.rs" caption="একটি ক্লোজারকে কল করার চেষ্টা করা যার প্রকারগুলো দুটি ভিন্ন প্রকারের সাথে অনুমান করা হয়েছে">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}
```

</Listing>

কম্পাইলার আমাদের এই এররটি দেয়:

```console
{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}
```

আমরা যখন প্রথমবার `String` ভ্যালু দিয়ে `example_closure` কল করি, তখন কম্পাইলার `x`-এর টাইপ এবং ক্লোজারের রিটার্ন টাইপ `String` হিসাবে অনুমান করে। সেই প্রকারগুলো তখন `example_closure`-এর ক্লোজারে লক হয়ে যায় এবং তারপরে আমরা যখন একই ক্লোজারের সাথে একটি ভিন্ন প্রকার ব্যবহার করার চেষ্টা করি তখন আমরা একটি টাইপ এরর পাই।

### রেফারেন্স ক্যাপচার করা বা মালিকানা সরানো

ক্লোজারগুলো তিনটি উপায়ে তাদের এনভায়রনমেন্ট থেকে ভ্যালু ক্যাপচার করতে পারে, যা সরাসরি তিনটি উপায়ের সাথে ম্যাপ করে যেভাবে একটি ফাংশন একটি প্যারামিটার নিতে পারে: ইমিউটেবল ধার করা, মিউটেবল ধার করা এবং মালিকানা নেওয়া। ক্লোজারটি কোনগুলো ব্যবহার করবে তা সেই ফাংশনের বডি ক্যাপচার করা ভ্যালুগুলোর সাথে কী করে তার উপর ভিত্তি করে সিদ্ধান্ত নেবে।

Listing 13-4-এ, আমরা একটি ক্লোজার সংজ্ঞায়িত করি যা `list` নামের ভেক্টরের একটি ইমিউটেবল রেফারেন্স ক্যাপচার করে কারণ এটির ভ্যালু প্রিন্ট করার জন্য শুধুমাত্র একটি ইমিউটেবল রেফারেন্স প্রয়োজন:

<Listing number="13-4" file-name="src/main.rs" caption="একটি ক্লোজার সংজ্ঞায়িত এবং কল করা যা একটি ইমিউটেবল রেফারেন্স ক্যাপচার করে">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}
```

</Listing>

এই উদাহরণটি আরও দেখায় যে একটি ভেরিয়েবল একটি ক্লোজার সংজ্ঞার সাথে বাইন্ড করতে পারে এবং আমরা পরে ভেরিয়েবলের নাম এবং বন্ধনী ব্যবহার করে ক্লোজারটিকে কল করতে পারি যেন ভেরিয়েবলের নামটি একটি ফাংশনের নাম।

যেহেতু আমরা একই সময়ে `list`-এর একাধিক ইমিউটেবল রেফারেন্স রাখতে পারি, তাই ক্লোজার সংজ্ঞা দেওয়ার আগে, ক্লোজার সংজ্ঞা দেওয়ার পরে কিন্তু ক্লোজার কল করার আগে এবং ক্লোজার কল করার পরে `list` কোড থেকে অ্যাক্সেসযোগ্য থাকে। এই কোডটি কম্পাইল হয়, চলে এবং প্রিন্ট করে:

```console
{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}
```

এরপর, Listing 13-5-এ, আমরা ক্লোজারের বডি পরিবর্তন করি যাতে এটি `list` ভেক্টরে একটি উপাদান যোগ করে। ক্লোজারটি এখন একটি মিউটেবল রেফারেন্স ক্যাপচার করে:

<Listing number="13-5" file-name="src/main.rs" caption="একটি ক্লোজার সংজ্ঞায়িত এবং কল করা যা একটি মিউটেবল রেফারেন্স ক্যাপচার করে">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}
```

</Listing>

এই কোডটি কম্পাইল হয়, চলে এবং প্রিন্ট করে:

```console
{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}
```

মনে রাখবেন যে `borrows_mutably` ক্লোজারের সংজ্ঞা এবং কলের মধ্যে আর কোনো `println!` নেই: যখন `borrows_mutably` সংজ্ঞায়িত করা হয়, তখন এটি `list`-এর একটি মিউটেবল রেফারেন্স ক্যাপচার করে। আমরা ক্লোজারটি কল করার পরে আর ক্লোজারটি ব্যবহার করি না, তাই মিউটেবল বরো শেষ হয়। ক্লোজার সংজ্ঞা এবং ক্লোজার কলের মধ্যে, প্রিন্ট করার জন্য একটি ইমিউটেবল বরো অনুমোদিত নয় কারণ যখন একটি মিউটেবল বরো থাকে তখন অন্য কোনো বরো অনুমোদিত নয়। আপনি কী এরর বার্তা পান তা দেখতে সেখানে একটি `println!` যোগ করার চেষ্টা করুন!

যদি আপনি ক্লোজারটিকে এনভায়রনমেন্টে ব্যবহৃত ভ্যালুগুলোর মালিকানা নিতে বাধ্য করতে চান যদিও ক্লোজারের বডির কঠোরভাবে মালিকানার প্রয়োজন নেই, তবে আপনি প্যারামিটার তালিকার আগে `move` কিওয়ার্ড ব্যবহার করতে পারেন।

এই কৌশলটি মূলত তখনই উপযোগী যখন ডেটা সরানোর জন্য একটি নতুন থ্রেডে ক্লোজার পাস করা হয় যাতে এটি নতুন থ্রেডের মালিকানাধীন হয়। আমরা Chapter 16-এ থ্রেডগুলো নিয়ে বিস্তারিত আলোচনা করব যখন আমরা কনকারেন্সি নিয়ে কথা বলব এবং কেন আপনি সেগুলো ব্যবহার করতে চাইবেন, তবে আপাতত, আসুন `move` কিওয়ার্ড প্রয়োজন এমন একটি ক্লোজার ব্যবহার করে একটি নতুন থ্রেড স্পন করা সংক্ষেপে অন্বেষণ করি। Listing 13-6 Listing 13-4-এর একটি পরিবর্তিত সংস্করণ দেখায় যেখানে মূল থ্রেডের পরিবর্তে একটি নতুন থ্রেডে ভেক্টরটি প্রিন্ট করা হয়েছে:

<Listing number="13-6" file-name="src/main.rs" caption="থ্রেডের জন্য ক্লোজারটিকে `list`-এর মালিকানা নিতে বাধ্য করতে `move` ব্যবহার করা">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}
```

</Listing>

আমরা একটি নতুন থ্রেড স্পন করি, থ্রেডটিকে আর্গুমেন্ট হিসাবে চালানোর জন্য একটি ক্লোজার দিই। ক্লোজার বডি তালিকাটি প্রিন্ট করে। Listing 13-4-এ, ক্লোজারটি `list` প্রিন্ট করার জন্য প্রয়োজনীয় সর্বনিম্ন অ্যাক্সেস হওয়ার কারণে শুধুমাত্র একটি ইমিউটেবল রেফারেন্স ব্যবহার করে `list` ক্যাপচার করেছে। এই উদাহরণে, যদিও ক্লোজারের বডির এখনও শুধুমাত্র একটি ইমিউটেবল রেফারেন্সের প্রয়োজন, তবুও আমাদের ক্লোজার সংজ্ঞার শুরুতে `move` কিওয়ার্ডটি লিখে নির্দিষ্ট করতে হবে যে `list` কে ক্লোজারের মধ্যে সরিয়ে নেওয়া উচিত। নতুন থ্রেডটি মূল থ্রেডের বাকি অংশ শেষ হওয়ার আগে শেষ হতে পারে বা মূল থ্রেডটি আগে শেষ হতে পারে। যদি মূল থ্রেডটি `list`-এর মালিকানা বজায় রাখে কিন্তু নতুন থ্রেডটি শেষ হওয়ার আগে শেষ হয়ে যায় এবং `list` ড্রপ করে, তাহলে থ্রেডের ইমিউটেবল রেফারেন্সটি অবৈধ হবে। অতএব, কম্পাইলারের প্রয়োজন যে নতুন থ্রেডে দেওয়া ক্লোজারের মধ্যে `list` সরিয়ে নেওয়া উচিত যাতে রেফারেন্সটি বৈধ হয়। `move` কিওয়ার্ডটি সরিয়ে বা ক্লোজার সংজ্ঞায়িত হওয়ার পরে মূল থ্রেডে `list` ব্যবহার করে আপনি কী কম্পাইলার এরর পান তা দেখার চেষ্টা করুন!

<!-- Old headings. Do not remove or links may break. -->

<a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>

### ক্লোজার থেকে ক্যাপচার করা ভ্যালু সরানো এবং `Fn` ট্রেট

একবার একটি ক্লোজার একটি রেফারেন্স ক্যাপচার করলে বা ক্লোজারটি সংজ্ঞায়িত করা হয়েছে এমন এনভায়রনমেন্ট থেকে একটি ভ্যালুর মালিকানা ক্যাপচার করলে (ফলে ক্লোজারে _কী_ সরানো হয়েছে তা প্রভাবিত করে), ক্লোজারের বডির কোডটি নির্ধারণ করে যে ক্লোজারটি পরে মূল্যায়ন করার সময় রেফারেন্স বা ভ্যালুগুলোর কী হয় (ফলে ক্লোজার থেকে _কী_ সরানো হয়েছে তা প্রভাবিত করে)। একটি ক্লোজার বডি নিম্নলিখিত যেকোনো কাজ করতে পারে: ক্যাপচার করা ভ্যালুকে ক্লোজার থেকে সরিয়ে নিতে পারে, ক্যাপচার করা ভ্যালুকে পরিবর্তন করতে পারে, ভ্যালুকে না সরাতে বা পরিবর্তন করতে পারে, বা শুরুতেই এনভায়রনমেন্ট থেকে কিছুই ক্যাপচার করতে না পারে।

একটি ক্লোজার কীভাবে এনভায়রনমেন্ট থেকে ভ্যালু ক্যাপচার করে এবং পরিচালনা করে তা প্রভাবিত করে ক্লোজারটি কোন ট্রেটগুলো প্রয়োগ করে এবং ট্রেটগুলো হল ফাংশন এবং struct-গুলো কীভাবে নির্দিষ্ট করতে পারে যে তারা কোন ধরণের ক্লোজার ব্যবহার করতে পারে। ক্লোজারগুলো স্বয়ংক্রিয়ভাবে এই তিনটি `Fn` ট্রেটের একটি, দুটি বা তিনটি প্রয়োগ করবে, সংযোজনমূলকভাবে, ক্লোজারের বডি ভ্যালুগুলো কীভাবে পরিচালনা করে তার উপর নির্ভর করে:

1. `FnOnce` उन ক্লোজারগুলোতে প্রয়োগ করা হয় যা একবার কল করা যেতে পারে। সমস্ত ক্লোজার অন্তত এই ট্রেটটি প্রয়োগ করে, কারণ সমস্ত ক্লোজারকে কল করা যেতে পারে। একটি ক্লোজার যা তার বডি থেকে ক্যাপচার করা ভ্যালু সরিয়ে নেয় তা শুধুমাত্র `FnOnce` প্রয়োগ করবে এবং অন্য কোনো `Fn` ট্রেট প্রয়োগ করবে না, কারণ এটিকে শুধুমাত্র একবার কল করা যেতে পারে।
2. `FnMut` उन ক্লোজারগুলোতে প্রয়োগ করা হয় যা তাদের বডি থেকে ক্যাপচার করা ভ্যালু সরিয়ে নেয় না, তবে ক্যাপচার করা ভ্যালুগুলোকে পরিবর্তন করতে পারে। এই ক্লোজারগুলোকে একাধিকবার কল করা যেতে পারে।
3. `Fn` उन ক্লোজারগুলোতে প্রয়োগ করা হয় যা তাদের বডি থেকে ক্যাপচার করা ভ্যালু সরিয়ে নেয় না এবং ক্যাপচার করা ভ্যালুগুলোকে পরিবর্তনও করে না, সেইসাথে সেই ক্লোজারগুলোতেও প্রয়োগ করা হয় যা তাদের এনভায়রনমেন্ট থেকে কিছুই ক্যাপচার করে না। এই ক্লোজারগুলোকে তাদের এনভায়রনমেন্ট পরিবর্তন না করে একাধিকবার কল করা যেতে পারে, যা এমন ক্ষেত্রে গুরুত্বপূর্ণ যেখানে একটি ক্লোজারকে একাধিকবার সমবর্তীভাবে কল করা হয়।

আসুন `Option<T>`-এর উপর `unwrap_or_else` মেথডের সংজ্ঞা দেখি যা আমরা Listing 13-1-এ ব্যবহার করেছি:

```rust,ignore
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

মনে রাখবেন যে `T` হল জেনেরিক টাইপ যা `Option`-এর `Some` ভেরিয়েন্টের ভ্যালুর প্রকারের প্রতিনিধিত্ব করে। সেই `T` টাইপটিও `unwrap_or_else` ফাংশনের রিটার্ন টাইপ: উদাহরণস্বরূপ, `Option<String>`-এ `unwrap_or_else` কল করে এমন কোড একটি `String` পাবে।

এরপর, লক্ষ্য করুন যে `unwrap_or_else` ফাংশনের অতিরিক্ত জেনেরিক টাইপ প্যারামিটার `F` আছে। `F` টাইপটি `f` নামের প্যারামিটারের টাইপ, যা হল ক্লোজার যা আমরা `unwrap_or_else` কল করার সময় সরবরাহ করি।

জেনেরিক টাইপ `F`-এ নির্দিষ্ট করা ট্রেট বাউন্ড হল `FnOnce() -> T`, যার মানে `F`-কে একবার কল করা যেতে হবে, কোনো আর্গুমেন্ট নিতে পারবে না এবং `T` রিটার্ন করতে হবে। ট্রেট বাউন্ডে `FnOnce` ব্যবহার করা এই সীমাবদ্ধতা প্রকাশ করে যে `unwrap_or_else` `f`-কে সর্বোচ্চ একবার কল করবে। `unwrap_or_else`-এর বডিতে, আমরা দেখতে পাচ্ছি যে `Option` যদি `Some` হয়, তাহলে `f` কল করা হবে না। যদি `Option` `None` হয়, তাহলে `f` একবার কল করা হবে। যেহেতু সমস্ত ক্লোজার `FnOnce` প্রয়োগ করে, তাই `unwrap_or_else` সমস্ত তিন ধরনের ক্লোজার গ্রহণ করে এবং যতটা সম্ভব নমনীয়।

> দ্রষ্টব্য: যদি আমরা যা করতে চাই তার জন্য এনভায়রনমেন্ট থেকে একটি ভ্যালু ক্যাপচার করার প্রয়োজন না হয়, তবে আমরা একটি ক্লোজারের পরিবর্তে একটি ফাংশনের নাম ব্যবহার করতে পারি। উদাহরণস্বরূপ, যদি ভ্যালুটি `None` হয়, তবে একটি নতুন, খালি ভেক্টর পেতে আমরা `Option<Vec<T>>` ভ্যালুতে `unwrap_or_else(Vec::new)` কল করতে পারতাম। কম্পাইলার স্বয়ংক্রিয়ভাবে একটি ফাংশন সংজ্ঞার জন্য প্রযোজ্য `Fn` ট্রেটগুলোর যেকোনো একটি প্রয়োগ করে।

এখন আসুন স্লাইসে সংজ্ঞায়িত স্ট্যান্ডার্ড লাইব্রেরি মেথড `sort_by_key` দেখি, যাতে এটি `unwrap_or_else` থেকে কীভাবে আলাদা এবং কেন `sort_by_key` ট্রেট বাউন্ডের জন্য `FnOnce`-এর পরিবর্তে `FnMut` ব্যবহার করে। ক্লোজারটি স্লাইসে বিবেচিত বর্তমান আইটেমের রেফারেন্সের আকারে একটি আর্গুমেন্ট পায় এবং `K` টাইপের একটি ভ্যালু রিটার্ন করে যা অর্ডার করা যায়। এই ফাংশনটি তখন কাজে লাগে যখন আপনি প্রতিটি আইটেমের একটি নির্দিষ্ট অ্যাট্রিবিউট দ্বারা একটি স্লাইস সাজাতে চান। Listing 13-7-এ, আমাদের কাছে `Rectangle` ইনস্ট্যান্সের একটি তালিকা আছে এবং আমরা তাদের `width` অ্যাট্রিবিউট অনুসারে নিচ থেকে উপরের দিকে সাজানোর জন্য `sort_by_key` ব্যবহার করি:

<Listing number="13-7" file-name="src/main.rs" caption="প্রস্থ অনুসারে আয়তক্ষেত্র সাজানোর জন্য `sort_by_key` ব্যবহার করা">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}
```

</Listing>

এই কোডটি প্রিন্ট করে:

```console
{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}
```

`sort_by_key`-কে `FnMut` ক্লোজার নিতে সংজ্ঞায়িত করার কারণ হল এটি ক্লোজারটিকে একাধিকবার কল করে: স্লাইসের প্রতিটি আইটেমের জন্য একবার। ক্লোজার `|r|
r.width` এর এনভায়রনমেন্ট থেকে কিছুই ক্যাপচার করে না, পরিবর্তন করে না বা সরিয়ে নেয় না, তাই এটি ট্রেট বাউন্ডের প্রয়োজনীয়তা পূরণ করে।

বিপরীতে, Listing 13-8-এ একটি ক্লোজারের উদাহরণ দেখানো হয়েছে যা শুধুমাত্র `FnOnce` ট্রেট প্রয়োগ করে, কারণ এটি এনভায়রনমেন্ট থেকে একটি ভ্যালু সরিয়ে নেয়। কম্পাইলার `sort_by_key`-এর সাথে এই ক্লোজারটি ব্যবহার করতে দেবে না:

<Listing number="13-8" file-name="src/main.rs" caption="`sort_by_key`-এর সাথে একটি `FnOnce` ক্লোজার ব্যবহার করার চেষ্টা করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}
```

</Listing>

এটি `list` বাছাই করার সময় `sort_by_key` ক্লোজারটিকে কতবার কল করে তা গণনা করার চেষ্টা করার একটি কৃত্রিম, জটিল উপায় (যা কাজ করে না)। এই কোডটি `sort_operations` ভেক্টরে `value`—ক্লোজারের এনভায়রনমেন্ট থেকে একটি `String`—পুশ করে এই গণনা করার চেষ্টা করে। ক্লোজারটি `value` ক্যাপচার করে তারপর `sort_operations` ভেক্টরে `value`-এর মালিকানা স্থানান্তর করে ক্লোজার থেকে `value` সরিয়ে দেয়। এই ক্লোজারটিকে একবার কল করা যেতে পারে; এটিকে দ্বিতীয়বার কল করার চেষ্টা করলে কাজ করবে না কারণ `sort_operations`-এ আবার পুশ করার জন্য `value` আর এনভায়রনমেন্টে থাকবে না! অতএব, এই ক্লোজারটি শুধুমাত্র `FnOnce` প্রয়োগ করে। যখন আমরা এই কোডটি কম্পাইল করার চেষ্টা করি, তখন আমরা এই এররটি পাই যে `value`-কে ক্লোজার থেকে সরানো যাবে না কারণ ক্লোজারটিকে `FnMut` প্রয়োগ করতে হবে:

```console
{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}
```

এররটি ক্লোজার বডির সেই লাইনটিকে নির্দেশ করে যা এনভায়রনমেন্ট থেকে `value` সরিয়ে নেয়। এটি ঠিক করতে, আমাদের ক্লোজারের বডিটিকে পরিবর্তন করতে হবে যাতে এটি এনভায়রনমেন্ট থেকে ভ্যালু না সরায়। ক্লোজারটিকে কতবার কল করা হয় তা গণনা করতে, এনভায়রনমেন্টে একটি কাউন্টার রাখা এবং ক্লোজারের বডিতে এর ভ্যালু বাড়ানো হল গণনা করার একটি সরল উপায়। Listing 13-9-এর ক্লোজারটি `sort_by_key`-এর সাথে কাজ করে কারণ এটি শুধুমাত্র `num_sort_operations` কাউন্টারের একটি মিউটেবল রেফারেন্স ক্যাপচার করছে এবং সেইজন্য এটিকে একাধিকবার কল করা যেতে পারে:

<Listing number="13-9" file-name="src/main.rs" caption="`sort_by_key`-এর সাথে একটি `FnMut` ক্লোজার ব্যবহার করার অনুমতি আছে">

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}
```

</Listing>

যখন ফাংশন বা টাইপগুলো সংজ্ঞায়িত বা ব্যবহার করা হয় যা ক্লোজার ব্যবহার করে তখন `Fn` ট্রেটগুলো গুরুত্বপূর্ণ। পরবর্তী বিভাগে, আমরা ইটারেটরগুলো নিয়ে আলোচনা করব। অনেক ইটারেটর মেথড ক্লোজার আর্গুমেন্ট নেয়, তাই আমরা যখন চালিয়ে যাব তখন এই ক্লোজারের বিবরণগুলো মনে রাখবেন!

[unwrap-or-else]: ../std/option/enum.Option.html#method.unwrap_or_else
