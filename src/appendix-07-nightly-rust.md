## পরিশিষ্ট G - Rust কীভাবে তৈরি হয় এবং "নাইটলি Rust"

এই পরিশিষ্টটি Rust কীভাবে তৈরি হয় এবং Rust ডেভেলপার হিসাবে এটি আপনাকে কীভাবে প্রভাবিত করে সে সম্পর্কে।

### স্থবিরতা ছাড়াই স্থিতিশীলতা

একটি ভাষা হিসাবে, Rust আপনার কোডের স্থিতিশীলতা সম্পর্কে _অনেক_ বেশি যত্ন নেয়। আমরা চাই Rust একটি কঠিন ভিত্তি হোক যার উপর আপনি নির্মাণ করতে পারেন এবং যদি জিনিসগুলি ক্রমাগত পরিবর্তন হতে থাকে তবে তা অসম্ভব হবে। একই সময়ে, যদি আমরা নতুন বৈশিষ্ট্যগুলি নিয়ে পরীক্ষা করতে না পারি তবে প্রকাশের আগে আমরা গুরুত্বপূর্ণ ত্রুটিগুলি জানতে পারব না, যখন আমরা আর জিনিসগুলি পরিবর্তন করতে পারি না।

এই সমস্যার আমাদের সমাধান হল যাকে আমরা "স্থবিরতা ছাড়াই স্থিতিশীলতা" বলি এবং আমাদের মূলনীতি হল: নতুন সংস্করণের স্থিতিশীল Rust-এ আপগ্রেড করতে আপনার কখনই ভয় পাওয়া উচিত নয়। প্রতিটি আপগ্রেড যেন সহজ হয়, তবে এটি যেন আপনার জন্য নতুন বৈশিষ্ট্য, কম বাগ এবং দ্রুত কম্পাইল করার সময় নিয়ে আসে।

### চু, চু! রিলিজ চ্যানেল এবং ট্রেনের যাত্রা

Rust ডেভেলপমেন্ট একটি _ট্রেনের সময়সূচী_ অনুসরণ করে। অর্থাৎ, সমস্ত ডেভেলপমেন্ট Rust রিপোজিটরির `master` শাখায় করা হয়। রিলিজগুলি একটি সফ্টওয়্যার রিলিজ ট্রেন মডেল অনুসরণ করে, যা সিসকো IOS এবং অন্যান্য সফ্টওয়্যার প্রকল্পগুলি দ্বারা ব্যবহৃত হয়েছে। Rust এর জন্য তিনটি _রিলিজ চ্যানেল_ রয়েছে:

- নাইটলি
- বিটা
- স্থিতিশীল

বেশিরভাগ Rust ডেভেলপার প্রধানত স্থিতিশীল চ্যানেল ব্যবহার করেন, তবে যারা পরীক্ষামূলক নতুন বৈশিষ্ট্যগুলি চেষ্টা করতে চান তারা নাইটলি বা বিটা ব্যবহার করতে পারেন।

ডেভেলপমেন্ট এবং রিলিজ প্রক্রিয়াটি কীভাবে কাজ করে তার একটি উদাহরণ এখানে দেওয়া হল: ধরা যাক Rust দল Rust 1.5-এর রিলিজ নিয়ে কাজ করছে। সেই রিলিজটি 2015 সালের ডিসেম্বরে হয়েছিল, কিন্তু এটি আমাদের বাস্তবসম্মত সংস্করণ নম্বর প্রদান করবে। Rust-এ একটি নতুন বৈশিষ্ট্য যুক্ত করা হয়েছে: `master` শাখায় একটি নতুন কমিট করা হয়েছে। প্রতি রাতে, Rust-এর একটি নতুন নাইটলি সংস্করণ তৈরি করা হয়। প্রতিদিন একটি রিলিজের দিন এবং এই রিলিজগুলি আমাদের রিলিজ অবকাঠামো দ্বারা স্বয়ংক্রিয়ভাবে তৈরি করা হয়। সুতরাং সময় অতিবাহিত হওয়ার সাথে সাথে, আমাদের রিলিজগুলি প্রতি রাতে একবার এমন দেখায়:

```text
nightly: * - - * - - *
```

প্রতি ছয় সপ্তাহে, একটি নতুন রিলিজ প্রস্তুত করার সময়! Rust রিপোজিটরির `beta` শাখা `master` শাখা থেকে বিভক্ত হয় যা নাইটলি দ্বারা ব্যবহৃত হয়। এখন, দুটি রিলিজ রয়েছে:

```text
nightly: * - - * - - *
                     |
beta:                *
```

বেশিরভাগ Rust ব্যবহারকারী বিটা রিলিজগুলি সক্রিয়ভাবে ব্যবহার করেন না, তবে তাদের CI সিস্টেমে বিটার বিরুদ্ধে পরীক্ষা করেন যাতে Rust সম্ভাব্য ত্রুটিগুলি আবিষ্কার করতে পারে। এদিকে, প্রতি রাতে এখনও একটি নাইটলি রিলিজ রয়েছে:

```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```

ধরা যাক, একটি ত্রুটি পাওয়া গেছে। ভালো যে একটি স্থিতিশীল রিলিজে ত্রুটি আসার আগে বিটা রিলিজটি পরীক্ষা করার জন্য আমাদের কাছে কিছু সময় ছিল! `master`-এ সমাধান প্রয়োগ করা হয়, যাতে নাইটলি ঠিক করা হয় এবং তারপরে সমাধানটি `beta` শাখায় ব্যাকপোর্ট করা হয় এবং বিটার একটি নতুন রিলিজ তৈরি করা হয়:

```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```

প্রথম বিটা তৈরি হওয়ার ছয় সপ্তাহ পরে, স্থিতিশীল রিলিজের সময়! `beta` শাখা থেকে `stable` শাখা তৈরি করা হয়েছে:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```

হুররে! Rust 1.5 সম্পন্ন হয়েছে! তবে, আমরা একটি জিনিস ভুলে গেছি: যেহেতু ছয় সপ্তাহ অতিবাহিত হয়ে গেছে, তাই Rust 1.6-এর _পরবর্তী_ সংস্করণের একটি নতুন বিটাও আমাদের প্রয়োজন। তাই `stable` `beta` থেকে আলাদা হওয়ার পরে, `beta`-এর পরবর্তী সংস্করণটি আবার `nightly` থেকে আলাদা হয়ে যায়:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```

একে "ট্রেন মডেল" বলা হয় কারণ প্রতি ছয় সপ্তাহে, একটি রিলিজ "স্টেশন ত্যাগ করে", তবে স্থিতিশীল রিলিজ হিসাবে পৌঁছানোর আগে এটিকে বিটা চ্যানেলের মাধ্যমে একটি যাত্রা করতে হয়।

Rust ঘড়ির কাঁটার মতো প্রতি ছয় সপ্তাহে রিলিজ করে। আপনি যদি একটি Rust রিলিজের তারিখ জানেন তবে আপনি পরেরটির তারিখ জানতে পারবেন: এটি ছয় সপ্তাহ পরে। প্রতি ছয় সপ্তাহে রিলিজের সময়সূচী রাখার একটি সুন্দর দিক হল যে পরবর্তী ট্রেনটি শীঘ্রই আসছে। যদি কোনো বৈশিষ্ট্য কোনো নির্দিষ্ট রিলিজ মিস করে, তবে চিন্তা করার কোনো প্রয়োজন নেই: অল্প সময়ের মধ্যেই আরও একটি রিলিজ হবে! এটি রিলিজের সময়সীমার কাছাকাছি সম্ভাব্য অসম্পূর্ণ বৈশিষ্ট্যগুলি যুক্ত করার চাপ কমাতে সাহায্য করে।

এই প্রক্রিয়ার জন্য ধন্যবাদ, আপনি সবসময় Rust-এর পরবর্তী বিল্ডটি পরীক্ষা করে দেখতে পারেন এবং নিজের জন্য যাচাই করতে পারেন যে আপগ্রেড করা সহজ কিনা: যদি একটি বিটা রিলিজ প্রত্যাশা অনুযায়ী কাজ না করে তবে আপনি দলের কাছে রিপোর্ট করতে পারেন এবং পরবর্তী স্থিতিশীল রিলিজ হওয়ার আগে এটি ঠিক করতে পারেন! বিটা রিলিজের ক্ষেত্রে সমস্যা তুলনামূলকভাবে বিরল, তবে `rustc` এখনও একটি সফ্টওয়্যার এবং বাগ অবশ্যই থাকতে পারে।

### রক্ষণাবেক্ষণের সময়

Rust প্রোজেক্টটি সবচেয়ে সাম্প্রতিক স্থিতিশীল সংস্করণটিকে সমর্থন করে। যখন একটি নতুন স্থিতিশীল সংস্করণ প্রকাশিত হয়, তখন পুরানো সংস্করণটি তার জীবনের শেষ পর্যায়ে (EOL) পৌঁছে যায়। এর মানে প্রতিটি সংস্করণ ছয় সপ্তাহের জন্য সমর্থিত।

### অস্থির বৈশিষ্ট্য

এই রিলিজ মডেলের সাথে আরও একটি বিষয় রয়েছে: অস্থির বৈশিষ্ট্য। Rust একটি কৌশল ব্যবহার করে যাকে "ফিচার ফ্ল্যাগ" বলা হয়, যা একটি নির্দিষ্ট রিলিজে কোন বৈশিষ্ট্যগুলি সক্রিয় করা হয়েছে তা নির্ধারণ করে। যদি একটি নতুন বৈশিষ্ট্য সক্রিয় বিকাশের অধীনে থাকে, তবে এটি `master`-এ চলে যায় এবং তাই, নাইটলি সংস্করণে থাকে, কিন্তু একটি _ফিচার ফ্ল্যাগের_ পিছনে থাকে। আপনি, একজন ব্যবহারকারী হিসাবে, যদি কাজের অগ্রগতি বৈশিষ্ট্যটি চেষ্টা করতে চান তবে আপনি করতে পারেন, তবে আপনাকে Rust-এর একটি নাইটলি রিলিজ ব্যবহার করতে হবে এবং উপযুক্ত পতাকা দিয়ে আপনার সোর্স কোডটিকে চিহ্নিত করতে হবে।

আপনি যদি Rust-এর একটি বিটা বা স্থিতিশীল রিলিজ ব্যবহার করেন তবে আপনি কোনও ফিচার ফ্ল্যাগ ব্যবহার করতে পারবেন না। এটিই সেই মূল বিষয় যা আমাদেরকে স্থায়ীভাবে স্থিতিশীল ঘোষণা করার আগে নতুন বৈশিষ্ট্যগুলির ব্যবহারিক প্রয়োগ করতে দেয়। যারা অত্যাধুনিক প্রযুক্তি ব্যবহার করতে চান তারা তা করতে পারেন এবং যারা একটি কঠিন অভিজ্ঞতা চান তারা স্থিতিশীলতার সাথে লেগে থাকতে পারেন এবং জানতে পারেন যে তাদের কোড ভাঙবে না। স্থবিরতা ছাড়াই স্থিতিশীলতা।

এই বইটিতে শুধুমাত্র স্থিতিশীল বৈশিষ্ট্যগুলি সম্পর্কে তথ্য রয়েছে, কারণ উন্নতি করা বৈশিষ্ট্যগুলি এখনও পরিবর্তিত হচ্ছে এবং নিশ্চিতভাবে এই বইটি লেখার সময় এবং স্থিতিশীল বিল্ডগুলিতে সেগুলি সক্রিয় হওয়ার মধ্যে সেগুলি ভিন্ন হবে৷ আপনি অনলাইনে নাইটলি-শুধুমাত্র বৈশিষ্ট্যগুলির জন্য ডকুমেন্টেশন খুঁজে পেতে পারেন।

### Rustup এবং Rust নাইটলি এর ভূমিকা

Rustup বিশ্বব্যাপী বা প্রতি-প্রোজেক্ট ভিত্তিতে Rust-এর বিভিন্ন রিলিজ চ্যানেলের মধ্যে পরিবর্তন করা সহজ করে তোলে। ডিফল্টরূপে, আপনার স্থিতিশীল Rust ইনস্টল করা থাকবে। উদাহরণস্বরূপ, নাইটলি ইনস্টল করতে:

```console
$ rustup toolchain install nightly
```

আপনি `rustup` এর সাথে আপনার ইনস্টল করা সমস্ত _টুলচেইন_ (Rust এবং সংশ্লিষ্ট উপাদানগুলির রিলিজ) দেখতে পারেন। এখানে আপনার লেখকদের উইন্ডোজ কম্পিউটারে একটি উদাহরণ দেওয়া হল:

```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```

আপনি দেখতে পাচ্ছেন, স্থিতিশীল টুলচেইনটি ডিফল্ট। বেশিরভাগ Rust ব্যবহারকারী বেশিরভাগ সময় স্থিতিশীল ব্যবহার করেন। আপনি সম্ভবত বেশিরভাগ সময় স্থিতিশীল ব্যবহার করতে চাইতে পারেন, তবে একটি নির্দিষ্ট প্রকল্পে নাইটলি ব্যবহার করতে চাইতে পারেন, কারণ আপনি একটি অত্যাধুনিক বৈশিষ্ট্য নিয়ে চিন্তিত। এটি করার জন্য, আপনি সেই প্রোজেক্টের ডিরেক্টরিতে `rustup override` ব্যবহার করতে পারেন `rustup` ব্যবহার করার সময় সেই ডিরেক্টরিতে থাকলে কোন নাইটলি টুলচেইন ব্যবহার করা উচিত তা সেট করতে:

```console
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```

এখন, প্রতিবার যখন আপনি _~/projects/needs-nightly_-এর ভিতরে `rustc` বা `cargo` কল করেন, `rustup` নিশ্চিত করবে যে আপনি স্থিতিশীল Rust এর পরিবর্তে নাইটলি Rust ব্যবহার করছেন। আপনার যখন অনেক Rust প্রোজেক্ট থাকে তখন এটি কাজে আসে!

### RFC প্রক্রিয়া এবং দল

তাহলে আপনি এই নতুন বৈশিষ্ট্যগুলি সম্পর্কে কীভাবে শিখবেন? Rust-এর ডেভেলপমেন্ট মডেল একটি _রিকোয়েস্ট ফর কমেন্টস (RFC) প্রক্রিয়া_ অনুসরণ করে। আপনি যদি Rust-এর উন্নতি চান তবে আপনি RFC নামক একটি প্রস্তাব লিখতে পারেন।

Rust-এর উন্নতি করার জন্য যে কেউ RFC লিখতে পারে এবং Rust দল প্রস্তাবগুলি পর্যালোচনা ও আলোচনা করে, যেটিতে অনেকগুলি বিষয় উপ-দল অন্তর্ভুক্ত রয়েছে। Rust-এর ওয়েবসাইটে [দলগুলির একটি সম্পূর্ণ তালিকা](https://www.rust-lang.org/governance) রয়েছে, যেখানে প্রোজেক্টের প্রতিটি অংশের জন্য দল রয়েছে: ভাষার নকশা, কম্পাইলার বাস্তবায়ন, অবকাঠামো, ডকুমেন্টেশন এবং আরও অনেক কিছু। উপযুক্ত দলটি প্রস্তাব এবং মন্তব্যগুলি পড়ে, তাদের নিজস্ব কিছু মন্তব্য লেখে এবং অবশেষে, বৈশিষ্ট্যটি গ্রহণ বা প্রত্যাখ্যান করার বিষয়ে একটি ঐক্যমত্য হয়।

যদি বৈশিষ্ট্যটি গৃহীত হয় তবে Rust রিপোজিটরিতে একটি ইস্যু খোলা হয় এবং কেউ এটি প্রয়োগ করতে পারে। যিনি এটি বাস্তবায়ন করেন তিনি খুব সম্ভবত সেই ব্যক্তি নাও হতে পারেন যিনি প্রথম স্থানে বৈশিষ্ট্যটি প্রস্তাব করেছিলেন! যখন বাস্তবায়ন প্রস্তুত হয়, তখন এটি `master` শাখায় একটি ফিচার গেটের পিছনে চলে যায়, যা আমরা ["অস্থির বৈশিষ্ট্য"](#unstable-features) বিভাগে আলোচনা করেছি।

কিছু সময় পরে, একবার নাইটলি রিলিজ ব্যবহার করেন এমন Rust ডেভেলপাররা নতুন বৈশিষ্ট্যটি চেষ্টা করতে সক্ষম হওয়ার পরে, দলের সদস্যরা বৈশিষ্ট্যটি, এটি নাইটলি সংস্করণে কেমন কাজ করেছে তা নিয়ে আলোচনা করবেন এবং সিদ্ধান্ত নেবেন যে এটি স্থিতিশীল Rust-এ অন্তর্ভুক্ত করা উচিত কিনা। যদি এগিয়ে যাওয়ার সিদ্ধান্ত নেওয়া হয়, তবে ফিচার গেটটি সরিয়ে দেওয়া হয় এবং বৈশিষ্ট্যটিকে এখন স্থিতিশীল হিসাবে বিবেচনা করা হয়! এটি Rust-এর একটি নতুন স্থিতিশীল রিলিজে ট্রেনের যাত্রা করে।
