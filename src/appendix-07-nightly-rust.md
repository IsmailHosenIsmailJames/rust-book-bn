## পরিশিষ্ট G - Rust কীভাবে তৈরি হয় এবং “নাইটলি Rust”

এই পরিশিষ্টটি Rust কীভাবে তৈরি হয় এবং একজন Rust ডেভেলপার হিসেবে এটি আপনাকে কীভাবে প্রভাবিত করে সে সম্পর্কে।

### স্থবিরতা ছাড়া স্থিতিশীলতা

একটি ভাষা হিসেবে, Rust আপনার কোডের স্থিতিশীলতা নিয়ে _অনেক_ বেশি ভাবে। আমরা চাই Rust একটি শিলা-কঠিন ভিত্তি হোক যার উপর আপনি নির্মাণ করতে পারেন, এবং যদি জিনিসগুলো ক্রমাগত পরিবর্তন হতে থাকে, তবে তা অসম্ভব হবে। একই সময়ে, যদি আমরা নতুন ফিচার নিয়ে পরীক্ষা-নিরীক্ষা করতে না পারি, তবে আমরা হয়তো তাদের প্রকাশের পরে গুরুত্বপূর্ণ ত্রুটিগুলো খুঁজে পাব না, যখন আমরা আর জিনিসগুলো পরিবর্তন করতে পারব না।

এই সমস্যার আমাদের সমাধান হলো যাকে আমরা বলি "স্থবিরতা ছাড়া স্থিতিশীলতা" (stability without stagnation), এবং আমাদের পথপ্রদর্শক নীতিটি হলো: আপনার কখনই স্থিতিশীল Rust-এর নতুন সংস্করণে আপগ্রেড করতে ভয় পাওয়া উচিত নয়। প্রতিটি আপগ্রেড যন্ত্রণাহীন হওয়া উচিত, তবে আপনার জন্য নতুন ফিচার, কম বাগ এবং দ্রুত কম্পাইল সময়ও নিয়ে আসা উচিত।

### ছু, ছু! রিলিজ চ্যানেল এবং ট্রেনে চড়া

Rust-এর ডেভেলপমেন্ট একটি _ট্রেন সময়সূচী_ (train schedule) মেনে চলে। অর্থাৎ, সমস্ত ডেভেলপমেন্ট Rust রিপোজিটরির `master` ব্রাঞ্চে করা হয়। রিলিজগুলো একটি সফটওয়্যার রিলিজ ট্রেন মডেল অনুসরণ করে, যা Cisco IOS এবং অন্যান্য সফটওয়্যার প্রজেক্টে ব্যবহৃত হয়েছে। Rust-এর জন্য তিনটি _রিলিজ চ্যানেল_ রয়েছে:

-   নাইটলি (Nightly)
-   বেটা (Beta)
-   স্টেবল (Stable)

বেশিরভাগ Rust ডেভেলপার প্রাথমিকভাবে স্টেবল চ্যানেল ব্যবহার করেন, কিন্তু যারা পরীক্ষামূলক নতুন ফিচার চেষ্টা করতে চান তারা নাইটলি বা বেটা ব্যবহার করতে পারেন।

ডেভেলপমেন্ট এবং রিলিজ প্রক্রিয়া কীভাবে কাজ করে তার একটি উদাহরণ এখানে দেওয়া হলো: চলুন ধরে নেওয়া যাক যে Rust টিম Rust 1.5 রিলিজের উপর কাজ করছে। সেই রিলিজটি ২০১৫ সালের ডিসেম্বরে হয়েছিল, কিন্তু এটি আমাদের বাস্তবসম্মত সংস্করণ নম্বর সরবরাহ করবে। Rust-এ একটি নতুন ফিচার যোগ করা হয়েছে: `master` ব্রাঞ্চে একটি নতুন কমিট এসেছে। প্রতি রাতে, Rust-এর একটি নতুন নাইটলি সংস্করণ তৈরি করা হয়। প্রতিদিন একটি রিলিজের দিন, এবং এই রিলিজগুলো আমাদের রিলিজ পরিকাঠামো দ্বারা স্বয়ংক্রিয়ভাবে তৈরি করা হয়। তাই সময় পার হওয়ার সাথে সাথে, আমাদের রিলিজগুলো প্রতি রাতে এমন দেখায়:

```text
nightly: * - - * - - *
```

প্রতি ছয় সপ্তাহ পর, একটি নতুন রিলিজ প্রস্তুত করার সময়! Rust রিপোজিটরির `beta` ব্রাঞ্চটি নাইটলি দ্বারা ব্যবহৃত `master` ব্রাঞ্চ থেকে আলাদা হয়। এখন, দুটি রিলিজ রয়েছে:

```text
nightly: * - - * - - *
                     |
beta:                *
```

বেশিরভাগ Rust ব্যবহারকারী সক্রিয়ভাবে বেটা রিলিজ ব্যবহার করেন না, কিন্তু সম্ভাব্য রিগ্রেশন আবিষ্কারে Rust-কে সাহায্য করার জন্য তাদের CI সিস্টেমে বেটার বিরুদ্ধে পরীক্ষা চালান। ইতিমধ্যে, প্রতি রাতে এখনও একটি নাইটলি রিলিজ হয়:

```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```

ধরা যাক একটি রিগ্রেশন পাওয়া গেল। ভালো ব্যাপার যে স্টেবল রিলিজে রিগ্রেশনটি ঢুকে পড়ার আগে বেটা রিলিজ পরীক্ষা করার জন্য আমাদের কিছু সময় ছিল! ফিক্সটি `master`-এ প্রয়োগ করা হয়, যাতে নাইটলি ঠিক হয়ে যায়, এবং তারপর ফিক্সটি `beta` ব্রাঞ্চে ব্যাকপোর্ট করা হয়, এবং বেটার একটি নতুন রিলিজ তৈরি করা হয়:

```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```

প্রথম বেটা তৈরি হওয়ার ছয় সপ্তাহ পর, একটি স্টেবল রিলিজের সময়! `stable` ব্রাঞ্চটি `beta` ব্রাঞ্চ থেকে তৈরি করা হয়:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```

হুররে! Rust 1.5 সম্পন্ন! যাইহোক, আমরা একটি জিনিস ভুলে গেছি: যেহেতু ছয় সপ্তাহ কেটে গেছে, তাই আমাদের Rust-এর _পরবর্তী_ সংস্করণ, 1.6-এর একটি নতুন বেটাও প্রয়োজন। তাই `stable` ব্রাঞ্চটি `beta` থেকে আলাদা হওয়ার পর, `beta`-এর পরবর্তী সংস্করণটি আবার `nightly` থেকে আলাদা হয়:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```

এটিকে "ট্রেন মডেল" বলা হয় কারণ প্রতি ছয় সপ্তাহে, একটি রিলিজ "স্টেশন ছেড়ে যায়", কিন্তু একটি স্টেবল রিলিজ হিসাবে পৌঁছানোর আগে তাকে বেটা চ্যানেলের মাধ্যমে একটি যাত্রা করতে হয়।

Rust প্রতি ছয় সপ্তাহে, ঘড়ির কাঁটার মতো রিলিজ করে। আপনি যদি একটি Rust রিলিজের তারিখ জানেন, আপনি পরেরটির তারিখ জানতে পারবেন: এটি ছয় সপ্তাহ পরে। প্রতি ছয় সপ্তাহে রিলিজ নির্ধারিত থাকার একটি চমৎকার দিক হলো যে পরবর্তী ট্রেনটি শীঘ্রই আসছে। যদি কোনো ফিচার কোনো নির্দিষ্ট রিলিজ মিস করে, তবে চিন্তা করার দরকার নেই: অল্প সময়ের মধ্যেই আরেকটি আসছে! এটি রিলিজের সময়সীমার কাছাকাছি সম্ভাব্য অপরিশোধিত ফিচারগুলোকে লুকিয়ে ফেলার চাপ কমাতে সাহায্য করে।

এই প্রক্রিয়ার জন্য ধন্যবাদ, আপনি সর্বদা Rust-এর পরবর্তী বিল্ডটি পরীক্ষা করতে পারেন এবং নিজের জন্য যাচাই করতে পারেন যে এটিতে আপগ্রেড করা সহজ: যদি একটি বেটা রিলিজ প্রত্যাশা অনুযায়ী কাজ না করে, আপনি টিমকে এটি রিপোর্ট করতে পারেন এবং পরবর্তী স্টেবল রিলিজ হওয়ার আগে এটি ঠিক করাতে পারেন! একটি বেটা রিলিজে ব্রেকএজ তুলনামূলকভাবে বিরল, কিন্তু `rustc` এখনও একটি সফটওয়্যার, এবং বাগ বিদ্যমান।

### রক্ষণাবেক্ষণের সময়

Rust প্রজেক্ট সবচেয়ে সাম্প্রতিক স্টেবল সংস্করণটিকে সমর্থন করে। যখন একটি নতুন স্টেবল সংস্করণ রিলিজ হয়, তখন পুরানো সংস্করণটি তার জীবনকালের শেষ পর্যায়ে (end of life - EOL) পৌঁছে যায়। এর মানে হলো প্রতিটি সংস্করণ ছয় সপ্তাহের জন্য সমর্থিত থাকে।

### আনস্টেবল ফিচার

এই রিলিজ মডেলের সাথে আরও একটি বিষয় জড়িত: আনস্টেবল ফিচার। Rust একটি নির্দিষ্ট রিলিজে কোন ফিচারগুলো সক্রিয় আছে তা নির্ধারণ করতে "ফিচার ফ্ল্যাগ" নামক একটি কৌশল ব্যবহার করে। যদি একটি নতুন ফিচার সক্রিয় বিকাশের অধীনে থাকে, তবে এটি `master`-এ আসে, এবং ফলস্বরূপ, নাইটলি-তে, কিন্তু একটি _ফিচার ফ্ল্যাগের_ আড়ালে। আপনি যদি একজন ব্যবহারকারী হিসেবে, কাজটি চলমান থাকা ফিচারটি চেষ্টা করতে চান, তবে আপনি তা করতে পারেন, কিন্তু আপনাকে অবশ্যই Rust-এর একটি নাইটলি রিলিজ ব্যবহার করতে হবে এবং অপ্ট-ইন করার জন্য আপনার সোর্স কোডটি উপযুক্ত ফ্ল্যাগ দিয়ে অ্যানোটেট করতে হবে।

আপনি যদি Rust-এর বেটা বা স্টেবল রিলিজ ব্যবহার করেন, তবে আপনি কোনো ফিচার ফ্ল্যাগ ব্যবহার করতে পারবেন না। এটিই সেই চাবিকাঠি যা আমাদের নতুন ফিচারগুলোকে চিরস্থায়ীভাবে স্টেবল ঘোষণা করার আগে তাদের ব্যবহারিক ব্যবহার পেতে দেয়। যারা অত্যাধুনিক ফিচার অপ্ট-ইন করতে চান তারা তা করতে পারেন, এবং যারা একটি শিলা-কঠিন অভিজ্ঞতা চান তারা স্টেবল-এর সাথে থাকতে পারেন এবং জানতে পারেন যে তাদের কোড ভাঙবে না। স্থবিরতা ছাড়া স্থিতিশীলতা।

এই বইটিতে শুধুমাত্র স্টেবল ফিচার সম্পর্কে তথ্য রয়েছে, কারণ কাজ চলমান থাকা ফিচারগুলো এখনও পরিবর্তিত হচ্ছে, এবং নিশ্চিতভাবেই এই বইটি লেখার সময় এবং যখন সেগুলি স্টেবল বিল্ডে সক্রিয় হবে তার মধ্যে সেগুলি ভিন্ন হবে। আপনি অনলাইনে নাইটলি-কেবল ফিচারগুলোর জন্য ডকুমেন্টেশন খুঁজে পেতে পারেন।

### `rustup` এবং রাস্ট নাইটলি-র ভূমিকা

`rustup` গ্লোবাল বা প্রতি-প্রজেক্ট ভিত্তিতে Rust-এর বিভিন্ন রিলিজ চ্যানেলের মধ্যে পরিবর্তন করা সহজ করে তোলে। ডিফল্টরূপে, আপনার কাছে স্টেবল Rust ইনস্টল করা থাকবে। উদাহরণস্বরূপ, নাইটলি ইনস্টল করতে:

```console
$ rustup toolchain install nightly
```

আপনি `rustup` দিয়ে আপনার ইনস্টল করা সমস্ত _টুলচেইন_ (Rust-এর রিলিজ এবং সংশ্লিষ্ট উপাদান) দেখতে পারেন। এখানে আপনার একজন লেখকের উইন্ডোজ কম্পিউটারে একটি উদাহরণ দেওয়া হলো:

```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```

যেমন আপনি দেখতে পাচ্ছেন, স্টেবল টুলচেইনটি ডিফল্ট। বেশিরভাগ Rust ব্যবহারকারী বেশিরভাগ সময় স্টেবল ব্যবহার করেন। আপনি হয়তো বেশিরভাগ সময় স্টেবল ব্যবহার করতে চান, কিন্তু একটি নির্দিষ্ট প্রজেক্টে নাইটলি ব্যবহার করতে চান, কারণ আপনি একটি অত্যাধুনিক ফিচার নিয়ে আগ্রহী। এটি করার জন্য, আপনি সেই প্রজেক্টের ডিরেক্টরিতে `rustup override` ব্যবহার করে নাইটলি টুলচেইনটিকে সেট করতে পারেন যা `rustup` ব্যবহার করবে যখন আপনি সেই ডিরেক্টরিতে থাকবেন:

```console
$ cd ~/projects/needs-nightly
$ rustup override set nightly
```

এখন, প্রতিবার যখন আপনি _~/projects/needs-nightly_-এর ভিতরে `rustc` বা `cargo` কল করবেন, তখন `rustup` নিশ্চিত করবে যে আপনি আপনার ডিফল্ট স্টেবল Rust-এর পরিবর্তে নাইটলি Rust ব্যবহার করছেন। এটি কার্যকর হয় যখন আপনার অনেক Rust প্রজেক্ট থাকে!

### RFC প্রক্রিয়া এবং টিম

তাহলে আপনি এই নতুন ফিচারগুলো সম্পর্কে কীভাবে জানবেন? Rust-এর ডেভেলপমেন্ট মডেল একটি _রিকোয়েস্ট ফর কমেন্টস (RFC) প্রক্রিয়া_ অনুসরণ করে। আপনি যদি Rust-এ কোনো উন্নতি চান, তবে আপনি একটি প্রস্তাবনা লিখতে পারেন, যাকে RFC বলা হয়।

যে কেউ Rust উন্নত করার জন্য RFC লিখতে পারে, এবং প্রস্তাবনাগুলো Rust টিম দ্বারা পর্যালোচনা এবং আলোচনা করা হয়, যা অনেকগুলো বিষয়ভিত্তিক সাবটিম নিয়ে গঠিত। Rust-এর ওয়েবসাইটে টিমগুলোর একটি সম্পূর্ণ তালিকা রয়েছে, যার মধ্যে প্রজেক্টের প্রতিটি ক্ষেত্রের জন্য টিম অন্তর্ভুক্ত: ভাষা ডিজাইন, কম্পাইলার ইমপ্লিমেন্টেশন, ইনফ্রাস্ট্রাকচার, ডকুমেন্টেশন এবং আরও অনেক কিছু। উপযুক্ত টিম প্রস্তাবনা এবং মন্তব্যগুলো পড়ে, তাদের নিজস্ব কিছু মন্তব্য লেখে, এবং অবশেষে, ফিচারটি গ্রহণ বা প্রত্যাখ্যান করার জন্য একটি ঐকমত্যে পৌঁছানো হয়।

যদি ফিচারটি গৃহীত হয়, তবে Rust রিপোজিটরিতে একটি ইস্যু খোলা হয়, এবং কেউ এটি ইমপ্লিমেন্ট করতে পারে। যে ব্যক্তি এটি ইমপ্লিমেন্ট করে সে খুব সম্ভবত সেই ব্যক্তি নাও হতে পারে যে প্রথম ফিচারটি প্রস্তাব করেছিল! যখন ইমপ্লিমেন্টেশনটি প্রস্তুত হয়, তখন এটি একটি ফিচার গেটের আড়ালে `master` ব্রাঞ্চে আসে, যেমনটি আমরা ["আনস্টেবল ফিচার"](#unstable-features) বিভাগে আলোচনা করেছি।

কিছু সময় পর, যখন নাইটলি রিলিজ ব্যবহারকারী Rust ডেভেলপাররা নতুন ফিচারটি চেষ্টা করতে সক্ষম হন, তখন টিমের সদস্যরা ফিচারটি নিয়ে আলোচনা করেন, এটি নাইটলি-তে কীভাবে কাজ করেছে তা নিয়ে আলোচনা করেন, এবং সিদ্ধান্ত নেন যে এটি স্টেবল Rust-এ আসা উচিত কিনা। যদি এগিয়ে যাওয়ার সিদ্ধান্ত নেওয়া হয়, তবে ফিচার গেটটি সরিয়ে ফেলা হয়, এবং ফিচারটি এখন স্টেবল হিসাবে বিবেচিত হয়! এটি ট্রেনগুলোতে চড়ে Rust-এর একটি নতুন স্টেবল রিলিজে আসে।