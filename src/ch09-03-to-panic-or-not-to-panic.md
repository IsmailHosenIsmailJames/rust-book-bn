## `panic!` অথবা `panic!` না করা

তাহলে আপনি কিভাবে সিদ্ধান্ত নেবেন কখন আপনার `panic!` কল করা উচিত এবং কখন আপনার `Result` রিটার্ন করা উচিত? যখন কোড প্যানিক করে, তখন পুনরুদ্ধার করার কোনো উপায় থাকে না। আপনি যেকোনো এরর পরিস্থিতির জন্য `panic!` কল করতে পারেন, পুনরুদ্ধার করার কোনো সম্ভাব্য উপায় থাকুক বা না থাকুক, কিন্তু তারপর আপনি কলিং কোডের পক্ষ থেকে সিদ্ধান্ত নিচ্ছেন যে একটি পরিস্থিতি পুনরুদ্ধার করা সম্ভব নয়। যখন আপনি একটি `Result` ভ্যালু রিটার্ন করতে পছন্দ করেন, তখন আপনি কলিং কোডকে অপশন দেন। কলিং কোড তার পরিস্থিতির জন্য উপযুক্ত উপায়ে পুনরুদ্ধার করার চেষ্টা করতে বেছে নিতে পারে, অথবা এটি সিদ্ধান্ত নিতে পারে যে এই ক্ষেত্রে একটি `Err` ভ্যালু পুনরুদ্ধার করা সম্ভব নয়, তাই এটি `panic!` কল করতে পারে এবং আপনার পুনরুদ্ধারযোগ্য এররটিকে একটি পুনরুদ্ধার করা অসম্ভব এররে পরিণত করতে পারে। অতএব, যখন আপনি এমন একটি ফাংশন সংজ্ঞায়িত করছেন যা ব্যর্থ হতে পারে, তখন `Result` রিটার্ন করা একটি ভাল ডিফল্ট পছন্দ।

উদাহরণ, প্রোটোটাইপ কোড এবং পরীক্ষার মতো পরিস্থিতিতে, `Result` রিটার্ন করার পরিবর্তে প্যানিক করে এমন কোড লেখা আরও উপযুক্ত। আসুন অন্বেষণ করি কেন, তারপর সেই পরিস্থিতিগুলো নিয়ে আলোচনা করি যেখানে কম্পাইলার বলতে পারে না যে ব্যর্থতা অসম্ভব, কিন্তু আপনি একজন মানুষ হিসাবে তা বলতে পারেন। এই অধ্যায়টি লাইব্রেরি কোডে প্যানিক করা উচিত কিনা তা সিদ্ধান্ত নেওয়ার কিছু সাধারণ নির্দেশিকা দিয়ে শেষ হবে।

### উদাহরণ, প্রোটোটাইপ কোড এবং পরীক্ষা

যখন আপনি কোনো ধারণা বোঝানোর জন্য একটি উদাহরণ লিখছেন, তখন শক্তিশালী এরর-হ্যান্ডলিং কোড অন্তর্ভুক্ত করলে উদাহরণটি কম স্পষ্ট হতে পারে। উদাহরণে, এটা বোঝা যায় যে `unwrap`-এর মতো কোনো মেথডের কল, যা প্যানিক করতে পারে, সেটি আপনার অ্যাপ্লিকেশন এররগুলো কীভাবে হ্যান্ডেল করতে চায় তার একটি স্থানধারক হিসেবে বোঝানো হয়েছে, যা আপনার বাকি কোড কী করছে তার উপর ভিত্তি করে আলাদা হতে পারে।

একইভাবে, `unwrap` এবং `expect` মেথডগুলো প্রোটোটাইপ করার সময় খুব কাজে লাগে, যখন আপনি এররগুলো কীভাবে হ্যান্ডেল করবেন তা সিদ্ধান্ত নিতে প্রস্তুত হন। যখন আপনি আপনার প্রোগ্রামটিকে আরও শক্তিশালী করতে প্রস্তুত হন, তখন তারা আপনার কোডে স্পষ্ট মার্কার রেখে যায়।

যদি একটি পরীক্ষায় একটি মেথড কল ব্যর্থ হয়, তবে আপনি চাইবেন পুরো পরীক্ষাটি ব্যর্থ হোক, এমনকি যদি সেই মেথডটি পরীক্ষার অধীনে থাকা কার্যকারিতা না হয়। যেহেতু `panic!` হল একটি পরীক্ষাকে ব্যর্থ হিসাবে চিহ্নিত করার উপায়, তাই `unwrap` বা `expect` কল করাই সঠিক কাজ।

### সেইসব ক্ষেত্র যেখানে আপনার কাছে কম্পাইলারের চেয়ে বেশি তথ্য আছে

`unwrap` বা `expect` কল করাও উপযুক্ত হবে যখন আপনার কাছে অন্য কোনো লজিক থাকে যা নিশ্চিত করে যে `Result`-এর একটি `Ok` ভ্যালু থাকবে, কিন্তু সেই লজিকটি কম্পাইলার বোঝে না। আপনার কাছে এখনও একটি `Result` ভ্যালু থাকবে যা আপনাকে হ্যান্ডেল করতে হবে: আপনি যে অপারেশনটি কল করছেন সেটি এখনও সাধারণভাবে ব্যর্থ হওয়ার সম্ভাবনা রয়েছে, যদিও এটি আপনার বিশেষ পরিস্থিতিতে যৌক্তিকভাবে অসম্ভব। আপনি যদি ম্যানুয়ালি কোড পরিদর্শন করে নিশ্চিত করতে পারেন যে আপনার কখনও `Err` ভেরিয়েন্ট থাকবে না, তবে `unwrap` কল করা একেবারে গ্রহণযোগ্য, এবং `expect` টেক্সটে আপনি কেন মনে করেন যে আপনার কখনও `Err` ভেরিয়েন্ট থাকবে না তার কারণটি নথিভুক্ত করা আরও ভাল। এখানে একটি উদাহরণ:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-08-unwrap-that-cant-fail/src/main.rs:here}}
```

আমরা একটি হার্ডকোড করা স্ট্রিং পার্স করে একটি `IpAddr` ইনস্ট্যান্স তৈরি করছি। আমরা দেখতে পাচ্ছি যে `127.0.0.1` একটি বৈধ IP ঠিকানা, তাই এখানে `expect` ব্যবহার করা গ্রহণযোগ্য। যাইহোক, একটি হার্ডকোড করা, বৈধ স্ট্রিং থাকা `parse` মেথডের রিটার্ন টাইপ পরিবর্তন করে না: আমরা এখনও একটি `Result` ভ্যালু পাই, এবং কম্পাইলার এখনও `Result`-কে এমনভাবে হ্যান্ডেল করতে বাধ্য করবে যেন `Err` ভেরিয়েন্ট একটি সম্ভাবনা, কারণ কম্পাইলার এত স্মার্ট নয় যে দেখতে পায় এই স্ট্রিংটি সর্বদা একটি বৈধ IP ঠিকানা। যদি IP ঠিকানা স্ট্রিংটি প্রোগ্রামে হার্ডকোড করার পরিবর্তে কোনো ব্যবহারকারীর কাছ থেকে আসত এবং তাই ব্যর্থ হওয়ার সম্ভাবনা _থাকত_, তাহলে আমরা অবশ্যই `Result`-কে আরও শক্তিশালী উপায়ে হ্যান্ডেল করতে চাইতাম। এই IP ঠিকানাটি হার্ডকোড করা আছে এমন অনুমান উল্লেখ করলে ভবিষ্যতে যদি আমাদের অন্য কোনো উৎস থেকে IP ঠিকানা পেতে হয়, তাহলে `expect`-কে আরও ভাল এরর-হ্যান্ডলিং কোডে পরিবর্তন করতে আমাদের প্ররোচিত করবে।

### এরর হ্যান্ডলিংয়ের জন্য নির্দেশিকা

পরামর্শ দেওয়া হয় যে আপনার কোড প্যানিক করুক যখন এমন সম্ভাবনা থাকে যে আপনার কোড খারাপ অবস্থায় শেষ হতে পারে। এই প্রেক্ষাপটে, একটি _খারাপ অবস্থা_ হল যখন কিছু অনুমান, গ্যারান্টি, চুক্তি বা অপরিবর্তনীয়তা ভেঙে গেছে, যেমন যখন অবৈধ ভ্যালু, পরস্পরবিরোধী ভ্যালু বা অনুপস্থিত ভ্যালু আপনার কোডে পাস করা হয়—সাথে নিম্নলিখিত এক বা একাধিক:

- খারাপ অবস্থাটি অপ্রত্যাশিত কিছু, এমন কিছু হওয়ার বিপরীতে যা সম্ভবত মাঝে মাঝে ঘটবে, যেমন কোনো ব্যবহারকারী ভুল ফরম্যাটে ডেটা প্রবেশ করা।
- এই পয়েন্টের পরে আপনার কোডকে এই খারাপ অবস্থায় না থাকার উপর নির্ভর করতে হবে, প্রতিটি ধাপে সমস্যার জন্য পরীক্ষা করার পরিবর্তে।
- আপনি যে টাইপগুলো ব্যবহার করেন তাতে এই তথ্য এনকোড করার কোনো ভালো উপায় নেই। আমরা Chapter 18-এর [“Encoding States and Behavior as Types”][encoding]<!-- ignore --> বিভাগে এর মানে কী তা নিয়ে একটি উদাহরণের মাধ্যমে কাজ করব।

যদি কেউ আপনার কোড কল করে এবং এমন ভ্যালু পাস করে যা বোধগম্য নয়, তাহলে যদি আপনি পারেন তবে একটি এরর রিটার্ন করাই ভাল যাতে লাইব্রেরির ব্যবহারকারী সিদ্ধান্ত নিতে পারে যে তারা সেই ক্ষেত্রে কী করতে চায়। যাইহোক, এমন ক্ষেত্রে যেখানে চালিয়ে যাওয়া অনিরাপদ বা ক্ষতিকর হতে পারে, সেখানে `panic!` কল করা এবং তাদের কোডের বাগ সম্পর্কে আপনার লাইব্রেরি ব্যবহার করা ব্যক্তিকে সতর্ক করা সেরা পছন্দ হতে পারে যাতে তারা ডেভেলপমেন্টের সময় এটি ঠিক করতে পারে। একইভাবে, আপনি যদি আপনার নিয়ন্ত্রণের বাইরের কোনো বাহ্যিক কোড কল করেন এবং এটি একটি অবৈধ অবস্থা ফেরত দেয় যা আপনি ঠিক করতে পারবেন না, তাহলে `panic!` প্রায়ই উপযুক্ত।

তবে, যখন ব্যর্থতা প্রত্যাশিত, তখন `panic!` কল করার চেয়ে একটি `Result` রিটার্ন করা আরও উপযুক্ত। উদাহরণস্বরূপ, একটি পার্সারকে ত্রুটিপূর্ণ ডেটা দেওয়া বা একটি HTTP অনুরোধ এমন একটি স্ট্যাটাস ফেরত দেওয়া যা নির্দেশ করে যে আপনি রেট সীমাতে পৌঁছেছেন। এই ক্ষেত্রে, একটি `Result` রিটার্ন করা ইঙ্গিত দেয় যে ব্যর্থতা একটি প্রত্যাশিত সম্ভাবনা যা কলিং কোডকে কীভাবে হ্যান্ডেল করতে হবে তা সিদ্ধান্ত নিতে হবে।

যখন আপনার কোড এমন একটি অপারেশন চালায় যা অবৈধ ভ্যালু ব্যবহার করে কল করা হলে ব্যবহারকারীকে ঝুঁকিতে ফেলতে পারে, তখন আপনার কোড প্রথমে ভ্যালুগুলো বৈধ কিনা তা যাচাই করা উচিত এবং ভ্যালুগুলো বৈধ না হলে প্যানিক করা উচিত। এটি মূলত নিরাপত্তার কারণে: অবৈধ ডেটাতে কাজ করার চেষ্টা করলে আপনার কোড দুর্বলতার শিকার হতে পারে। এই প্রধান কারণে স্ট্যান্ডার্ড লাইব্রেরি `panic!` কল করে যদি আপনি কোনো সীমার বাইরের মেমরি অ্যাক্সেস করার চেষ্টা করেন: মেমরি অ্যাক্সেস করার চেষ্টা করা যা বর্তমান ডেটা স্ট্রাকচারের অন্তর্ভুক্ত নয় সেটি একটি সাধারণ নিরাপত্তা সমস্যা। ফাংশনগুলোর প্রায়শই _চুক্তি_ থাকে: তাদের আচরণ তখনই নিশ্চিত করা হয় যদি ইনপুটগুলো নির্দিষ্ট প্রয়োজনীয়তা পূরণ করে। চুক্তি লঙ্ঘন হলে প্যানিক করা বোধগম্য, কারণ চুক্তি লঙ্ঘন সবসময় কলার-সাইড বাগ নির্দেশ করে এবং এটি এমন ধরনের এরর নয় যা কলিং কোডকে স্পষ্টভাবে হ্যান্ডেল করতে হবে। প্রকৃতপক্ষে, কলিং কোডের পুনরুদ্ধারের কোনো যুক্তিসঙ্গত উপায় নেই; কলিং _প্রোগ্রামারদের_ কোডটি ঠিক করতে হবে। একটি ফাংশনের চুক্তি, বিশেষ করে যখন একটি লঙ্ঘন প্যানিক সৃষ্টি করবে, তখন ফাংশনের API ডকুমেন্টেশনে ব্যাখ্যা করা উচিত।

যাইহোক, আপনার সমস্ত ফাংশনে প্রচুর এরর চেক থাকলে তা বিস্তারিত এবং বিরক্তিকর হবে। সৌভাগ্যবশত, আপনি রাস্টের টাইপ সিস্টেম (এবং সেইজন্য কম্পাইলার দ্বারা করা টাইপ চেকিং) ব্যবহার করে আপনার জন্য অনেক চেক করতে পারেন। যদি আপনার ফাংশনের প্যারামিটার হিসাবে একটি নির্দিষ্ট টাইপ থাকে, তবে আপনি আপনার কোডের লজিক নিয়ে এগিয়ে যেতে পারেন এই জেনে যে কম্পাইলার ইতিমধ্যেই নিশ্চিত করেছে যে আপনার কাছে একটি বৈধ ভ্যালু আছে। উদাহরণস্বরূপ, যদি আপনার কাছে `Option`-এর পরিবর্তে একটি টাইপ থাকে, তবে আপনার প্রোগ্রামটি _কিছু_ থাকার আশা করে, _কিছু না_ থাকার নয়। আপনার কোডটিকে তখন `Some` এবং `None` ভেরিয়েন্টের জন্য দুটি কেস হ্যান্ডেল করতে হবে না: এটি নিশ্চিতভাবে একটি ভ্যালু থাকার জন্য শুধুমাত্র একটি কেস থাকবে। আপনার ফাংশনে কিছুই পাস করার চেষ্টা করা কোড কম্পাইলও হবে না, তাই আপনার ফাংশনকে রানটাইমে সেই কেসের জন্য পরীক্ষা করতে হবে না। আরেকটি উদাহরণ হল `u32`-এর মতো একটি আনসাইন্ড ইন্টিজার টাইপ ব্যবহার করা, যা নিশ্চিত করে যে প্যারামিটারটি কখনও নেতিবাচক নয়।

### বৈধতার জন্য কাস্টম টাইপ তৈরি করা

আসুন রাস্টের টাইপ সিস্টেম ব্যবহার করে নিশ্চিত করার ধারণাটিকে আরও একধাপ এগিয়ে নিয়ে যাই এবং বৈধতার জন্য একটি কাস্টম টাইপ তৈরি করা দেখি। Chapter 2-এর গেসিং গেমের কথা মনে করুন যেখানে আমাদের কোড ব্যবহারকারীকে 1 থেকে 100-এর মধ্যে একটি সংখ্যা অনুমান করতে বলেছিল। আমাদের গোপন নম্বরের সাথে তুলনা করার আগে আমরা কখনই যাচাই করিনি যে ব্যবহারকারীর অনুমান সেই সংখ্যাগুলোর মধ্যে ছিল কিনা; আমরা শুধুমাত্র যাচাই করেছিলাম যে অনুমানটি ইতিবাচক কিনা। এই ক্ষেত্রে, পরিণতি খুব মারাত্মক ছিল না: আমাদের "খুব বেশি" বা "খুব কম" আউটপুট এখনও সঠিক হবে। কিন্তু ব্যবহারকারীকে বৈধ অনুমানের দিকে গাইড করা এবং ব্যবহারকারী যখন রেঞ্জের বাইরের কোনো সংখ্যা অনুমান করে এবং যখন ব্যবহারকারী, উদাহরণস্বরূপ, অক্ষর টাইপ করে তখন ভিন্ন আচরণ করা একটি দরকারী উন্নতি হবে।

এটি করার একটি উপায় হল সম্ভাব্য নেতিবাচক সংখ্যার অনুমতি দেওয়ার জন্য শুধুমাত্র `u32`-এর পরিবর্তে অনুমানটিকে `i32` হিসাবে পার্স করা এবং তারপর সংখ্যাটি রেঞ্জের মধ্যে আছে কিনা তা পরীক্ষা করা, যেমন:

<Listing file-name="src/main.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-09-guess-out-of-range/src/main.rs:here}}
```

</Listing>

`if` এক্সপ্রেশনটি পরীক্ষা করে দেখে যে আমাদের ভ্যালুটি রেঞ্জের বাইরে আছে কিনা, ব্যবহারকারীকে সমস্যাটি সম্পর্কে জানায় এবং লুপের পরবর্তী পুনরাবৃত্তি শুরু করতে এবং অন্য একটি অনুমান চাইতে `continue` কল করে। `if` এক্সপ্রেশনের পরে, আমরা `guess` এবং গোপন নম্বরের মধ্যে তুলনা চালিয়ে যেতে পারি এই জেনে যে `guess` 1 থেকে 100-এর মধ্যে রয়েছে।

তবে, এটি একটি আদর্শ সমাধান নয়: যদি এটি একেবারে গুরুত্বপূর্ণ হত যে প্রোগ্রামটি শুধুমাত্র 1 থেকে 100-এর মধ্যে ভ্যালু নিয়ে কাজ করবে এবং এটির এই প্রয়োজনীয়তা সহ অনেক ফাংশন থাকত, তবে প্রতিটি ফাংশনে এই ধরনের চেক করা ক্লান্তিকর (এবং কর্মক্ষমতাকে প্রভাবিত করতে পারে)।

পরিবর্তে, আমরা একটি নতুন টাইপ তৈরি করতে পারি এবং সর্বত্র বৈধতা পুনরাবৃত্তি করার পরিবর্তে টাইপের একটি ইনস্ট্যান্স তৈরি করার জন্য একটি ফাংশনে বৈধতা রাখতে পারি। এইভাবে, ফাংশনগুলোর জন্য তাদের সিগনেচারে নতুন টাইপ ব্যবহার করা এবং তারা যে ভ্যালুগুলো পায় তা আত্মবিশ্বাসের সাথে ব্যবহার করা নিরাপদ। Listing 9-13 `Guess` টাইপ সংজ্ঞায়িত করার একটি উপায় দেখায় যা শুধুমাত্র তখনই `Guess`-এর একটি ইনস্ট্যান্স তৈরি করবে যদি `new` ফাংশন 1 থেকে 100-এর মধ্যে একটি ভ্যালু পায়।

<Listing number="9-13" caption="একটি `Guess` টাইপ যা শুধুমাত্র 1 থেকে 100-এর মধ্যে ভ্যালু নিয়ে কাজ করবে">

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-13/src/lib.rs}}
```

</Listing>

প্রথমে আমরা `Guess` নামের একটি struct সংজ্ঞায়িত করি যার `value` নামের একটি ফিল্ড আছে যা একটি `i32` ধারণ করে। এখানেই সংখ্যাটি স্টোর করা হবে।

তারপর আমরা `Guess`-এ `new` নামের একটি অ্যাসোসিয়েটেড ফাংশন প্রয়োগ করি যা `Guess` ভ্যালুর ইনস্ট্যান্স তৈরি করে। `new` ফাংশনটি `i32` টাইপের `value` নামের একটি প্যারামিটার এবং একটি `Guess` রিটার্ন করার জন্য সংজ্ঞায়িত করা হয়েছে। `new` ফাংশনের বডির কোডটি `value`-কে পরীক্ষা করে দেখে যে এটি 1 থেকে 100-এর মধ্যে আছে কিনা। যদি `value` এই পরীক্ষায় উত্তীর্ণ না হয়, তাহলে আমরা একটি `panic!` কল করি, যা কলিং কোড লিখছেন এমন প্রোগ্রামারকে সতর্ক করবে যে তাদের একটি বাগ আছে যা তাদের ঠিক করতে হবে, কারণ এই রেঞ্জের বাইরের `value` সহ একটি `Guess` তৈরি করলে `Guess::new` যে চুক্তির উপর নির্ভর করে তা লঙ্ঘন করবে। `Guess::new` কোন পরিস্থিতিতে প্যানিক করতে পারে তা এর পাবলিক-ফেসিং API ডকুমেন্টেশনে আলোচনা করা উচিত; আমরা Chapter 14-এ আপনার তৈরি করা API ডকুমেন্টেশনে একটি `panic!`-এর সম্ভাবনা নির্দেশ করে এমন ডকুমেন্টেশন কনভেনশনগুলি নিয়ে আলোচনা করব। যদি `value` পরীক্ষায় উত্তীর্ণ হয়, তাহলে আমরা এর `value` ফিল্ডটিকে `value` প্যারামিটারে সেট করে একটি নতুন `Guess` তৈরি করি এবং `Guess` রিটার্ন করি।

এরপর, আমরা `value` নামের একটি মেথড প্রয়োগ করি যা `self`-কে বরো করে, অন্য কোনো প্যারামিটার নেই এবং একটি `i32` রিটার্ন করে। এই ধরনের মেথডকে কখনও কখনও _গেটার_ বলা হয় কারণ এর উদ্দেশ্য হল এর ফিল্ড থেকে কিছু ডেটা পাওয়া এবং তা ফেরত দেওয়া। এই পাবলিক মেথডটি প্রয়োজনীয় কারণ `Guess` struct-এর `value` ফিল্ডটি প্রাইভেট। এটি গুরুত্বপূর্ণ যে `value` ফিল্ডটি প্রাইভেট হোক যাতে `Guess` struct ব্যবহার করা কোডকে সরাসরি `value` সেট করার অনুমতি দেওয়া না হয়: মডিউলের বাইরের কোডকে `Guess` struct-এর একটি ইনস্ট্যান্স তৈরি করতে `Guess::new` ফাংশন ব্যবহার করতে _হবে_, এইভাবে নিশ্চিত করা হয় যে `Guess`-এর এমন `value` থাকার কোনো উপায় নেই যা `Guess::new` ফাংশনের শর্তগুলো দ্বারা পরীক্ষা করা হয়নি।

একটি ফাংশন যার প্যারামিটার বা রিটার্ন ভ্যালু শুধুমাত্র 1 থেকে 100-এর মধ্যে সংখ্যা থাকে, সেটি তখন তার সিগনেচারে ঘোষণা করতে পারে যে এটি `i32`-এর পরিবর্তে একটি `Guess` নেয় বা রিটার্ন করে এবং এর বডিতে কোনো অতিরিক্ত চেক করার প্রয়োজন হবে না।

## সারসংক্ষেপ

রাস্টের এরর-হ্যান্ডলিং বৈশিষ্ট্যগুলো আপনাকে আরও শক্তিশালী কোড লিখতে সাহায্য করার জন্য ডিজাইন করা হয়েছে। `panic!` ম্যাক্রো সংকেত দেয় যে আপনার প্রোগ্রাম এমন একটি অবস্থায় আছে যা এটি পরিচালনা করতে পারে না এবং আপনাকে অবৈধ বা ভুল ভ্যালু নিয়ে কাজ করার চেষ্টা করার পরিবর্তে প্রক্রিয়াটিকে থামাতে বলার সুযোগ দেয়। `Result` enum রাস্টের টাইপ সিস্টেম ব্যবহার করে নির্দেশ করে যে অপারেশনগুলো এমনভাবে ব্যর্থ হতে পারে যা থেকে আপনার কোড পুনরুদ্ধার করতে পারে। আপনি আপনার কোডকে কল করে এমন কোডকে বলতে `Result` ব্যবহার করতে পারেন যে এটির সম্ভাব্য সাফল্য বা ব্যর্থতাও হ্যান্ডেল করতে হবে। উপযুক্ত পরিস্থিতিতে `panic!` এবং `Result` ব্যবহার করলে আপনার কোড অনিবার্য সমস্যার মুখে আরও নির্ভরযোগ্য হবে।

এখন যেহেতু আপনি `Option` এবং `Result` enum-এর সাথে স্ট্যান্ডার্ড লাইব্রেরি জেনেরিক ব্যবহার করার দরকারী উপায়গুলো দেখেছেন, তাই আমরা আলোচনা করব কিভাবে জেনেরিক কাজ করে এবং আপনি কীভাবে আপনার কোডে সেগুলো ব্যবহার করতে পারেন।

[encoding]: ch18-03-oo-design-patterns.html#encoding-states-and-behavior-as-types
