```markdown
## Test-Driven Development (TDD) ব্যবহার করে লাইব্রেরির কার্যকারিতা তৈরি করা

এখন যেহেতু আমরা যুক্তি _src/lib.rs_-এ নিয়ে এসেছি এবং _src/main.rs_-এ আর্গুমেন্ট সংগ্রহ এবং error হ্যান্ডেল করার কাজ রেখেছি, তাই আমাদের কোডের মূল কার্যকারিতার জন্য test লেখা অনেক সহজ। কমান্ড লাইন থেকে আমাদের বাইনারি কল না করেই আমরা সরাসরি বিভিন্ন আর্গুমেন্ট দিয়ে ফাংশন কল করতে পারি এবং রিটার্ন ভ্যালুগুলো পরীক্ষা করতে পারি।

এই বিভাগে, আমরা test-driven development (TDD) প্রক্রিয়া ব্যবহার করে `minigrep` প্রোগ্রামে অনুসন্ধানের যুক্তি যোগ করব। TDD এর জন্য নিম্নলিখিত ধাপগুলো অনুসরণ করব:

1.  একটি test লিখুন যা fail করে এবং এটি নিশ্চিত করার জন্য চালান যে এটি আপনার প্রত্যাশিত কারণে fail করেছে।
2.  নতুন test পাস করার জন্য যথেষ্ট কোড লিখুন বা পরিবর্তন করুন।
3.  আপনি এইমাত্র যে কোড যোগ করেছেন বা পরিবর্তন করেছেন তা Refactor করুন এবং নিশ্চিত করুন যে test গুলো এখনও পাস করছে।
4.  ১ নম্বর ধাপ থেকে পুনরাবৃত্তি করুন!

যদিও এটি সফ্টওয়্যার লেখার অনেক পদ্ধতির মধ্যে একটি, TDD কোড ডিজাইন করতে সাহায্য করতে পারে। test পাস করার জন্য কোড লেখার আগে test লিখলে পুরো প্রক্রিয়া জুড়ে উচ্চ test কভারেজ বজায় রাখতে সাহায্য করে।

আমরা সেই কার্যকারিতার বাস্তবায়ন test-drive করব যা আসলে ফাইলের বিষয়বস্তুতে query string অনুসন্ধান করবে এবং query এর সাথে মেলে এমন লাইনগুলোর একটি তালিকা তৈরি করবে। আমরা `search` নামের একটি ফাংশনে এই কার্যকারিতা যোগ করব।

### একটি Fail করা Test লেখা

যেহেতু আমাদের এখন আর তাদের প্রয়োজন নেই, তাই _src/lib.rs_ এবং _src/main.rs_ থেকে `println!` স্টেটমেন্টগুলি সরিয়ে ফেলুন যা আমরা প্রোগ্রামের আচরণ পরীক্ষা করতে ব্যবহার করতাম। তারপরে, _src/lib.rs_-এ, আমরা একটি test ফাংশন সহ একটি `tests` মডিউল যোগ করব, যেমনটি আমরা [অধ্যায় 11][ch11-anatomy]<!-- ignore -->-এ করেছিলাম। test ফাংশনটি `search` ফাংশনের আচরণ নির্দিষ্ট করে যা আমরা চাই: এটি একটি query এবং অনুসন্ধান করার জন্য text নেবে এবং এটি text থেকে শুধুমাত্র সেই লাইনগুলি ফেরত দেবে যেগুলোতে query আছে। Listing 12-15 এই test দেখায়, যা এখনও compile হবে না।

<Listing number="12-15" file-name="src/lib.rs" caption="`search` ফাংশনের জন্য একটি fail করা test তৈরি করা যা আমরা পেতে চাই">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-15/src/lib.rs:here}}
```

</Listing>

এই test `"duct"` string-এর জন্য অনুসন্ধান করে। আমরা যে text অনুসন্ধান করছি তা তিনটি লাইনের, যার মধ্যে শুধুমাত্র একটিতে `"duct"` আছে (লক্ষ্য করুন যে opening double quote-এর পরে backslash Rust কে এই string literal-এর শুরুতে একটি newline character না রাখার জন্য বলছে)। আমরা দাবি করি যে `search` ফাংশন থেকে ফেরত মানটিতে শুধুমাত্র সেই লাইনটি রয়েছে যা আমরা আশা করি।

আমরা এখনও এই test টি চালাতে এবং fail করতে দেখতে পাচ্ছি না কারণ test টি compile ও হচ্ছে না: `search` ফাংশনটি এখনও বিদ্যমান নেই! TDD নীতি অনুসারে, আমরা `search` ফাংশনের একটি সংজ্ঞা যোগ করে test টি compile এবং চালানোর জন্য যথেষ্ট কোড যোগ করব যা সবসময় একটি খালি ভেক্টর প্রদান করে, যেমন Listing 12-16 এ দেখানো হয়েছে। তারপর test compile এবং fail করা উচিত কারণ একটি খালি ভেক্টর `“safe, fast, productive.”` লাইন ধারণকারী একটি ভেক্টরের সাথে মেলে না।

<Listing number="12-16" file-name="src/lib.rs" caption="`search` ফাংশনের কেবল যথেষ্ট সংজ্ঞা দেওয়া যাতে আমাদের test compile হবে">

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-16/src/lib.rs:here}}
```

</Listing>

লক্ষ্য করুন যে `search`-এর সংজ্ঞায় আমাদের একটি স্পষ্ট লাইফটাইম `'a` সংজ্ঞায়িত করতে হবে এবং `contents` আর্গুমেন্ট এবং রিটার্ন ভ্যালু সহ সেই লাইফটাইম ব্যবহার করতে হবে। [অধ্যায় 10][ch10-lifetimes]<!-- ignore -->-এ মনে রাখবেন যে লাইফটাইম প্যারামিটারগুলি নির্দিষ্ট করে যে কোন আর্গুমেন্টের লাইফটাইম রিটার্ন ভ্যালুর লাইফটাইমের সাথে সংযুক্ত। এই ক্ষেত্রে, আমরা নির্দেশ করি যে রিটার্ন করা ভেক্টরে স্ট্রিং স্লাইস থাকা উচিত যা আর্গুমেন্ট `contents`-এর স্লাইসগুলিকে রেফারেন্স করে (আর্গুমেন্ট `query` এর পরিবর্তে)।

অন্য কথায়, আমরা Rust কে বলি যে `search` ফাংশন দ্বারা ফেরত দেওয়া ডেটা `contents` আর্গুমেন্টে `search` ফাংশনে পাস করা ডেটা যতক্ষণ থাকবে ততক্ষণ পর্যন্ত লাইভ থাকবে। এটা গুরুত্বপূর্ণ! একটি স্লাইস দ্বারা রেফারেন্স করা ডেটা বৈধ হওয়ার জন্য রেফারেন্সটি বৈধ হতে হবে; যদি কম্পাইলার ধরে নেয় যে আমরা `contents` এর পরিবর্তে `query` এর স্ট্রিং স্লাইস তৈরি করছি, তবে এটি তার নিরাপত্তা পরীক্ষা ভুলভাবে করবে।

যদি আমরা লাইফটাইম টীকাগুলি ভুলে যাই এবং এই ফাংশনটি কম্পাইল করার চেষ্টা করি তবে আমরা এই error পাব:

```console
{{#include ../listings/ch12-an-io-project/output-only-02-missing-lifetimes/output.txt}}
```

Rust সম্ভবত জানতে পারে না যে আমাদের কোন দুটি আর্গুমেন্টের প্রয়োজন, তাই আমাদের এটি স্পষ্টভাবে জানাতে হবে। যেহেতু `contents` হল সেই আর্গুমেন্ট যাতে আমাদের সমস্ত text রয়েছে এবং আমরা সেই text-এর অংশগুলি ফেরত দিতে চাই যা মিলে যায়, তাই আমরা জানি যে `contents` হল সেই আর্গুমেন্ট যা লাইফটাইম সিনট্যাক্স ব্যবহার করে রিটার্ন ভ্যালুর সাথে সংযুক্ত হওয়া উচিত।

অন্যান্য প্রোগ্রামিং ভাষাগুলিতে আপনাকে সংজ্ঞায় রিটার্ন ভ্যালুর সাথে আর্গুমেন্টগুলিকে সংযুক্ত করার প্রয়োজন হয় না, তবে এই অনুশীলন সময়ের সাথে সহজ হয়ে যাবে। আপনি [“লাইফটাইম সহ রেফারেন্স যাচাইকরণ”][validating-references-with-lifetimes]<!-- ignore --> বিভাগে অধ্যায় 10-এর উদাহরণগুলির সাথে এই উদাহরণটি তুলনা করতে চাইতে পারেন।

এখন test টি চালাই:

```console
{{#include ../listings/ch12-an-io-project/listing-12-16/output.txt}}
```

দারুণ, test টি fail করেছে, ঠিক যেমনটি আমরা আশা করেছিলাম। চলুন test টি পাস করাই!

### Test পাস করার জন্য কোড লেখা

বর্তমানে, আমাদের test fail করছে কারণ আমরা সবসময় একটি খালি ভেক্টর ফেরত দিই। এটি ঠিক করতে এবং `search` প্রয়োগ করতে, আমাদের প্রোগ্রামকে নিম্নলিখিত পদক্ষেপগুলি অনুসরণ করতে হবে:

1.  বিষয়বস্তুর প্রতিটি লাইনের মাধ্যমে পুনরাবৃত্তি করুন।
2.  লাইনটিতে আমাদের query string আছে কিনা তা পরীক্ষা করুন।
3.  যদি থাকে, তাহলে আমরা যে মানগুলি ফেরত দিচ্ছি তার তালিকায় যোগ করুন।
4.  যদি না থাকে তবে কিছুই করবেন না।
5.  ফলাফলের তালিকাটি ফেরত দিন যা মিলে যায়।

আসুন প্রতিটি ধাপের মাধ্যমে কাজ করি, লাইনগুলির মাধ্যমে পুনরাবৃত্তি করা দিয়ে শুরু করি।

#### `lines` মেথড দিয়ে লাইনের মধ্যে পুনরাবৃত্তি করা

Rust-এর string-এর লাইন-বাই-লাইন পুনরাবৃত্তি করার জন্য একটি সহায়ক মেথড রয়েছে, যার নাম `lines`, যা Listing 12-17 এ দেখানো হয়েছে। মনে রাখবেন যে এটি এখনও compile হবে না।

<Listing number="12-17" file-name="src/lib.rs" caption="`contents`-এর প্রতিটি লাইনের মাধ্যমে পুনরাবৃত্তি করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-17/src/lib.rs:here}}
```

</Listing>

`lines` মেথড একটি iterator ফেরত দেয়। আমরা [অধ্যায় 13][ch13-iterators]<!-- ignore -->-এ iterator নিয়ে বিস্তারিত আলোচনা করব, কিন্তু মনে রাখবেন যে আপনি [Listing 3-5][ch3-iter]<!-- ignore -->-এ iterator ব্যবহারের এই উপায়টি দেখেছিলেন, যেখানে আমরা একটি `for` লুপ ব্যবহার করেছি একটি iterator এর সাথে একটি collection এর প্রতিটি আইটেমের উপর কিছু কোড চালানোর জন্য।

#### Query-এর জন্য প্রতিটি লাইন অনুসন্ধান করা

এর পরে, আমরা পরীক্ষা করব যে বর্তমান লাইনে আমাদের query string আছে কিনা। সৌভাগ্যক্রমে, string-এর `contains` নামের একটি সহায়ক মেথড আছে যা আমাদের জন্য এটি করে! `search` ফাংশনে `contains` মেথডের একটি কল যোগ করুন, যেমন Listing 12-18 এ দেখানো হয়েছে। মনে রাখবেন যে এটি এখনও compile হবে না।

<Listing number="12-18" file-name="src/lib.rs" caption="লাইনটিতে `query`-এর string আছে কিনা তা দেখার জন্য কার্যকারিতা যোগ করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-18/src/lib.rs:here}}
```

</Listing>

এই মুহূর্তে, আমরা কার্যকারিতা তৈরি করছি। কোডটি compile করার জন্য, আমাদের ফাংশন সংজ্ঞায় যেমন ইঙ্গিত দিয়েছিলাম বডি থেকে একটি মান ফেরত দিতে হবে।

#### ম্যাচিং লাইনগুলি সংরক্ষণ করা

এই ফাংশনটি শেষ করতে, আমাদের ম্যাচিং লাইনগুলি সংরক্ষণ করার একটি উপায় প্রয়োজন যা আমরা ফেরত দিতে চাই। এর জন্য, আমরা `for` লুপের আগে একটি পরিবর্তনযোগ্য ভেক্টর তৈরি করতে পারি এবং ভেক্টরে একটি `line` সংরক্ষণ করতে `push` মেথড কল করতে পারি। `for` লুপের পরে, আমরা ভেক্টরটি ফেরত দিই, যেমন Listing 12-19 এ দেখানো হয়েছে।

<Listing number="12-19" file-name="src/lib.rs" caption="যে লাইনগুলো মিলে যায় সেগুলো সংরক্ষণ করা যাতে আমরা সেগুলো ফেরত দিতে পারি">

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-19/src/lib.rs:here}}
```

</Listing>

এখন `search` ফাংশনটি শুধুমাত্র সেই লাইনগুলি ফেরত দেবে যেগুলিতে `query` আছে, এবং আমাদের test পাস করা উচিত। test চালাই:

```console
{{#include ../listings/ch12-an-io-project/listing-12-19/output.txt}}
```

আমাদের test পাস করেছে, তাই আমরা জানি যে এটি কাজ করে!

এই মুহুর্তে, আমরা `search` ফাংশনের বাস্তবতাকে refactor করার সুযোগগুলি বিবেচনা করতে পারি যখন test পাস করে একই কার্যকারিতা বজায় রাখে। `search` ফাংশনের কোড খুব খারাপ নয়, তবে এটি iterator-এর কিছু দরকারী বৈশিষ্ট্য ব্যবহার করে না। আমরা [অধ্যায় 13][ch13-iterators]<!-- ignore -->-এ এই উদাহরণে ফিরে আসব, যেখানে আমরা iterator নিয়ে বিস্তারিত আলোচনা করব এবং এটিকে কীভাবে উন্নত করা যায় তা দেখব।

#### `run` ফাংশনে `search` ফাংশন ব্যবহার করা

এখন যেহেতু `search` ফাংশনটি কাজ করছে এবং test করা হয়েছে, তাই আমাদের `run` ফাংশন থেকে `search` কল করতে হবে। `search` ফাংশনে আমাদের `config.query` মান এবং `run` ফাংশন ফাইল থেকে যে `contents` পড়ে তা পাস করতে হবে। তারপর `run` ফাংশন `search` থেকে ফেরত আসা প্রতিটি লাইন প্রিন্ট করবে:

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/src/lib.rs:here}}
```

আমরা এখনও `search` থেকে প্রতিটি লাইন ফেরত দিতে এবং প্রিন্ট করতে একটি `for` লুপ ব্যবহার করছি।

এখন পুরো প্রোগ্রাম কাজ করা উচিত! আসুন এটি চেষ্টা করে দেখি, প্রথমে এমন একটি শব্দ দিয়ে যা এমিলি ডিকিনসনের কবিতা থেকে ঠিক একটি লাইন ফেরত দেবে: _frog_।

```console
{{#include ../listings/ch12-an-io-project/no-listing-02-using-search-in-run/output.txt}}
```

দারুণ! এখন এমন একটি শব্দ চেষ্টা করা যাক যা একাধিক লাইনের সাথে মিলবে, যেমন _body_:

```console
{{#include ../listings/ch12-an-io-project/output-only-03-multiple-matches/output.txt}}
```

এবং অবশেষে, আসুন নিশ্চিত করি যে আমরা যখন এমন একটি শব্দ খুঁজি যা কবিতার কোথাও নেই, যেমন _monomorphization_: তখন আমরা কোনো লাইন পাব না:

```console
{{#include ../listings/ch12-an-io-project/output-only-04-no-matches/output.txt}}
```

চমৎকার! আমরা একটি ক্লাসিক টুলের নিজস্ব মিনি সংস্করণ তৈরি করেছি এবং অ্যাপ্লিকেশনগুলি কীভাবে তৈরি করতে হয় সে সম্পর্কে অনেক কিছু শিখেছি। আমরা ফাইল ইনপুট এবং আউটপুট, লাইফটাইম, টেস্টিং এবং কমান্ড লাইন পার্সিং সম্পর্কেও কিছুটা শিখেছি।

এই প্রকল্পটি শেষ করতে, আমরা সংক্ষেপে দেখাব কিভাবে এনভায়রনমেন্ট ভেরিয়েবলগুলির সাথে কাজ করতে হয় এবং কীভাবে স্ট্যান্ডার্ড error-এ প্রিন্ট করতে হয়, এই দুটিই কমান্ড লাইন প্রোগ্রাম লেখার সময় কাজে লাগে।

[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[ch11-anatomy]: ch11-01-writing-tests.html#the-anatomy-of-a-test-function
[ch10-lifetimes]: ch10-03-lifetime-syntax.html
[ch3-iter]: ch03-05-control-flow.html#looping-through-a-collection-with-for
[ch13-iterators]: ch13-02-iterators.html
```
