## Ownership কি?

_Ownership_ হলো কিছু নিয়ম যা একটি Rust প্রোগ্রাম কিভাবে মেমরি ম্যানেজ করে তা নির্ধারণ করে।

সব প্রোগ্রামকেই চলার সময় কম্পিউটারের মেমরি ব্যবহারের পদ্ধতি ম্যানেজ করতে হয়। কিছু ভাষায় garbage collection থাকে যা প্রোগ্রাম চলার সময় নিয়মিতভাবে অব্যবহৃত মেমরি খুঁজে বের করে; অন্যান্য ভাষায়, প্রোগ্রামারকে স্পষ্টভাবে মেমরি allocate এবং free করতে হয়। Rust তৃতীয় একটি পদ্ধতি ব্যবহার করে: Ownership সিস্টেমের মাধ্যমে মেমরি ম্যানেজ করা হয়, যেখানে কিছু নিয়ম আছে যা কম্পাইলার চেক করে। যদি কোনো নিয়ম ভঙ্গ হয়, তাহলে প্রোগ্রাম compile হবে না। Ownership এর কোনো বৈশিষ্ট্যই প্রোগ্রাম চলার সময় এর গতি কমাবে না।

যেহেতু Ownership অনেক প্রোগ্রামারের জন্য একটি নতুন ধারণা, তাই এটি আয়ত্ত করতে কিছুটা সময় লাগে। ভালো খবর হলো, Rust এবং Ownership সিস্টেমের নিয়মগুলির সাথে আপনি যত বেশি অভিজ্ঞ হবেন, তত সহজে আপনি নিরাপদ এবং কার্যকর কোড তৈরি করতে পারবেন। চেষ্টা চালিয়ে যান!

যখন আপনি Ownership বুঝবেন, তখন আপনি Rust এর বৈশিষ্ট্যগুলি বোঝার জন্য একটি শক্ত ভিত্তি পাবেন। এই অধ্যায়ে, আপনি Ownership শিখবেন কিছু উদাহরণের মাধ্যমে, যা একটি খুব সাধারণ ডেটা স্ট্রাকচার: স্ট্রিং-এর উপর ফোকাস করবে।

> ### Stack এবং Heap
>
> অনেক প্রোগ্রামিং ভাষায় আপনাকে Stack এবং Heap নিয়ে বেশি চিন্তা করতে হয় না। কিন্তু Rust এর মতো একটি সিস্টেম প্রোগ্রামিং ভাষায়, একটি ভ্যালু Stack এ আছে নাকি Heap এ, তা ভাষার আচরণ এবং কিছু সিদ্ধান্ত নেওয়ার ক্ষেত্রে প্রভাব ফেলে। Ownership এর কিছু অংশ Stack এবং Heap এর সাথে সম্পর্কিত করে এই অধ্যায়ের পরে আলোচনা করা হবে, তাই এখানে একটি সংক্ষিপ্ত ব্যাখ্যা দেওয়া হলো।
>
> Stack এবং Heap দুটোই রানটাইমে আপনার কোড ব্যবহারের জন্য উপলব্ধ মেমরির অংশ, তবে এগুলি ভিন্নভাবে গঠিত। Stack ভ্যালুগুলিকে সেই অর্ডারে স্টোর করে যেভাবে সেগুলি পায় এবং বিপরীত অর্ডারে ভ্যালুগুলিকে সরিয়ে দেয়। একে _last in, first out_ বলা হয়। প্লেটের একটি স্তূপের কথা ভাবুন: যখন আপনি আরও প্লেট যোগ করেন, তখন আপনি সেগুলিকে স্তূপের উপরে রাখেন, এবং যখন আপনার প্লেটের প্রয়োজন হয়, তখন আপনি উপরের একটি সরিয়ে নেন। মাঝখান থেকে বা নিচ থেকে প্লেট যোগ বা সরানো ততটা ভালোভাবে কাজ করবে না! ডেটা যোগ করাকে _pushing onto the stack_ বলা হয় এবং ডেটা সরানোকে _popping off the stack_ বলা হয়। Stack এ স্টোর করা সমস্ত ডেটার একটি পরিচিত, fixed size থাকতে হবে। compile time এ অজানা আকারের বা পরিবর্তন হতে পারে এমন ডেটা অবশ্যই Heap এ স্টোর করতে হবে।
>
> Heap কম সুসংগঠিত: যখন আপনি Heap এ ডেটা রাখেন, তখন আপনি একটি নির্দিষ্ট পরিমাণ জায়গার জন্য অনুরোধ করেন। মেমরি অ্যালোকেটর Heap এ যথেষ্ট বড় একটি খালি জায়গা খুঁজে বের করে, এটিকে ব্যবহার করা হচ্ছে বলে চিহ্নিত করে, এবং একটি _pointer_ রিটার্ন করে, যা সেই লোকেশনের ঠিকানা। এই প্রক্রিয়াকে _allocating on the heap_ বলা হয় এবং মাঝে মাঝে শুধু _allocating_ হিসাবেও লেখা হয় (Stack এ ভ্যালু push করাকে allocating হিসাবে ধরা হয় না)। যেহেতু Heap এর pointer একটি পরিচিত, fixed size, তাই আপনি pointer টিকে Stack এ স্টোর করতে পারেন, কিন্তু যখন আপনার আসল ডেটার প্রয়োজন হয়, তখন আপনাকে pointer অনুসরণ করতে হবে। একটি রেস্টুরেন্টে বসার কথা ভাবুন। যখন আপনি প্রবেশ করেন, তখন আপনি আপনার গ্রুপের লোকের সংখ্যা বলেন, এবং হোস্ট এমন একটি খালি টেবিল খুঁজে বের করেন যা সবার জন্য উপযুক্ত এবং আপনাকে সেখানে নিয়ে যান। যদি আপনার গ্রুপের কেউ পরে আসে, তবে তারা আপনাকে খুঁজে বের করার জন্য জিজ্ঞাসা করতে পারে যে আপনি কোথায় বসেছেন।
>
> Stack এ push করা Heap এ allocate করার চেয়ে দ্রুত, কারণ অ্যালোকেটরকে নতুন ডেটা স্টোর করার জন্য কোনো জায়গা খুঁজতে হয় না; সেই লোকেশন সবসময় Stack এর উপরে থাকে। তুলনামূলকভাবে, Heap এ জায়গা allocate করার জন্য আরও বেশি কাজ করতে হয়, কারণ অ্যালোকেটরকে প্রথমে ডেটা রাখার জন্য যথেষ্ট বড় জায়গা খুঁজে বের করতে হয় এবং তারপরে পরবর্তী allocation এর জন্য প্রস্তুতি নিতে বুককিপিং করতে হয়।
>
> Heap এ ডেটা অ্যাক্সেস করা Stack এর ডেটা অ্যাক্সেস করার চেয়ে ধীর, কারণ সেখানে পৌঁছানোর জন্য আপনাকে একটি pointer অনুসরণ করতে হয়। আধুনিক প্রসেসরগুলি মেমরিতে কম ঘোরাঘুরি করলে দ্রুত কাজ করে। সাদৃশ্য বজায় রেখে, একটি রেস্টুরেন্টে একজন ওয়েটার অনেক টেবিল থেকে অর্ডার নেওয়ার কথা ভাবুন। এক টেবিলের সব অর্ডার নিয়ে তারপর অন্য টেবিলে যাওয়া সবচেয়ে ভালো। টেবিল A থেকে একটি অর্ডার, তারপর টেবিল B থেকে একটি অর্ডার, তারপর আবার A থেকে একটি এবং তারপর আবার B থেকে একটি অর্ডার নেওয়া অনেক ধীর প্রক্রিয়া হবে। একইভাবে, একটি প্রসেসর ডেটার কাছাকাছি থাকলে (যেমন Stack এ থাকে) ভালোভাবে কাজ করতে পারে, দূর থেকে (যেমন Heap এ থাকতে পারে) কাজ করার চেয়ে।
>
> যখন আপনার কোড কোনো function কল করে, তখন function এ পাস করা ভ্যালুগুলি (সম্ভাব্যত Heap এ ডেটার pointer সহ) এবং function এর local ভেরিয়েবলগুলি Stack এ push করা হয়। যখন function শেষ হয়, তখন সেই ভ্যালুগুলি Stack থেকে pop করা হয়।
>
> Heap এ কোডের কোন অংশ কোন ডেটা ব্যবহার করছে, Heap এ ডুপ্লিকেট ডেটার পরিমাণ কমানো এবং অব্যবহৃত ডেটা পরিষ্কার করা যাতে আপনার জায়গা শেষ না হয়ে যায়, এই সব সমস্যা ownership সমাধান করে। একবার আপনি ownership বুঝতে পারলে, আপনাকে Stack এবং Heap নিয়ে বেশি চিন্তা করতে হবে না, তবে ownership এর মূল উদ্দেশ্য হল Heap ডেটা ম্যানেজ করা, যা এটি কেন এভাবে কাজ করে তা ব্যাখ্যা করতে সাহায্য করতে পারে।

### Ownership এর নিয়ম

প্রথমে, Ownership এর নিয়মগুলো দেখে নেওয়া যাক। এই নিয়মগুলো মনে রাখুন যখন আমরা উদাহরণগুলো দেখব:

- Rust এ প্রতিটি ভ্যালুর একজন _owner_ থাকে।
- এক সময়ে শুধুমাত্র একজন owner থাকতে পারে।
- যখন owner scope এর বাইরে চলে যায়, তখন ভ্যালু drop হয়ে যায়।

### Variable Scope

এখন যেহেতু আমরা Rust এর মৌলিক সিনট্যাক্স পেরিয়ে এসেছি, তাই আমরা উদাহরণগুলিতে `fn main() {` কোড অন্তর্ভুক্ত করব না, তাই আপনি যদি অনুসরণ করেন, তবে নিশ্চিত করুন যে আপনি নিম্নলিখিত উদাহরণগুলি ম্যানুয়ালি একটি `main` ফাংশনের ভিতরে রেখেছেন। ফলস্বরূপ, আমাদের উদাহরণগুলি আরও সংক্ষিপ্ত হবে, যা আমাদের boilerplate কোডের পরিবর্তে আসল বিবরণের দিকে মনোযোগ দিতে দেবে।

Ownership এর প্রথম উদাহরণ হিসাবে, আমরা কিছু ভেরিয়েবলের _scope_ দেখব। একটি scope হল প্রোগ্রামের মধ্যে সেই পরিসর যেখানে একটি আইটেম বৈধ। নিম্নলিখিত ভেরিয়েবলটি নিন:

```rust
let s = "hello";
```

ভেরিয়েবল `s` একটি string literal কে নির্দেশ করে, যেখানে string এর ভ্যালু আমাদের প্রোগ্রামের টেক্সটে হার্ডকোড করা আছে। ভেরিয়েবলটি সেই পয়েন্ট থেকে বৈধ যেখানে এটি ডিক্লেয়ার করা হয়েছে, বর্তমান _scope_ শেষ না হওয়া পর্যন্ত। Listing 4-1 এ একটি প্রোগ্রাম দেখানো হয়েছে যেখানে কমেন্ট দিয়ে চিহ্নিত করা হয়েছে যে ভেরিয়েবল `s` কোথায় বৈধ হবে।

<Listing number="4-1" caption="একটি ভেরিয়েবল এবং যে scope এ এটি বৈধ">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-01/src/main.rs:here}}
```

</Listing>

অন্য কথায়, এখানে দুটি গুরুত্বপূর্ণ সময় আছে:

- যখন `s` scope _এ আসে_, তখন এটি বৈধ হয়।
- এটি scope _এর বাইরে_ না যাওয়া পর্যন্ত বৈধ থাকে।

এই মুহুর্তে, scope এবং কখন ভেরিয়েবল বৈধ থাকে তার মধ্যেকার সম্পর্ক অন্যান্য প্রোগ্রামিং ভাষার মতোই। এখন আমরা `String` টাইপ প্রবর্তন করে এই বোঝার উপর ভিত্তি তৈরি করব।

### `String` টাইপ

Ownership এর নিয়মগুলি ব্যাখ্যা করার জন্য, আমাদের এমন একটি ডেটা টাইপের প্রয়োজন যা [“Data Types”][data-types]<!-- ignore --> বিভাগে কভার করা ডেটা টাইপের চেয়ে জটিল। পূর্বে কভার করা টাইপগুলির একটি পরিচিত আকার আছে, সেগুলিকে Stack এ স্টোর করা যায় এবং যখন তাদের scope শেষ হয়ে যায় তখন pop করা যায়, এবং যদি কোডের অন্য কোনো অংশের একই ভ্যালু অন্য scope এ ব্যবহার করার প্রয়োজন হয়, তাহলে নতুন, স্বাধীন ইনস্ট্যান্স তৈরি করার জন্য দ্রুত এবং সহজে কপি করা যেতে পারে। কিন্তু আমরা এমন ডেটা দেখতে চাই যা Heap এ স্টোর করা আছে এবং Rust কিভাবে সেই ডেটা পরিষ্কার করতে জানে তা জানতে চাই, এবং `String` টাইপটি এর জন্য একটি দারুণ উদাহরণ।

আমরা `String` এর সেই অংশগুলির উপর মনোযোগ দেব যা Ownership এর সাথে সম্পর্কিত। এই দিকগুলি অন্যান্য জটিল ডেটা টাইপের ক্ষেত্রেও প্রযোজ্য, সেগুলি স্ট্যান্ডার্ড লাইব্রেরি দ্বারা সরবরাহ করা হোক বা আপনার দ্বারা তৈরি করা হোক। আমরা [Chapter 8][ch8]<!-- ignore --> এ `String` নিয়ে আরও বিস্তারিত আলোচনা করব।

আমরা ইতিমধ্যেই string literal দেখেছি, যেখানে একটি string ভ্যালু আমাদের প্রোগ্রামে হার্ডকোড করা থাকে। string literal সুবিধাজনক, কিন্তু সেগুলি সব পরিস্থিতিতে উপযুক্ত নয় যেখানে আমরা টেক্সট ব্যবহার করতে চাই। এর একটি কারণ হল সেগুলি immutable। আরেকটি কারণ হল, আমরা যখন কোড লিখি তখন প্রতিটি string ভ্যালু জানা সম্ভব নয়: উদাহরণস্বরূপ, যদি আমরা ব্যবহারকারীর ইনপুট নিতে এবং তা স্টোর করতে চাই? এই পরিস্থিতিতে, Rust এর কাছে দ্বিতীয় একটি string টাইপ আছে, `String`। এই টাইপটি Heap এ allocate করা ডেটা ম্যানেজ করে এবং সেই কারণে compile time এ অজানা পরিমাণের টেক্সট স্টোর করতে সক্ষম। আপনি `from` ফাংশন ব্যবহার করে একটি string literal থেকে `String` তৈরি করতে পারেন, যেমন:

```rust
let s = String::from("hello");
```

ডাবল কোলন `::` অপারেটরটি `string_from` এর মতো কোনো নাম ব্যবহার না করে `String` টাইপের অধীনে এই বিশেষ `from` ফাংশনটিকে namespace করার অনুমতি দেয়। আমরা [“Method Syntax”][method-syntax]<!-- ignore --> বিভাগে Chapter 5 এ এবং [“Paths for Referring to an Item in the Module Tree”][paths-module-tree]<!-- ignore --> বিভাগে Chapter 7 এ মডিউল সহ namespace নিয়ে আলোচনা করব।

এই ধরনের string _পরিবর্তন করা যেতে পারে_:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-01-can-mutate-string/src/main.rs:here}}
```

তাহলে, এখানে পার্থক্য কি? কেন `String` পরিবর্তন করা যেতে পারে কিন্তু literals করা যায় না? পার্থক্য হল এই দুটি টাইপ কিভাবে মেমরি নিয়ে কাজ করে তার মধ্যে।

### মেমরি এবং Allocation

String literal এর ক্ষেত্রে, আমরা compile time এ কন্টেন্ট জানি, তাই টেক্সট সরাসরি ফাইনাল এক্সিকিউটেবলে হার্ডকোড করা থাকে। এই কারণে string literal দ্রুত এবং কার্যকর। কিন্তু এই বৈশিষ্ট্যগুলি শুধুমাত্র string literal এর immutability থেকে আসে। দুর্ভাগ্যবশত, আমরা মেমরির একটি blob বাইনারিতে রাখতে পারি না প্রতিটি টেক্সটের জন্য যার আকার compile time এ অজানা এবং প্রোগ্রাম চলার সময় যার আকার পরিবর্তন হতে পারে।

`String` টাইপের সাথে, একটি পরিবর্তনযোগ্য, growable টেক্সট সমর্থন করার জন্য, আমাদের Heap এ একটি নির্দিষ্ট পরিমাণ মেমরি allocate করতে হবে, যা compile time এ অজানা, কন্টেন্টগুলি রাখার জন্য। এর মানে হল:

- রানটাইমে মেমরি অ্যালোকেটরের কাছ থেকে মেমরির জন্য অনুরোধ করতে হবে।
- যখন আমাদের `String` এর কাজ শেষ হয়ে যাবে, তখন এই মেমরি অ্যালোকেটরকে ফেরত দেওয়ার একটি উপায় আমাদের দরকার।

প্রথম কাজটি আমরা করি: যখন আমরা `String::from` কল করি, তখন এর বাস্তবায়ন প্রয়োজনীয় মেমরির জন্য অনুরোধ করে। প্রোগ্রামিং ভাষাগুলিতে এটি প্রায় সার্বজনীন।

তবে, দ্বিতীয় অংশটি আলাদা। _garbage collector (GC)_ সহ ভাষাগুলিতে, GC সেই মেমরি ট্র্যাক করে এবং পরিষ্কার করে যা আর ব্যবহার করা হচ্ছে না, এবং আমাদের এটি নিয়ে চিন্তা করার প্রয়োজন নেই। GC ছাড়া বেশিরভাগ ভাষায়, যখন মেমরি আর ব্যবহার করা হচ্ছে না তা সনাক্ত করা এবং এটিকে স্পষ্টভাবে free করার জন্য কোড কল করা আমাদের দায়িত্ব, ঠিক যেমন আমরা এটির জন্য অনুরোধ করেছিলাম। সঠিকভাবে এটি করা ঐতিহাসিকভাবে একটি কঠিন প্রোগ্রামিং সমস্যা ছিল। যদি আমরা ভুলে যাই, তাহলে আমরা মেমরি নষ্ট করব। যদি আমরা খুব তাড়াতাড়ি করি, তাহলে আমাদের একটি অবৈধ ভেরিয়েবল থাকবে। যদি আমরা এটি দুবার করি, তবে সেটিও একটি বাগ। আমাদের ঠিক একটি `allocate` এর সাথে একটি `free` যুক্ত করতে হবে।

Rust একটি ভিন্ন পথ নেয়: মেমরি স্বয়ংক্রিয়ভাবে ফেরত দেওয়া হয় যখন ভেরিয়েবল যার মালিকানা আছে তা স্কোপের বাইরে চলে যায়। এখানে Listing 4-1 থেকে আমাদের স্কোপ উদাহরণের একটি সংস্করণ দেওয়া হল, যেখানে একটি string literal এর পরিবর্তে `String` ব্যবহার করা হয়েছে:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-02-string-scope/src/main.rs:here}}
```

একটি স্বাভাবিক বিন্দু আছে যেখানে আমরা আমাদের `String` এর জন্য প্রয়োজনীয় মেমরি অ্যালোকেটরকে ফেরত দিতে পারি: যখন `s` scope এর বাইরে চলে যায়। যখন একটি ভেরিয়েবল scope এর বাইরে চলে যায়, তখন Rust আমাদের জন্য একটি বিশেষ ফাংশন কল করে। এই ফাংশনটিকে [`drop`][drop]<!-- ignore --> বলা হয়, এবং এটি সেই জায়গা যেখানে `String` এর লেখক মেমরি ফেরত দেওয়ার জন্য কোড রাখতে পারেন। Rust closing curly bracket এ স্বয়ংক্রিয়ভাবে `drop` কল করে।

> মনে রাখবেন: C++ এ, একটি আইটেমের জীবনকালের শেষে রিসোর্স ডিঅ্যালোকেট করার এই প্যাটার্নটিকে কখনও কখনও _Resource Acquisition Is Initialization (RAII)_ বলা হয়। আপনি যদি RAII প্যাটার্ন ব্যবহার করে থাকেন তবে Rust এর `drop` ফাংশন আপনার কাছে পরিচিত হবে।

এই প্যাটার্নটি Rust কোড লেখার পদ্ধতিতে গভীর প্রভাব ফেলে। এখন এটি সহজ মনে হতে পারে, তবে কোডের আচরণ আরও জটিল পরিস্থিতিতে অপ্রত্যাশিত হতে পারে যখন আমরা চাই একাধিক ভেরিয়েবল Heap এ allocate করা ডেটা ব্যবহার করুক। আসুন এখন সেই পরিস্থিতিগুলির কিছু অন্বেষণ করি।

<!-- Old heading. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-move"></a>

#### ভেরিয়েবল এবং ডেটা Move এর সাথে ইন্টারঅ্যাক্ট করা

Rust এ একাধিক ভেরিয়েবল একই ডেটার সাথে বিভিন্নভাবে ইন্টারঅ্যাক্ট করতে পারে। Listing 4-2 এ একটি ইন্টিজার ব্যবহার করে একটি উদাহরণ দেখা যাক।

<Listing number="4-2" caption="ভেরিয়েবল `x` এর ইন্টিজার ভ্যালু `y` এ অ্যাসাইন করা">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-02/src/main.rs:here}}
```

</Listing>

আমরা সম্ভবত অনুমান করতে পারি যে এটি কী করছে: “`5` ভ্যালুটিকে `x` এর সাথে বাইন্ড করুন; তারপর `x` এর ভ্যালুর একটি কপি তৈরি করুন এবং সেটিকে `y` এর সাথে বাইন্ড করুন।” এখন আমাদের কাছে দুটি ভেরিয়েবল আছে, `x` এবং `y`, এবং উভয়ই `5` এর সমান। প্রকৃতপক্ষে এটাই ঘটছে, কারণ ইন্টিজারগুলি একটি পরিচিত, fixed size সহ সহজ ভ্যালু, এবং এই দুটি `5` ভ্যালু Stack এ push করা হয়েছে।

এখন `String` এর সংস্করণটি দেখা যাক:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-03-string-move/src/main.rs:here}}
```

এটি দেখতে খুব একই রকম, তাই আমরা ধরে নিতে পারি যে এটি একই ভাবে কাজ করবে: অর্থাৎ, দ্বিতীয় লাইনটি `s1` এর ভ্যালুর একটি কপি তৈরি করবে এবং সেটিকে `s2` এর সাথে বাইন্ড করবে। কিন্তু এটি ঠিক তেমন ঘটে না।

ভেতরে `String` এর সাথে কী ঘটছে তা দেখতে Figure 4-1 এ একবার দেখে নিন। একটি `String` তিনটি অংশ দিয়ে তৈরি, যা বাম দিকে দেখানো হয়েছে: string এর কন্টেন্ট ধারণকারী মেমরির একটি pointer, একটি দৈর্ঘ্য এবং একটি ক্যাপাসিটি। এই ডেটার গ্রুপটি Stack এ স্টোর করা আছে। ডানদিকে Heap এ সেই মেমরি আছে যা কন্টেন্টগুলি ধরে রেখেছে।

<img alt="Two tables: the first table contains the representation of s1 on the
stack, consisting of its length (5), capacity (5), and a pointer to the first
value in the second table. The second table contains the representation of the
string data on the heap, byte by byte." src="img/trpl04-01.svg" class="center"
style="width: 50%;" />

<span class="caption">Figure 4-1: `String` এর মেমরিতে উপস্থাপনা, যার মান `"hello"` এবং যা `s1` এর সাথে বাইন্ড করা হয়েছে</span>

দৈর্ঘ্য হল `String` এর কন্টেন্ট বর্তমানে কত মেমরি ব্যবহার করছে, বাইটে। ক্যাপাসিটি হল মেমরির মোট পরিমাণ, বাইটে, যা `String` অ্যালোকেটরের কাছ থেকে পেয়েছে। দৈর্ঘ্য এবং ক্যাপাসিটির মধ্যে পার্থক্য গুরুত্বপূর্ণ, তবে এই প্রসঙ্গে নয়, তাই আপাতত ক্যাপাসিটিকে উপেক্ষা করাই ভালো।

যখন আমরা `s1` কে `s2` এ অ্যাসাইন করি, তখন `String` ডেটা কপি করা হয়, যার মানে হল আমরা pointer, দৈর্ঘ্য এবং ক্যাপাসিটি কপি করি যা Stack এ আছে। আমরা Heap এ থাকা ডেটা কপি করি না যা pointer নির্দেশ করে। অন্য কথায়, মেমরিতে ডেটার উপস্থাপনা Figure 4-2 এর মতো দেখায়।

<img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap."
src="img/trpl04-02.svg" class="center" style="width: 50%;" />

<span class="caption">Figure 4-2: ভেরিয়েবল `s2` এর মেমরিতে উপস্থাপনা, যার `s1` এর pointer, দৈর্ঘ্য এবং ক্যাপাসিটির একটি কপি আছে</span>
মেমরি উপস্থাপনা Figure 4-3 এর মতো দেখায় না, যেখানে মেমরি দেখতে কেমন হতো যদি Rust Heap ডেটাও কপি করত। যদি Rust এটি করত, তাহলে Heap এ ডেটা বড় হলে `s2 = s1` অপারেশনটি রানটাইম পারফরম্যান্সের দিক থেকে খুব ব্যয়বহুল হতে পারত।

<img alt="Four tables: two tables representing the stack data for s1 and s2,
and each points to its own copy of string data on the heap."
src="img/trpl04-03.svg" class="center" style="width: 50%;" />

<span class="caption">Figure 4-3: `s2 = s1` করলে Rust যদি Heap ডেটাও কপি করত তাহলে আরেকটি সম্ভাবনা</span>

আগে, আমরা বলেছিলাম যে যখন একটি ভেরিয়েবল scope এর বাইরে চলে যায়, তখন Rust স্বয়ংক্রিয়ভাবে `drop` ফাংশন কল করে এবং সেই ভেরিয়েবলের জন্য Heap মেমরি পরিষ্কার করে। কিন্তু Figure 4-2 দেখায় যে উভয় ডেটা পয়েন্টার একই লোকেশন নির্দেশ করছে। এটি একটি সমস্যা: যখন `s2` এবং `s1` scope এর বাইরে চলে যায়, তখন তারা উভয়েই একই মেমরি free করার চেষ্টা করবে। একে _double free_ ত্রুটি বলা হয় এবং এটি হল মেমরি নিরাপত্তার সেই বাগগুলির মধ্যে একটি যা আমরা আগে উল্লেখ করেছি। দুবার মেমরি free করলে মেমরি করাপ্ট হতে পারে, যা সম্ভাব্যভাবে নিরাপত্তা দুর্বলতার দিকে নিয়ে যেতে পারে।

মেমরি নিরাপত্তা নিশ্চিত করার জন্য, `let s2 = s1;` লাইনটির পরে, Rust `s1` কে আর বৈধ মনে করে না। তাই, যখন `s1` scope এর বাইরে চলে যায় তখন Rust কে আর কিছু free করতে হয় না। `s2` তৈরি হওয়ার পরে আপনি যখন `s1` ব্যবহার করার চেষ্টা করেন তখন কী ঘটে তা দেখুন; এটি কাজ করবে না:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/src/main.rs:here}}
```

আপনি এইরকম একটি ত্রুটি পাবেন কারণ Rust আপনাকে অবৈধ রেফারেন্স ব্যবহার করা থেকে বাধা দেয়:

```console
{{#include ../listings/ch04-understanding-ownership/no-listing-04-cant-use-after-move/output.txt}}
```

আপনি যদি অন্য ভাষায় কাজ করার সময় _shallow copy_ এবং _deep copy_ শব্দগুলি শুনে থাকেন, তাহলে ডেটা কপি না করে pointer, দৈর্ঘ্য এবং ক্যাপাসিটি কপি করার ধারণাটিকে সম্ভবত shallow copy করার মতো শোনাচ্ছে। কিন্তু যেহেতু Rust প্রথম ভেরিয়েবলটিকে অবৈধ করে দেয়, তাই shallow copy না বলে একে _move_ বলা হয়। এই উদাহরণে, আমরা বলব যে `s1` কে `s2` তে _move_ করা হয়েছে। তাহলে, আসলে কী ঘটে তা Figure 4-4 এ দেখানো হয়েছে।

<img alt="Three tables: tables s1 and s2 representing those strings on the
stack, respectively, and both pointing to the same string data on the heap.
Table s1 is grayed out be-cause s1 is no longer valid; only s2 can be used to
access the heap data." src="img/trpl04-04.svg" class="center" style="width:
50%;" />

<span class="caption">Figure 4-4: `s1` অবৈধ হওয়ার পরে মেমরিতে উপস্থাপনা</span>

এটি আমাদের সমস্যার সমাধান করে! যেহেতু শুধুমাত্র `s2` বৈধ, তাই যখন এটি scope এর বাইরে চলে যায় তখন এটি একা মেমরি free করবে, এবং আমাদের কাজ শেষ।

এছাড়াও, এর মাধ্যমে একটি ডিজাইনের পছন্দ বোঝানো হয়েছে: Rust কখনই স্বয়ংক্রিয়ভাবে আপনার ডেটার "deep" কপি তৈরি করবে না। অতএব, কোনো _স্বয়ংক্রিয়_ কপি runtime পারফরম্যান্সের দিক থেকে সস্তা বলে ধরে নেওয়া যেতে পারে।

#### Scope এবং Assignment

scoping, ownership এবং `drop` ফাংশনের মাধ্যমে মেমরি free হওয়ার মধ্যে সম্পর্কটির বিপরীতটিও সত্য। আপনি যখন কোনো বিদ্যমান ভেরিয়েবলে সম্পূর্ণ নতুন মান অ্যাসাইন করেন, তখন Rust `drop` কল করবে এবং মূল মানের মেমরি অবিলম্বে free করবে। উদাহরণস্বরূপ, এই কোডটি বিবেচনা করুন:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-04b-replacement-drop/src/main.rs:here}}
```

আমরা প্রথমে একটি ভেরিয়েবল `s` ডিক্লেয়ার করি এবং এটিকে `"hello"` মান সহ একটি `String` এর সাথে বাইন্ড করি। তারপর আমরা অবিলম্বে `"ahoy"` মান সহ একটি নতুন `String` তৈরি করি এবং সেটিকে `s` এ অ্যাসাইন করি। এই মুহুর্তে, Heap এ থাকা আসল মানটিকে আর কেউ নির্দেশ করছে না।

<img alt="One table s representing the string value on the stack, pointing to
the second piece of string data (ahoy) on the heap, with the original string
data (hello) grayed out because it cannot be accessed anymore."
src="img/trpl04-05.svg"
class="center"
style="width: 50%;"
/>

<span class="caption">Figure 4-5: মেমরিতে উপস্থাপনা যখন প্রাথমিক মান সম্পূর্ণরূপে প্রতিস্থাপিত করা হয়েছে।</span>

সুতরাং মূল স্ট্রিংটি সঙ্গে সঙ্গেই scope এর বাইরে চলে যায়। Rust এটির উপর `drop` ফাংশন চালাবে এবং এর মেমরি সাথে সাথেই free হয়ে যাবে। যখন আমরা শেষে মানটি প্রিন্ট করব, তখন এটি হবে `"ahoy, world!"`।

<!-- Old heading. Do not remove or links may break. -->

<a id="ways-variables-and-data-interact-clone"></a>

#### ভেরিয়েবল এবং ডেটা Clone এর সাথে ইন্টারঅ্যাক্ট করা

যদি আমরা `String` এর Heap ডেটার deep copy করতে চাই, শুধু Stack ডেটার নয়, তাহলে আমরা `clone` নামক একটি সাধারণ পদ্ধতি ব্যবহার করতে পারি। আমরা Chapter 5 এ মেথড সিনট্যাক্স নিয়ে আলোচনা করব, কিন্তু যেহেতু মেথডগুলি অনেক প্রোগ্রামিং ভাষায় একটি সাধারণ বৈশিষ্ট্য, তাই আপনি সম্ভবত সেগুলি আগে দেখেছেন।

এখানে `clone` পদ্ধতির একটি উদাহরণ দেওয়া হল:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-05-clone/src/main.rs:here}}
```

এটি ঠিকঠাক কাজ করে এবং স্পষ্টভাবে Figure 4-3 এ দেখানো আচরণ তৈরি করে, যেখানে Heap ডেটা _কপি_ করা হয়।

যখন আপনি `clone` এর কল দেখেন, তখন আপনি জানেন যে কিছু নির্বিচারে কোড এক্সিকিউট করা হচ্ছে এবং সেই কোডটি ব্যয়বহুল হতে পারে। এটি একটি ভিজ্যুয়াল নির্দেশক যে কিছু ভিন্ন ঘটছে।

#### শুধুমাত্র Stack ডেটা: Copy

এখানে আরেকটি বিষয় আছে যা নিয়ে আমরা এখনও কথা বলিনি। ইন্টিজার ব্যবহার করে এই কোডটি—যার কিছু অংশ Listing 4-2 এ দেখানো হয়েছে—কাজ করে এবং বৈধ:

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/no-listing-06-copy/src/main.rs:here}}
```

কিন্তু এই কোডটি আমরা যা শিখলাম তার সাথে সাংঘর্ষিক মনে হচ্ছে: আমাদের `clone` এর কোনো কল নেই, কিন্তু `x` এখনও বৈধ এবং `y` তে move করা হয়নি।

এর কারণ হল ইন্টিজারের মতো টাইপগুলি, যাদের compile time এ একটি পরিচিত আকার আছে, সেগুলি সম্পূর্ণরূপে Stack এ স্টোর করা হয়, তাই আসল মানগুলির কপি তৈরি করা দ্রুত। এর মানে হল `y` ভেরিয়েবল তৈরি করার পরে `x` কে বৈধ হতে বাধা দেওয়ার কোনো কারণ নেই। অন্য কথায়, এখানে deep এবং shallow কপি করার মধ্যে কোনো পার্থক্য নেই, তাই `clone` কল করলে সাধারণ shallow কপি করা থেকে আলাদা কিছু হবে না, এবং আমরা এটিকে বাদ দিতে পারি।

Rust এর `Copy` নামক একটি বিশেষ অ্যানোটেশন আছে যা আমরা Stack এ স্টোর করা টাইপের উপর রাখতে পারি, যেমন ইন্টিজার (আমরা [Chapter 10][traits]<!-- ignore --> এ traits সম্পর্কে আরও আলোচনা করব)। যদি কোনো টাইপ `Copy` trait প্রয়োগ করে, তবে যে ভেরিয়েবলগুলি এটি ব্যবহার করে সেগুলি move হয় না, বরং সাধারণভাবে কপি করা হয়, যা অন্য ভেরিয়েবলে অ্যাসাইন করার পরেও সেগুলিকে বৈধ রাখে।

যদি টাইপটি, বা এর কোনো অংশের `Drop` trait প্রয়োগ করা থাকে, তবে Rust আমাদের সেই টাইপটিকে `Copy` দিয়ে অ্যানোটেট করতে দেবে না। যদি টাইপের মান scope এর বাইরে গেলে বিশেষ কিছু করার প্রয়োজন হয় এবং আমরা সেই টাইপে `Copy` অ্যানোটেশন যোগ করি, তাহলে আমরা compile time এ একটি ত্রুটি পাব। আপনার টাইপে `Copy` অ্যানোটেশন যোগ করে trait প্রয়োগ করার বিষয়ে জানতে, Appendix C তে [“Derivable Traits”][derivable-traits]<!-- ignore --> দেখুন।

তাহলে, কোন টাইপগুলি `Copy` trait প্রয়োগ করে? আপনি নিশ্চিত হওয়ার জন্য প্রদত্ত টাইপের ডকুমেন্টেশন পরীক্ষা করতে পারেন, তবে একটি সাধারণ নিয়ম হিসাবে, সাধারণ স্কেলার মানের যেকোনো গ্রুপ `Copy` প্রয়োগ করতে পারে এবং allocation প্রয়োজন হয় বা কোনো রিসোর্স এমন কিছুই `Copy` প্রয়োগ করতে পারে না। এখানে কিছু টাইপ দেওয়া হল যা `Copy` প্রয়োগ করে:

- সমস্ত ইন্টিজার টাইপ, যেমন `u32`।
- বুলিয়ান টাইপ, `bool`, যার মান `true` এবং `false`।
- সমস্ত ফ্লোটিং-পয়েন্ট টাইপ, যেমন `f64`।
- ক্যারেক্টার টাইপ, `char`।
- Tuple, যদি সেগুলিতে শুধুমাত্র সেই টাইপগুলি থাকে যা `Copy` প্রয়োগ করে। উদাহরণস্বরূপ, `(i32, i32)` `Copy` প্রয়োগ করে, কিন্তু `(i32, String)` করে না।

### Ownership এবং ফাংশন

একটি ফাংশনে একটি মান পাস করার নিয়মগুলি একটি ভেরিয়েবলে একটি মান অ্যাসাইন করার মতোই। একটি ভেরিয়েবলকে একটি ফাংশনে পাস করলে সেটি move বা copy হবে, ঠিক যেমন অ্যাসাইনমেন্টে হয়। Listing 4-3 এ কিছু অ্যানোটেশন সহ একটি উদাহরণ রয়েছে, যা দেখায় ভেরিয়েবলগুলি কোথায় scope এর ভিতরে এবং বাইরে যায়।

<Listing number="4-3" file-name="src/main.rs" caption="Ownership এবং scope এর অ্যানোটেশন সহ ফাংশন">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-03/src/main.rs}}
```

</Listing>

যদি আমরা `takes_ownership` এ কল করার পরে `s` ব্যবহার করার চেষ্টা করি, তাহলে Rust একটি compile-time ত্রুটি দেখাবে। এই স্ট্যাটিক চেকগুলি আমাদের ভুল থেকে রক্ষা করে। `main` এ কোড যোগ করার চেষ্টা করুন যা `s` এবং `x` ব্যবহার করে, এটি দেখার জন্য যে আপনি সেগুলি কোথায় ব্যবহার করতে পারেন এবং কোথায় Ownership এর নিয়মগুলি আপনাকে তা করতে বাধা দেয়।

### Return ভ্যালু এবং Scope

Return ভ্যালুগুলিও Ownership স্থানান্তর করতে পারে। Listing 4-4 এ একটি ফাংশনের উদাহরণ দেখানো হয়েছে যা কিছু মান রিটার্ন করে, Listing 4-3 এর মতো একই অ্যানোটেশন সহ।

<Listing number="4-4" file-name="src/main.rs" caption="Return ভ্যালুগুলির Ownership স্থানান্তর করা">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-04/src/main.rs}}
```

</Listing>

একটি ভেরিয়েবলের Ownership সবসময় একই প্যাটার্ন অনুসরণ করে: অন্য ভেরিয়েবলে একটি মান অ্যাসাইন করলে সেটি move হয়। যখন Heap এ ডেটা সহ একটি ভেরিয়েবল scope এর বাইরে চলে যায়, তখন `drop` দ্বারা মানটি পরিষ্কার করা হবে, যদি না ডেটার Ownership অন্য কোনো ভেরিয়েবলে move করা হয়ে থাকে।

যদিও এটি কাজ করে, প্রতিটি ফাংশনের সাথে ownership নেওয়া এবং তারপর ownership ফেরত দেওয়া একটু ক্লান্তিকর। যদি আমরা কোনো ফাংশনকে একটি মান ব্যবহার করতে দিতে চাই কিন্তু ownership নিতে না দিতে চাই তাহলে কি হবে? এটা খুবই বিরক্তিকর যে আমরা যা কিছু পাস করি তা যদি আমরা আবার ব্যবহার করতে চাই তবে তা ফেরতও দিতে হয়, সেই সাথে ফাংশনের বডি থেকে আসা ডেটা যোগ করে যা আমরা ফেরত দিতে চাই।

Rust আমাদের একটি Tuple ব্যবহার করে একাধিক মান ফেরত দিতে দেয়, যেমন Listing 4-5 এ দেখানো হয়েছে।

<Listing number="4-5" file-name="src/main.rs" caption="প্যারামিটারের Ownership ফেরত দেওয়া">

```rust
{{#rustdoc_include ../listings/ch04-understanding-ownership/listing-04-05/src/main.rs}}
```

</Listing>

কিন্তু এটি খুব বেশি আনুষ্ঠানিকতা এবং এমন একটি ধারণার জন্য অনেক কাজ যা সাধারণ হওয়া উচিত। সৌভাগ্যবশত আমাদের জন্য, Rust এর এমন একটি বৈশিষ্ট্য রয়েছে যা Ownership স্থানান্তর না করে একটি মান ব্যবহার করার জন্য, যাকে _reference_ বলা হয়।

[data-types]: ch03-02-data-types.html#data-types
[ch8]: ch08-02-strings.html
[traits]: ch10-02-traits.html
[derivable-traits]: appendix-03-derivable-traits.html
[method-syntax]: ch05-03-method-syntax.html#method-syntax
[paths-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
[drop]: ../std/ops/trait.Drop.html#tymethod.drop
