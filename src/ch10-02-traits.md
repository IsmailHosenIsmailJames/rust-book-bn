## ট্রেট: শেয়ার্ড আচরণ সংজ্ঞায়িত করা

একটি _ট্রেট_ একটি নির্দিষ্ট টাইপের কার্যকারিতা সংজ্ঞায়িত করে এবং অন্যান্য টাইপের সাথে শেয়ার করতে পারে। আমরা একটি বিমূর্ত উপায়ে শেয়ার্ড আচরণ সংজ্ঞায়িত করতে ট্রেট ব্যবহার করতে পারি। আমরা _ট্রেট বাউন্ড_ ব্যবহার করে নির্দিষ্ট করতে পারি যে একটি জেনেরিক টাইপ যেকোনো টাইপ হতে পারে যার একটি নির্দিষ্ট আচরণ আছে।

> দ্রষ্টব্য: ট্রেটগুলো অন্যান্য ভাষায় প্রায়শই _ইন্টারফেস_ নামক একটি বৈশিষ্ট্যের মতো, যদিও কিছু পার্থক্য রয়েছে।

### একটি ট্রেট সংজ্ঞায়িত করা

একটি টাইপের আচরণ সেই মেথডগুলো নিয়ে গঠিত যা আমরা সেই টাইপের উপর কল করতে পারি। বিভিন্ন টাইপ একই আচরণ শেয়ার করে যদি আমরা সেই সমস্ত টাইপের উপর একই মেথড কল করতে পারি। ট্রেট সংজ্ঞাগুলো হল মেথড সিগনেচারগুলোকে একত্রিত করার একটি উপায় যাতে কোনো উদ্দেশ্য সাধনের জন্য প্রয়োজনীয় আচরণের একটি সেট সংজ্ঞায়িত করা যায়।

উদাহরণস্বরূপ, ধরা যাক আমাদের কাছে বিভিন্ন প্রকার এবং পরিমাণের টেক্সট ধারণকারী একাধিক struct আছে: একটি `NewsArticle` struct যা একটি নির্দিষ্ট স্থানে ফাইল করা একটি খবরের গল্প ধারণ করে এবং একটি `Tweet` যাতে সর্বোচ্চ 280টি ক্যারেক্টার থাকতে পারে এবং এর সাথে মেটাডেটা থাকে যা নির্দেশ করে যে এটি একটি নতুন টুইট, একটি রিটুইট বা অন্য একটি টুইটের উত্তর কিনা।

আমরা `aggregator` নামের একটি মিডিয়া এগ্রিগেটর লাইব্রেরি ক্রেট তৈরি করতে চাই যা `NewsArticle` বা `Tweet` ইনস্ট্যান্সে স্টোর করা ডেটার সারসংক্ষেপ প্রদর্শন করতে পারে। এটি করার জন্য, আমাদের প্রতিটি টাইপের একটি সারসংক্ষেপ প্রয়োজন, এবং আমরা একটি ইনস্ট্যান্সে `summarize` মেথড কল করে সেই সারসংক্ষেপের জন্য অনুরোধ করব। Listing 10-12 একটি পাবলিক `Summary` ট্রেটের সংজ্ঞা দেখায় যা এই আচরণ প্রকাশ করে।

<Listing number="10-12" file-name="src/lib.rs" caption="একটি `Summary` ট্রেট যা `summarize` মেথড দ্বারা প্রদত্ত আচরণ নিয়ে গঠিত">

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-12/src/lib.rs}}
```

</Listing>

এখানে, আমরা `trait` কিওয়ার্ড এবং তারপর ট্রেটের নাম ব্যবহার করে একটি ট্রেট ঘোষণা করি, যা এই ক্ষেত্রে `Summary`। আমরা ট্রেটটিকে `pub` হিসাবেও ঘোষণা করি যাতে এই ক্রেটের উপর নির্ভরশীল ক্রেটগুলোও এই ট্রেটটি ব্যবহার করতে পারে, যেমন আমরা কয়েকটি উদাহরণে দেখব। কোঁকড়া বন্ধনীর ভিতরে, আমরা মেথড সিগনেচারগুলো ঘোষণা করি যা এই ট্রেট প্রয়োগ করে এমন টাইপগুলোর আচরণ বর্ণনা করে, যা এই ক্ষেত্রে `fn summarize(&self) -> String`।

মেথড সিগনেচারের পরে, কোঁকড়া বন্ধনীর মধ্যে একটি বাস্তবায়ন প্রদান করার পরিবর্তে, আমরা একটি সেমিকোলন ব্যবহার করি। এই ট্রেট প্রয়োগকারী প্রতিটি টাইপকে মেথডের বডির জন্য নিজস্ব কাস্টম আচরণ প্রদান করতে হবে। কম্পাইলার নিশ্চিত করবে যে `Summary` ট্রেট আছে এমন যেকোনো টাইপে `summarize` মেথডটি এই সিগনেচার সহ সঠিকভাবে সংজ্ঞায়িত করা আছে।

একটি ট্রেটের বডিতে একাধিক মেথড থাকতে পারে: মেথড সিগনেচারগুলো প্রতি লাইনে একটি করে তালিকাভুক্ত করা হয় এবং প্রতিটি লাইন একটি সেমিকোলন দিয়ে শেষ হয়।

### একটি টাইপের উপর একটি ট্রেট প্রয়োগ করা

এখন যেহেতু আমরা `Summary` ট্রেটের মেথডগুলোর পছন্দসই সিগনেচার সংজ্ঞায়িত করেছি, আমরা আমাদের মিডিয়া এগ্রিগেটরের টাইপগুলোতে এটি প্রয়োগ করতে পারি। Listing 10-13 `NewsArticle` struct-এর উপর `Summary` ট্রেটের একটি বাস্তবায়ন দেখায় যা `summarize`-এর রিটার্ন ভ্যালু তৈরি করতে শিরোনাম, লেখক এবং স্থান ব্যবহার করে। `Tweet` struct-এর জন্য, আমরা `summarize`-কে ব্যবহারকারীর নাম এবং তারপরে টুইটের সম্পূর্ণ টেক্সট হিসাবে সংজ্ঞায়িত করি, ধরে নিই যে টুইটের কন্টেন্ট ইতিমধ্যেই 280 ক্যারেক্টারে সীমিত।

<Listing number="10-13" file-name="src/lib.rs" caption="`NewsArticle` এবং `Tweet` টাইপের উপর `Summary` ট্রেট প্রয়োগ করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-13/src/lib.rs:here}}
```

</Listing>

একটি টাইপের উপর একটি ট্রেট প্রয়োগ করা নিয়মিত মেথড প্রয়োগ করার মতোই। পার্থক্য হল যে `impl`-এর পরে, আমরা যে ট্রেটটি প্রয়োগ করতে চাই তার নাম রাখি, তারপর `for` কিওয়ার্ড ব্যবহার করি এবং তারপর আমরা যে টাইপের জন্য ট্রেটটি প্রয়োগ করতে চাই তার নাম উল্লেখ করি। `impl` ব্লকের ভিতরে, আমরা সেই মেথড সিগনেচারগুলো রাখি যা ট্রেট সংজ্ঞায় সংজ্ঞায়িত করা হয়েছে। প্রতিটি সিগনেচারের পরে একটি সেমিকোলন যোগ করার পরিবর্তে, আমরা কোঁকড়া বন্ধনী ব্যবহার করি এবং একটি বিশেষ টাইপের জন্য ট্রেটের মেথডগুলোর যে নির্দিষ্ট আচরণ আমরা রাখতে চাই তা দিয়ে মেথডের বডি পূরণ করি।

এখন যেহেতু লাইব্রেরি `NewsArticle` এবং `Tweet`-এর উপর `Summary` ট্রেট প্রয়োগ করেছে, ক্রেটের ব্যবহারকারীরা `NewsArticle` এবং `Tweet`-এর উদাহরণে ঠিক একইভাবে ট্রেট মেথড কল করতে পারে যেভাবে আমরা নিয়মিত মেথড কল করি। একমাত্র পার্থক্য হল ব্যবহারকারীকে টাইপের পাশাপাশি ট্রেটটিকেও স্কোপে আনতে হবে। এখানে একটি উদাহরণ দেওয়া হল যে কীভাবে একটি বাইনারি ক্রেট আমাদের `aggregator` লাইব্রেরি ক্রেট ব্যবহার করতে পারে:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-01-calling-trait-method/src/main.rs}}
```

এই কোডটি প্রিন্ট করে `1 new tweet: horse_ebooks: of course, as you probably already
know, people`।

`aggregator` ক্রেটের উপর নির্ভরশীল অন্যান্য ক্রেটও তাদের নিজস্ব টাইপে `Summary` প্রয়োগ করতে `Summary` ট্রেটটিকে স্কোপে আনতে পারে। মনে রাখার মতো একটি সীমাবদ্ধতা হল যে আমরা একটি টাইপের উপর একটি ট্রেট প্রয়োগ করতে পারি যদি ট্রেট বা টাইপ, বা উভয়ই, আমাদের ক্রেটের স্থানীয় হয়। উদাহরণস্বরূপ, আমরা আমাদের `aggregator` ক্রেট কার্যকারিতার অংশ হিসাবে `Tweet`-এর মতো একটি কাস্টম টাইপের উপর `Display`-এর মতো স্ট্যান্ডার্ড লাইব্রেরি ট্রেট প্রয়োগ করতে পারি কারণ `Tweet` টাইপটি আমাদের `aggregator` ক্রেটের স্থানীয়। আমরা আমাদের `aggregator` ক্রেটে `Vec<T>`-এর উপর `Summary`-ও প্রয়োগ করতে পারি কারণ `Summary` ট্রেটটি আমাদের `aggregator` ক্রেটের স্থানীয়।

কিন্তু আমরা বাহ্যিক টাইপের উপর বাহ্যিক ট্রেট প্রয়োগ করতে পারি না। উদাহরণস্বরূপ, আমরা আমাদের `aggregator` ক্রেটের মধ্যে `Vec<T>`-এর উপর `Display` ট্রেট প্রয়োগ করতে পারি না কারণ `Display` এবং `Vec<T>` উভয়ই স্ট্যান্ডার্ড লাইব্রেরিতে সংজ্ঞায়িত করা হয়েছে এবং আমাদের `aggregator` ক্রেটের স্থানীয় নয়। এই সীমাবদ্ধতাটি _সঙ্গতি_ নামক একটি বৈশিষ্ট্যের অংশ, এবং আরও বিশেষভাবে _অরফান রুল_, এর নামকরণ করা হয়েছে কারণ প্যারেন্ট টাইপ উপস্থিত নেই। এই নিয়মটি নিশ্চিত করে যে অন্য লোকেদের কোড আপনার কোডকে এবং এর বিপরীতে ভাঙতে পারবে না। নিয়মটি না থাকলে, দুটি ক্রেট একই টাইপের জন্য একই ট্রেট প্রয়োগ করতে পারত, এবং রাস্ট জানত না কোন বাস্তবায়ন ব্যবহার করতে হবে।

### ডিফল্ট বাস্তবায়ন

কখনও কখনও প্রতিটি টাইপের সমস্ত মেথডের বাস্তবায়নের প্রয়োজন না করে একটি ট্রেটের কিছু বা সমস্ত মেথডের জন্য ডিফল্ট আচরণ থাকা দরকারী। তারপর, যখন আমরা একটি নির্দিষ্ট টাইপে ট্রেট প্রয়োগ করি, তখন আমরা প্রতিটি মেথডের ডিফল্ট আচরণ রাখতে বা ওভাররাইড করতে পারি।

Listing 10-14-এ, আমরা `Summary` ট্রেটের `summarize` মেথডের জন্য শুধুমাত্র মেথড সিগনেচার সংজ্ঞায়িত করার পরিবর্তে একটি ডিফল্ট স্ট্রিং নির্দিষ্ট করি, যেমনটি আমরা Listing 10-12-এ করেছিলাম।

<Listing number="10-14" file-name="src/lib.rs" caption="`summarize` মেথডের একটি ডিফল্ট বাস্তবায়ন সহ একটি `Summary` ট্রেট সংজ্ঞায়িত করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-14/src/lib.rs:here}}
```

</Listing>

`NewsArticle`-এর উদাহরণ সংক্ষিপ্ত করার জন্য একটি ডিফল্ট বাস্তবায়ন ব্যবহার করতে, আমরা `impl Summary for NewsArticle {}` সহ একটি খালি `impl` ব্লক উল্লেখ করি।

যদিও আমরা সরাসরি `NewsArticle`-এ `summarize` মেথড সংজ্ঞায়িত করছি না, আমরা একটি ডিফল্ট বাস্তবায়ন প্রদান করেছি এবং নির্দিষ্ট করেছি যে `NewsArticle` `Summary` ট্রেট প্রয়োগ করে। ফলস্বরূপ, আমরা এখনও `NewsArticle`-এর একটি উদাহরণে `summarize` মেথড কল করতে পারি, যেমন:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-02-calling-default-impl/src/main.rs:here}}
```

এই কোডটি প্রিন্ট করে `New article available! (Read more...)`।

একটি ডিফল্ট বাস্তবায়ন তৈরি করার জন্য Listing 10-13-এ `Tweet`-এর উপর `Summary`-এর বাস্তবায়ন সম্পর্কে কোনো পরিবর্তন করার প্রয়োজন হয় না। কারণ হল যে একটি ডিফল্ট বাস্তবায়নকে ওভাররাইড করার সিনট্যাক্স হল একটি ট্রেট মেথড বাস্তবায়নের সিনট্যাক্সের মতোই যার কোনো ডিফল্ট বাস্তবায়ন নেই।

ডিফল্ট বাস্তবায়নগুলো একই ট্রেটের অন্যান্য মেথড কল করতে পারে, এমনকি যদি সেই অন্যান্য মেথডগুলোর ডিফল্ট বাস্তবায়ন নাও থাকে। এইভাবে, একটি ট্রেট অনেক দরকারী কার্যকারিতা প্রদান করতে পারে এবং বাস্তবায়নকারীদের শুধুমাত্র এর একটি ছোট অংশ নির্দিষ্ট করতে বলতে পারে। উদাহরণস্বরূপ, আমরা `Summary` ট্রেটটিকে `summarize_author` মেথড সহ সংজ্ঞায়িত করতে পারি যার বাস্তবায়ন প্রয়োজন, এবং তারপর একটি `summarize` মেথড সংজ্ঞায়িত করতে পারি যার একটি ডিফল্ট বাস্তবায়ন রয়েছে যা `summarize_author` মেথড কল করে:

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:here}}
```

`Summary`-এর এই সংস্করণটি ব্যবহার করতে, একটি টাইপে ট্রেট প্রয়োগ করার সময় আমাদের শুধুমাত্র `summarize_author` সংজ্ঞায়িত করতে হবে:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/lib.rs:impl}}
```

`summarize_author` সংজ্ঞায়িত করার পরে, আমরা `Tweet` struct-এর উদাহরণে `summarize` কল করতে পারি এবং `summarize`-এর ডিফল্ট বাস্তবায়নটি আমরা যে `summarize_author` সংজ্ঞায়িত করেছি তা কল করবে। যেহেতু আমরা `summarize_author` প্রয়োগ করেছি, তাই `Summary` ট্রেটটি আমাদের `summarize` মেথডের আচরণ দিয়েছে এবং এর জন্য আমাদের আর কোনো কোড লিখতে হয়নি। এখানে এটি দেখতে কেমন:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-03-default-impl-calls-other-methods/src/main.rs:here}}
```

এই কোডটি প্রিন্ট করে `1 new tweet: (Read more from @horse_ebooks...)`।

মনে রাখবেন যে একই মেথডের একটি ওভাররাইডিং বাস্তবায়ন থেকে ডিফল্ট বাস্তবায়নকে কল করা সম্ভব নয়।

### প্যারামিটার হিসাবে ট্রেট

এখন যেহেতু আপনি জানেন কিভাবে ট্রেট সংজ্ঞায়িত এবং প্রয়োগ করতে হয়, আমরা অন্বেষণ করতে পারি কিভাবে বিভিন্ন টাইপ গ্রহণ করে এমন ফাংশন সংজ্ঞায়িত করতে ট্রেট ব্যবহার করতে হয়। আমরা Listing 10-13-এ `NewsArticle` এবং `Tweet` টাইপের উপর প্রয়োগ করা `Summary` ট্রেটটি ব্যবহার করব একটি `notify` ফাংশন সংজ্ঞায়িত করতে যা এর `item` প্যারামিটারে `summarize` মেথড কল করে, যা এমন কিছু টাইপের যা `Summary` ট্রেট প্রয়োগ করে। এটি করতে, আমরা `impl Trait` সিনট্যাক্স ব্যবহার করি, যেমন:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-04-traits-as-parameters/src/lib.rs:here}}
```

`item` প্যারামিটারের জন্য একটি কংক্রিট টাইপের পরিবর্তে, আমরা `impl` কিওয়ার্ড এবং ট্রেটের নাম উল্লেখ করি। এই প্যারামিটারটি নির্দিষ্ট ট্রেট প্রয়োগ করে এমন যেকোনো টাইপ গ্রহণ করে। `notify`-এর বডিতে, আমরা `item`-এ `Summary` ট্রেট থেকে আসা যেকোনো মেথড কল করতে পারি, যেমন `summarize`। আমরা `notify` কল করতে পারি এবং `NewsArticle` বা `Tweet`-এর যেকোনো উদাহরণ পাস করতে পারি। অন্য কোনো টাইপ, যেমন `String` বা `i32`, দিয়ে ফাংশন কল করা কোড কম্পাইল হবে না কারণ সেই টাইপগুলো `Summary` প্রয়োগ করে না।

<!-- Old headings. Do not remove or links may break. -->

<a id="fixing-the-largest-function-with-trait-bounds"></a>

#### ট্রেট বাউন্ড সিনট্যাক্স

`impl Trait` সিনট্যাক্স সরল ক্ষেত্রে কাজ করে তবে এটি আসলে একটি দীর্ঘ ফর্মের সিনট্যাক্স সুগার যা _ট্রেট বাউন্ড_ নামে পরিচিত; এটি দেখতে এইরকম:

```rust,ignore
pub fn notify<T: Summary>(item: &T) {
    println!("Breaking news! {}", item.summarize());
}
```

এই দীর্ঘ ফর্মটি আগের বিভাগের উদাহরণের সমতুল্য কিন্তু আরও বিস্তারিত। আমরা একটি কোলন এবং কোণের বন্ধনীর ভিতরে একটি জেনেরিক টাইপ প্যারামিটারের ঘোষণার সাথে ট্রেট বাউন্ড রাখি।

`impl Trait` সিনট্যাক্সটি সুবিধাজনক এবং সাধারণ ক্ষেত্রে আরও সংক্ষিপ্ত কোড তৈরি করে, অন্যদিকে সম্পূর্ণ ট্রেট বাউন্ড সিনট্যাক্স অন্যান্য ক্ষেত্রে আরও জটিলতা প্রকাশ করতে পারে। উদাহরণস্বরূপ, আমাদের দুটি প্যারামিটার থাকতে পারে যা `Summary` প্রয়োগ করে। `impl Trait` সিনট্যাক্স দিয়ে এটি করলে দেখতে এইরকম হয়:

```rust,ignore
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
```

যদি আমরা চাই যে এই ফাংশনটি `item1` এবং `item2`-কে বিভিন্ন প্রকারের (যতক্ষণ উভয় প্রকারই `Summary` প্রয়োগ করে) অনুমতি দেয় তবে `impl Trait` ব্যবহার করা উপযুক্ত। যদি আমরা উভয় প্যারামিটারকে একই টাইপের হতে বাধ্য করতে চাই, তবে আমাদের একটি ট্রেট বাউন্ড ব্যবহার করতে হবে, যেমন:

```rust,ignore
pub fn notify<T: Summary>(item1: &T, item2: &T) {
```

জেনেরিক টাইপ `T` যা `item1` এবং `item2` প্যারামিটারের টাইপ হিসাবে নির্দিষ্ট করা হয়েছে তা ফাংশনটিকে এমনভাবে সীমাবদ্ধ করে যে `item1` এবং `item2`-এর জন্য আর্গুমেন্ট হিসাবে পাস করা ভ্যালুর কংক্রিট টাইপ একই হতে হবে।

#### `+` সিনট্যাক্স সহ একাধিক ট্রেট বাউন্ড নির্দিষ্ট করা

আমরা একাধিক ট্রেট বাউন্ডও নির্দিষ্ট করতে পারি। ধরুন আমরা `notify`-কে `item`-এ `summarize` করার পাশাপাশি ডিসপ্লে ফরম্যাটিং ব্যবহার করতে চাই: আমরা `notify` সংজ্ঞায় নির্দিষ্ট করি যে `item`-কে অবশ্যই `Display` এবং `Summary` উভয়ই প্রয়োগ করতে হবে। আমরা `+` সিনট্যাক্স ব্যবহার করে এটি করতে পারি:

```rust,ignore
pub fn notify(item: &(impl Summary + Display)) {
```

জেনেরিক টাইপের উপর ট্রেট বাউন্ডের সাথেও `+` সিনট্যাক্স বৈধ:

```rust,ignore
pub fn notify<T: Summary + Display>(item: &T) {
```

দুটি ট্রেট বাউন্ড নির্দিষ্ট করার সাথে, `notify`-এর বডি `summarize` কল করতে পারে এবং `item` ফরম্যাট করতে `{}` ব্যবহার করতে পারে।

#### `where` ক্লজ সহ আরও স্পষ্ট ট্রেট বাউন্ড

অতিরিক্ত ট্রেট বাউন্ড ব্যবহারের কিছু অসুবিধা রয়েছে। প্রতিটি জেনেরিকের নিজস্ব ট্রেট বাউন্ড রয়েছে, তাই একাধিক জেনেরিক টাইপ প্যারামিটারযুক্ত ফাংশনে ফাংশনের নাম এবং এর প্যারামিটার তালিকার মধ্যে প্রচুর ট্রেট বাউন্ড তথ্য থাকতে পারে, যা ফাংশনের সিগনেচার পড়া কঠিন করে তোলে। এই কারণে, রাস্টের ফাংশন সিগনেচারের পরে একটি `where` ক্লজের ভিতরে ট্রেট বাউন্ড নির্দিষ্ট করার বিকল্প সিনট্যাক্স রয়েছে। সুতরাং, এটি লেখার পরিবর্তে:

```rust,ignore
fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {
```

আমরা একটি `where` ক্লজ ব্যবহার করতে পারি, যেমন:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-07-where-clause/src/lib.rs:here}}
```

এই ফাংশনের সিগনেচারটি কম বিশৃঙ্খল: ফাংশনের নাম, প্যারামিটার তালিকা এবং রিটার্ন টাইপ কাছাকাছি থাকে, অনেকটা প্রচুর ট্রেট বাউন্ড ছাড়া একটি ফাংশনের মতো।

### এমন টাইপ রিটার্ন করা যা ট্রেট প্রয়োগ করে

আমরা একটি ট্রেট প্রয়োগ করে এমন কিছু টাইপের ভ্যালু রিটার্ন করতে রিটার্ন অবস্থানে `impl Trait` সিনট্যাক্সও ব্যবহার করতে পারি, যেমনটি এখানে দেখানো হয়েছে:

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-05-returning-impl-trait/src/lib.rs:here}}
```

রিটার্ন টাইপের জন্য `impl Summary` ব্যবহার করে, আমরা নির্দিষ্ট করি যে `returns_summarizable` ফাংশন এমন কিছু টাইপ রিটার্ন করে যা কংক্রিট টাইপের নামকরণ না করে `Summary` ট্রেট প্রয়োগ করে। এই ক্ষেত্রে, `returns_summarizable` একটি `Tweet` রিটার্ন করে, কিন্তু এই ফাংশন কল করা কোডের তা জানার প্রয়োজন নেই।

যে টাইপটি প্রয়োগ করে তার মাধ্যমে একটি রিটার্ন টাইপ নির্দিষ্ট করার ক্ষমতা ক্লোজার এবং ইটারেটরের প্রেক্ষাপটে বিশেষভাবে কার্যকর, যা আমরা Chapter 13-এ আলোচনা করব। ক্লোজার এবং ইটারেটর এমন টাইপ তৈরি করে যা শুধুমাত্র কম্পাইলার জানে বা এমন টাইপ যা নির্দিষ্ট করতে অনেক দীর্ঘ। `impl Trait` সিনট্যাক্স আপনাকে খুব দীর্ঘ টাইপ লেখার প্রয়োজন ছাড়াই সংক্ষিপ্তভাবে নির্দিষ্ট করতে দেয় যে একটি ফাংশন এমন কিছু টাইপ রিটার্ন করে যা `Iterator` ট্রেট প্রয়োগ করে।

যাইহোক, আপনি যদি একটি একক টাইপ রিটার্ন করেন তবেই আপনি `impl Trait` ব্যবহার করতে পারেন। উদাহরণস্বরূপ, এই কোডটি যা `impl Summary` হিসাবে নির্দিষ্ট রিটার্ন টাইপের সাথে একটি `NewsArticle` বা একটি `Tweet` রিটার্ন করে তা কাজ করবে না:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-06-impl-trait-returns-one-type/src/lib.rs:here}}
```

`NewsArticle` বা `Tweet` এর যেকোনো একটি রিটার্ন করা `impl Trait` সিনট্যাক্স কম্পাইলারে কিভাবে প্রয়োগ করা হয় তার সীমাবদ্ধতার কারণে অনুমোদিত নয়। আমরা Chapter 18-এর [“বিভিন্ন প্রকারের ভ্যালুর জন্য অনুমতি দেয় এমন ট্রেট অবজেক্ট ব্যবহার করা”][using-trait-objects-that-allow-for-values-of-different-types]<!-- ignore --> বিভাগে এই আচরণের সাথে একটি ফাংশন কীভাবে লিখতে হয় তা নিয়ে আলোচনা করব।

### শর্তসাপেক্ষে মেথড প্রয়োগ করতে ট্রেট বাউন্ড ব্যবহার করা

জেনেরিক টাইপ প্যারামিটার ব্যবহার করে এমন একটি `impl` ব্লকের সাথে একটি ট্রেট বাউন্ড ব্যবহার করে, আমরা নির্দিষ্ট ট্রেট প্রয়োগ করে এমন টাইপগুলোর জন্য শর্তসাপেক্ষে মেথড প্রয়োগ করতে পারি। উদাহরণস্বরূপ, Listing 10-15-এর `Pair<T>` টাইপটি সবসময় `Pair<T>`-এর একটি নতুন ইনস্ট্যান্স রিটার্ন করার জন্য `new` ফাংশন প্রয়োগ করে (Chapter 5-এর [“মেথড সংজ্ঞায়িত করা”][methods]<!-- ignore --> বিভাগ থেকে মনে রাখবেন যে `Self` হল `impl` ব্লকের টাইপের জন্য একটি টাইপ অ্যালিয়াস, যা এই ক্ষেত্রে `Pair<T>`)। কিন্তু পরবর্তী `impl` ব্লকে, `Pair<T>` শুধুমাত্র তখনই `cmp_display` মেথড প্রয়োগ করে যদি এর ভিতরের টাইপ `T` `PartialOrd` ট্রেট প্রয়োগ করে যা তুলনা সক্ষম করে _এবং_ `Display` ট্রেট যা প্রিন্টিং সক্ষম করে।

<Listing number="10-15" file-name="src/lib.rs" caption="ট্রেট বাউন্ডের উপর নির্ভর করে একটি জেনেরিক টাইপের উপর শর্তসাপেক্ষে মেথড প্রয়োগ করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-15/src/lib.rs}}
```

</Listing>

আমরা এমন যেকোনো টাইপের জন্য শর্তসাপেক্ষে একটি ট্রেটও প্রয়োগ করতে পারি যা অন্য একটি ট্রেট প্রয়োগ করে। যেকোনো টাইপের উপর একটি ট্রেটের বাস্তবায়ন যা ট্রেট বাউন্ড পূরণ করে তাকে _ব্ল্যাঙ্কেট ইমপ্লিমেন্টেশন_ বলা হয় এবং রাস্ট স্ট্যান্ডার্ড লাইব্রেরিতে ব্যাপকভাবে ব্যবহৃত হয়। উদাহরণস্বরূপ, স্ট্যান্ডার্ড লাইব্রেরি `Display` ট্রেট প্রয়োগ করে এমন যেকোনো টাইপের উপর `ToString` ট্রেট প্রয়োগ করে। স্ট্যান্ডার্ড লাইব্রেরির `impl` ব্লকটি দেখতে এই কোডের মতো:

```rust,ignore
impl<T: Display> ToString for T {
    // --snip--
}
```

যেহেতু স্ট্যান্ডার্ড লাইব্রেরিতে এই ব্ল্যাঙ্কেট ইমপ্লিমেন্টেশন রয়েছে, তাই আমরা `Display` ট্রেট প্রয়োগ করে এমন যেকোনো টাইপের উপর `ToString` ট্রেট দ্বারা সংজ্ঞায়িত `to_string` মেথড কল করতে পারি। উদাহরণস্বরূপ, আমরা পূর্ণসংখ্যাগুলোকে তাদের সংশ্লিষ্ট `String` ভ্যালুতে রূপান্তর করতে পারি যেমনটি এইরকম, কারণ পূর্ণসংখ্যা `Display` প্রয়োগ করে:

```rust
let s = 3.to_string();
```

ব্ল্যাঙ্কেট ইমপ্লিমেন্টেশনগুলো ট্রেটের ডকুমেন্টেশনের "ইমপ্লিমেন্টর" বিভাগে প্রদর্শিত হয়।

ট্রেট এবং ট্রেট বাউন্ড আমাদের এমন কোড লিখতে দেয় যা ডুপ্লিকেশন কমাতে জেনেরিক টাইপ প্যারামিটার ব্যবহার করে কিন্তু কম্পাইলারেও নির্দিষ্ট করে যে আমরা চাই জেনেরিক টাইপের একটি বিশেষ আচরণ থাকুক। কম্পাইলার তখন ট্রেট বাউন্ডের তথ্য ব্যবহার করতে পারে যাতে আমাদের কোডের সাথে ব্যবহৃত সমস্ত কংক্রিট টাইপ সঠিক আচরণ প্রদান করে কিনা তা পরীক্ষা করতে পারে। ডাইনামিকভাবে টাইপ করা ভাষাগুলোতে, যদি আমরা এমন একটি টাইপের উপর একটি মেথড কল করি যা মেথডটিকে সংজ্ঞায়িত করে না, তাহলে আমরা রানটাইমে একটি এরর পাব। কিন্তু রাস্ট এই এররগুলোকে কম্পাইল টাইমে সরিয়ে দেয় তাই আমাদের কোড রান হওয়ার আগেই সমস্যাগুলো সমাধান করতে বাধ্য করা হয়। এছাড়াও, রানটাইমে আচরণের জন্য পরীক্ষা করে এমন কোড আমাদের লিখতে হয় না কারণ আমরা ইতিমধ্যেই কম্পাইল টাইমে পরীক্ষা করেছি। এটি জেনেরিকের নমনীয়তা ত্যাগ না করে কর্মক্ষমতা উন্নত করে।

[using-trait-objects-that-allow-for-values-of-different-types]: ch18-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types
[methods]: ch05-03-method-syntax.html#defining-methods
