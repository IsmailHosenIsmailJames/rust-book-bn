## টেস্ট কিভাবে চালানো হয় তা নিয়ন্ত্রণ করা

যেভাবে `cargo run` আপনার কোড কম্পাইল করে এবং তার ফলে তৈরি হওয়া বাইনারি চালায়, ঠিক সেভাবেই `cargo test` আপনার কোডকে টেস্ট মোডে (test mode) কম্পাইল করে এবং তার ফলে তৈরি হওয়া টেস্ট বাইনারি চালায়। `cargo test` দ্বারা উৎপাদিত বাইনারির ডিফল্ট আচরণ হলো সমস্ত টেস্টকে প্যারালালি (in parallel) চালানো এবং টেস্ট চলাকালীন জেনারেট হওয়া আউটপুট ক্যাপচার করা। এটি আউটপুটকে প্রদর্শিত হতে বাধা দেয় এবং টেস্টের ফলাফলের সাথে সম্পর্কিত আউটপুট পড়া সহজ করে তোলে। তবে, আপনি এই ডিফল্ট আচরণ পরিবর্তন করার জন্য কমান্ড লাইন অপশন নির্দিষ্ট করতে পারেন।

কিছু কমান্ড লাইন অপশন `cargo test`-এর জন্য এবং কিছু তার ফলে তৈরি হওয়া টেস্ট বাইনারির জন্য। এই দুই ধরনের আর্গুমেন্ট আলাদা করতে, আপনি প্রথমে `cargo test`-এর আর্গুমেন্টগুলো তালিকাভুক্ত করুন, তারপর `--` বিভাজক (separator) দিন এবং এরপর টেস্ট বাইনারির জন্য আর্গুমেন্টগুলো দিন। `cargo test --help` চালালে আপনি `cargo test`-এর সাথে ব্যবহারযোগ্য অপশনগুলো দেখতে পাবেন, এবং `cargo test -- --help` চালালে আপনি বিভাজকের পরে ব্যবহারযোগ্য অপশনগুলো দেখতে পাবেন। সেই অপশনগুলো [the rustc book][rustc]-এর ["Tests" section][tests]-এও নথিভুক্ত আছে।

[tests]: https://doc.rust-lang.org/rustc/tests/index.html
[rustc]: https://doc.rust-lang.org/rustc/index.html

### টেস্ট প্যারালালি বা পরপর চালানো

যখন আপনি একাধিক টেস্ট চালান, ডিফল্টভাবে সেগুলো থ্রেড (thread) ব্যবহার করে প্যারালালি চলে, যার মানে হলো সেগুলো দ্রুত শেষ হয় এবং আপনি তাড়াতাড়ি ফিডব্যাক পান। যেহেতু টেস্টগুলো একই সময়ে চলছে, আপনাকে নিশ্চিত করতে হবে যে আপনার টেস্টগুলো একে অপরের উপর বা কোনো শেয়ার্ড স্টেট (shared state), যেমন বর্তমান ওয়ার্কিং ডিরেক্টরি বা এনভায়রনমেন্ট ভেরিয়েবলের উপর নির্ভরশীল নয়।

উদাহরণস্বরূপ, ধরুন আপনার প্রতিটি টেস্ট এমন কিছু কোড চালায় যা ডিস্কে _test-output.txt_ নামে একটি ফাইল তৈরি করে এবং সেই ফাইলে কিছু ডেটা লেখে। তারপর প্রতিটি টেস্ট সেই ফাইলের ডেটা পড়ে এবং অ্যাসার্ট করে যে ফাইলটিতে একটি নির্দিষ্ট মান রয়েছে, যা প্রতিটি টেস্টে ভিন্ন। যেহেতু টেস্টগুলো একই সময়ে চলছে, একটি টেস্ট ফাইল লেখার এবং পড়ার মধ্যবর্তী সময়ে অন্য একটি টেস্ট ফাইলটি ওভাররাইট করে ফেলতে পারে। তখন দ্বিতীয় টেস্টটি ফেইল করবে, কোডটি ভুল হওয়ার কারণে নয়, বরং প্যারালালি চলার সময় টেস্টগুলো একে অপরের সাথে হস্তক্ষেপ করার কারণে। একটি সমাধান হলো নিশ্চিত করা যে প্রতিটি টেস্ট একটি ভিন্ন ফাইলে লেখে; আরেকটি সমাধান হলো টেস্টগুলো একবারে একটি করে চালানো।

আপনি যদি টেস্টগুলো প্যারালালি চালাতে না চান অথবা ব্যবহৃত থ্রেডের সংখ্যার উপর আরও সূক্ষ্ম নিয়ন্ত্রণ চান, তাহলে আপনি `--test-threads` ফ্ল্যাগ এবং আপনি যে সংখ্যক থ্রেড ব্যবহার করতে চান তা টেস্ট বাইনারিতে পাঠাতে পারেন। নিচের উদাহরণটি দেখুন:

```console
$ cargo test -- --test-threads=1
```

আমরা টেস্ট থ্রেডের সংখ্যা `1` সেট করেছি, যা প্রোগ্রামকে কোনো প্যারালালিসম ব্যবহার না করতে বলছে। একটি থ্রেড ব্যবহার করে টেস্ট চালালে প্যারালালি চালানোর চেয়ে বেশি সময় লাগবে, কিন্তু টেস্টগুলো যদি স্টেট শেয়ার করে তবে একে অপরের সাথে হস্তক্ষেপ করবে না।

### ফাংশন আউটপুট দেখানো

ডিফল্টভাবে, যদি একটি টেস্ট পাস করে, Rust-এর টেস্ট লাইব্রেরি স্ট্যান্ডার্ড আউটপুটে প্রিন্ট করা যেকোনো কিছু ক্যাপচার করে। উদাহরণস্বরূপ, যদি আমরা একটি টেস্টে `println!` কল করি এবং টেস্টটি পাস করে, আমরা টার্মিনালে `println!` আউটপুট দেখতে পাব না; আমরা শুধুমাত্র সেই লাইনটি দেখব যা নির্দেশ করে যে টেস্টটি পাস করেছে। যদি একটি টেস্ট ফেইল করে, আমরা স্ট্যান্ডার্ড আউটপুটে প্রিন্ট করা সবকিছু ফেইলার মেসেজের বাকি অংশের সাথে দেখতে পাব।

উদাহরণস্বরূপ, তালিকা ১১-১০-এ একটি সাধারণ ফাংশন রয়েছে যা তার প্যারামিটারের মান প্রিন্ট করে এবং ১০ রিটার্ন করে, সাথে একটি পাস করা টেস্ট এবং একটি ফেইল করা টেস্ট রয়েছে।

<Listing number="11-10" file-name="src/lib.rs" caption="`println!` কল করে এমন একটি ফাংশনের জন্য টেস্ট">

```rust,panics,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-10/src/lib.rs}}```

</Listing>

যখন আমরা `cargo test` দিয়ে এই টেস্টগুলো চালাই, আমরা নিম্নলিখিত আউটপুট দেখতে পাব:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-10/output.txt}}
```

লক্ষ্য করুন যে এই আউটপুটের কোথাও আমরা `I got the value 4` দেখতে পাচ্ছি না, যা পাস করা টেস্টটি চলার সময় প্রিন্ট হয়। সেই আউটপুট ক্যাপচার করা হয়েছে। ফেইল করা টেস্টের আউটপুট, `I got the value 8`, টেস্ট সারাংশ আউটপুটের সেই অংশে প্রদর্শিত হয়, যা টেস্ট ফেইলের কারণও দেখায়।

আমরা যদি পাস করা টেস্টগুলোর জন্যও প্রিন্ট করা মান দেখতে চাই, আমরা `--show-output` দিয়ে Rust-কে সফল টেস্টের আউটপুটও দেখাতে বলতে পারি:

```console
$ cargo test -- --show-output
```

যখন আমরা `--show-output` ফ্ল্যাগ দিয়ে তালিকা ১১-১০-এর টেস্টগুলো আবার চালাই, আমরা নিম্নলিখিত আউটপুট দেখতে পাই:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-01-show-output/output.txt}}
```

### নাম অনুসারে টেস্টের একটি অংশ চালানো

কখনও কখনও, একটি সম্পূর্ণ টেস্ট স্যুট (test suite) চালাতে অনেক সময় লাগতে পারে। আপনি যদি একটি নির্দিষ্ট এলাকার কোডে কাজ করেন, তবে আপনি শুধুমাত্র সেই কোড সম্পর্কিত টেস্টগুলো চালাতে চাইতে পারেন। আপনি `cargo test`-কে আর্গুমেন্ট হিসেবে যে টেস্ট বা টেস্টগুলোর নাম চালাতে চান তা পাস করে কোন টেস্টগুলো চালাবেন তা বেছে নিতে পারেন।

কিভাবে টেস্টের একটি অংশ চালাতে হয় তা দেখানোর জন্য, আমরা প্রথমে আমাদের `add_two` ফাংশনের জন্য তিনটি টেস্ট তৈরি করব, যেমনটি তালিকা ১১-১১-এ দেখানো হয়েছে, এবং সেগুলোর মধ্যে কোনটি চালাব তা বেছে নেব।

<Listing number="11-11" file-name="src/lib.rs" caption="তিনটি ভিন্ন নামের তিনটি টেস্ট">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-11/src/lib.rs}}
```

</Listing>

যদি আমরা কোনো আর্গুমেন্ট পাস না করে টেস্টগুলো চালাই, যেমনটি আমরা আগে দেখেছি, সমস্ত টেস্ট প্যারালালি চলবে:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-11/output.txt}}
```

#### একক টেস্ট চালানো

আমরা যেকোনো টেস্ট ফাংশনের নাম `cargo test`-কে পাস করে শুধুমাত্র সেই টেস্টটি চালাতে পারি:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-02-single-test/output.txt}}
```

শুধুমাত্র `one_hundred` নামের টেস্টটি চলেছে; অন্য দুটি টেস্ট সেই নামের সাথে মেলেনি। টেস্ট আউটপুট আমাদের জানায় যে আমাদের আরও টেস্ট ছিল যা চলেনি, শেষে `2 filtered out` প্রদর্শন করে।

আমরা এইভাবে একাধিক টেস্টের নাম নির্দিষ্ট করতে পারি না; `cargo test`-কে দেওয়া শুধুমাত্র প্রথম মানটি ব্যবহার করা হবে। কিন্তু একাধিক টেস্ট চালানোর একটি উপায় আছে।

#### একাধিক টেস্ট চালানোর জন্য ফিল্টারিং

আমরা একটি টেস্ট নামের অংশ নির্দিষ্ট করতে পারি, এবং যে কোনো টেস্টের নাম সেই মানের সাথে মিলবে তা চালানো হবে। উদাহরণস্বরূপ, যেহেতু আমাদের দুটি টেস্টের নামে `add` রয়েছে, আমরা `cargo test add` চালিয়ে সেই দুটি চালাতে পারি:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-03-multiple-tests/output.txt}}
```

এই কমান্ডটি `add` নামে থাকা সমস্ত টেস্ট চালিয়েছে এবং `one_hundred` নামের টেস্টটি ফিল্টার করে বাদ দিয়েছে। আরও লক্ষ্য করুন যে একটি টেস্ট যে মডিউলে উপস্থিত থাকে তা টেস্টের নামের অংশ হয়ে যায়, তাই আমরা মডিউলের নামের উপর ফিল্টার করে একটি মডিউলের সমস্ত টেস্ট চালাতে পারি।

### নির্দিষ্টভাবে অনুরোধ না করা পর্যন্ত কিছু টেস্ট উপেক্ষা করা

কখনও কখনও কিছু নির্দিষ্ট টেস্ট চালাতে অনেক সময় লাগতে পারে, তাই আপনি `cargo test`-এর বেশিরভাগ রানের সময় সেগুলোকে বাদ দিতে চাইতে পারেন। আপনি যে সমস্ত টেস্ট চালাতে চান সেগুলোকে আর্গুমেন্ট হিসেবে তালিকাভুক্ত করার পরিবর্তে, আপনি সময়সাপেক্ষ টেস্টগুলোকে `ignore` অ্যাট্রিবিউট ব্যবহার করে অ্যানোটেট করে বাদ দিতে পারেন, যেমনটি এখানে দেখানো হয়েছে:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/src/lib.rs:here}}
```

`#[test]`-এর পরে, আমরা যে টেস্টটি বাদ দিতে চাই তার জন্য `#[ignore]` লাইনটি যোগ করি। এখন যখন আমরা আমাদের টেস্টগুলো চালাই, `it_works` চলে, কিন্তু `expensive_test` চলে না:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-11-ignore-a-test/output.txt}}
```

`expensive_test` ফাংশনটি `ignored` হিসাবে তালিকাভুক্ত হয়েছে। যদি আমরা শুধুমাত্র উপেক্ষা করা টেস্টগুলো চালাতে চাই, আমরা `cargo test -- --ignored` ব্যবহার করতে পারি:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-04-running-ignored/output.txt}}
```

কোন টেস্টগুলো চলবে তা নিয়ন্ত্রণ করে, আপনি নিশ্চিত করতে পারেন যে আপনার `cargo test`-এর ফলাফল দ্রুত ফিরে আসবে। যখন আপনি এমন একটি পর্যায়ে থাকবেন যেখানে `ignored` টেস্টগুলোর ফলাফল পরীক্ষা করা অর্থপূর্ণ এবং আপনার কাছে ফলাফলের জন্য অপেক্ষা করার সময় আছে, তখন আপনি `cargo test -- --ignored` চালাতে পারেন। আপনি যদি সমস্ত টেস্ট চালাতে চান, সেগুলি উপেক্ষা করা হোক বা না হোক, আপনি `cargo test -- --include-ignored` চালাতে পারেন।