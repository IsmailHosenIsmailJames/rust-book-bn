# একটি গেসিং গেম প্রোগ্রামিং

আসুন একসাথে একটি হাতে-কলমে প্রকল্পের মাধ্যমে Rust এ প্রবেশ করি! এই অধ্যায়ে, আপনি একটি বাস্তব প্রোগ্রামে কিছু সাধারণ Rust ধারণা কিভাবে ব্যবহার করতে হয় তা জানতে পারবেন। আপনি `let`, `match`, methods, associated functions, external crates এবং আরও অনেক কিছু সম্পর্কে জানতে পারবেন! নিম্নলিখিত অধ্যায়গুলোতে, আমরা এই ধারণাগুলো আরও বিস্তারিতভাবে আলোচনা করব। এই অধ্যায়ে, আপনি শুধু মৌলিক বিষয়গুলো অনুশীলন করবেন।

আমরা একটি ক্লাসিক শিক্ষানবিস প্রোগ্রামিং সমস্যা বাস্তবায়ন করব: একটি গেসিং গেম। এটি কিভাবে কাজ করে: প্রোগ্রামটি 1 থেকে 100 এর মধ্যে একটি র্যান্ডম পূর্ণসংখ্যা তৈরি করবে। তারপর এটি খেলোয়াড়কে একটি অনুমান প্রবেশ করতে বলবে। অনুমান প্রবেশ করার পরে, প্রোগ্রামটি জানাবে যে অনুমানটি খুব কম নাকি খুব বেশি। যদি অনুমানটি সঠিক হয়, তবে গেমটি একটি অভিনন্দন বার্তা প্রিন্ট করবে এবং প্রস্থান করবে।

## নতুন একটি প্রকল্প স্থাপন করা

নতুন একটি প্রকল্প স্থাপন করতে, আপনি অধ্যায় 1 এ তৈরি করা _projects_ ডিরেক্টরিতে যান এবং Cargo ব্যবহার করে একটি নতুন প্রকল্প তৈরি করুন, যেমন:

```console
$ cargo new guessing_game
$ cd guessing_game
```

প্রথম কমান্ড, `cargo new`, প্রকল্পের নাম (`guessing_game`) প্রথম আর্গুমেন্ট হিসেবে গ্রহণ করে। দ্বিতীয় কমান্ডটি নতুন প্রকল্পের ডিরেক্টরিতে পরিবর্তন করে।

তৈরি হওয়া _Cargo.toml_ ফাইলটি দেখুন:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial
rm -rf no-listing-01-cargo-new
cargo new no-listing-01-cargo-new --name guessing_game
cd no-listing-01-cargo-new
cargo run > output.txt 2>&1
cd ../../..
-->

<span class="filename">Filename: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/Cargo.toml}}
```

আপনি অধ্যায় 1 এ দেখেছেন, `cargo new` আপনার জন্য একটি "Hello, world!" প্রোগ্রাম তৈরি করে। _src/main.rs_ ফাইলটি দেখুন:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/src/main.rs}}
```

এখন আসুন এই "Hello, world!" প্রোগ্রামটি কম্পাইল করি এবং `cargo run` কমান্ড ব্যবহার করে একই ধাপে রান করি:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-01-cargo-new/output.txt}}
```

`run` কমান্ডটি কাজে লাগে যখন আপনি কোনও প্রকল্পের উপর দ্রুত কাজ করতে চান, যেমন আমরা এই গেমটিতে করব, প্রতিটি ধাপ দ্রুত পরীক্ষা করে পরবর্তী ধাপে যাওয়ার আগে।

_src/main.rs_ ফাইলটি পুনরায় খুলুন। আপনি এই ফাইলে সমস্ত কোড লিখবেন।

## একটি অনুমান প্রক্রিয়াকরণ

গেসিং গেম প্রোগ্রামের প্রথম অংশটি ব্যবহারকারীর ইনপুট চাইবে, সেই ইনপুটটি প্রক্রিয়া করবে এবং ইনপুটটি প্রত্যাশিত ফর্মে আছে কিনা তা পরীক্ষা করবে। শুরু করতে, আমরা খেলোয়াড়কে একটি অনুমান ইনপুট করার অনুমতি দেব। Listing 2-1 এর কোডটি _src/main.rs_ এ প্রবেশ করান।

<Listing number="2-1" file-name="src/main.rs" caption="ব্যবহারকারীর কাছ থেকে একটি অনুমান নেওয়ার এবং তা প্রিন্ট করার কোড">

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:all}}
```

</Listing>

এই কোডে অনেক তথ্য রয়েছে, তাই আসুন আমরা এটি লাইন বাই লাইন দেখি। ব্যবহারকারীর ইনপুট পেতে এবং তারপর ফলাফল আউটপুট হিসেবে প্রিন্ট করতে, আমাদের `io` ইনপুট/আউটপুট লাইব্রেরিটিকে স্কোপে আনতে হবে। `io` লাইব্রেরিটি স্ট্যান্ডার্ড লাইব্রেরি থেকে আসে, যা `std` নামে পরিচিত:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:io}}
```

ডিফল্টরূপে, Rust এর স্ট্যান্ডার্ড লাইব্রেরিতে কিছু আইটেম সংজ্ঞায়িত করা আছে যা প্রতিটি প্রোগ্রামের স্কোপে নিয়ে আসে। এই সেটটিকে _prelude_ বলা হয় এবং আপনি [স্ট্যান্ডার্ড লাইব্রেরি ডকুমেন্টেশনে][prelude] এর সবকিছু দেখতে পারেন।

যদি আপনি যে টাইপটি ব্যবহার করতে চান তা prelude-তে না থাকে, তবে আপনাকে `use` স্টেটমেন্টের মাধ্যমে সেই টাইপটিকে স্পষ্টভাবে স্কোপে আনতে হবে। `std::io` লাইব্রেরি ব্যবহার করে আপনি ব্যবহারকারীর ইনপুট গ্রহণ করার ক্ষমতা সহ অনেকগুলো দরকারি বৈশিষ্ট্য পাবেন।

আপনি অধ্যায় 1 এ দেখেছেন, `main` ফাংশনটি প্রোগ্রামের এন্ট্রি পয়েন্ট:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:main}}
```

`fn` সিনট্যাক্স একটি নতুন ফাংশন ঘোষণা করে; প্যারেনথেসিস, `()`, নির্দেশ করে যে কোনও প্যারামিটার নেই; এবং কার্লি ব্র্যাকেট, `{`, ফাংশনের বডি শুরু করে।

আপনি অধ্যায় 1 এ আরও শিখেছেন, `println!` একটি ম্যাক্রো যা স্ক্রিনে একটি স্ট্রিং প্রিন্ট করে:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print}}
```

এই কোডটি একটি প্রম্পট প্রিন্ট করছে যা গেমটি কী তা বলছে এবং ব্যবহারকারীর কাছ থেকে ইনপুট চাইছে।

### ভেরিয়েবল দিয়ে মান সংরক্ষণ করা

পরবর্তী, আমরা ব্যবহারকারীর ইনপুট সংরক্ষণ করার জন্য একটি _variable_ তৈরি করব, যেমন:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:string}}
```

এখন প্রোগ্রামটি আকর্ষণীয় হচ্ছে! এই ছোট লাইনে অনেক কিছু ঘটছে। আমরা ভেরিয়েবল তৈরি করতে `let` স্টেটমেন্ট ব্যবহার করি। এখানে আরও একটি উদাহরণ:

```rust,ignore
let apples = 5;
```

এই লাইনটি `apples` নামের একটি নতুন ভেরিয়েবল তৈরি করে এবং এটিকে 5 মানের সাথে বাইন্ড করে। Rust এ, ভেরিয়েবলগুলি ডিফল্টরূপে অপরিবর্তনীয়, যার মানে একবার আমরা ভেরিয়েবলটিকে একটি মান দিলে, সেই মান পরিবর্তন হবে না। আমরা অধ্যায় 3 এর [“Variables and Mutability”][variables-and-mutability]<!-- ignore --> বিভাগে এই ধারণাটি বিস্তারিতভাবে আলোচনা করব। একটি ভেরিয়েবলকে পরিবর্তনযোগ্য করতে, আমরা ভেরিয়েবলের নামের আগে `mut` যোগ করি:

```rust,ignore
let apples = 5; // অপরিবর্তনীয়
let mut bananas = 5; // পরিবর্তনযোগ্য
```

> দ্রষ্টব্য: `//` সিনট্যাক্স একটি মন্তব্য শুরু করে যা লাইনের শেষ পর্যন্ত চলতে থাকে। Rust মন্তব্যের ভিতরের সবকিছু উপেক্ষা করে। আমরা [অধ্যায় 3][comments]<!-- ignore --> এ মন্তব্য নিয়ে আরও বিস্তারিত আলোচনা করব।

গেসিং গেম প্রোগ্রামে ফিরে গেলে, আপনি এখন জানেন যে `let mut guess` `guess` নামের একটি পরিবর্তনযোগ্য ভেরিয়েবল তৈরি করবে। সমান চিহ্ন (`=`) Rust কে বলে যে আমরা এখন ভেরিয়েবলের সাথে কিছু বাইন্ড করতে চাই। সমান চিহ্নের ডানদিকে হল সেই মান যা `guess` এর সাথে বাইন্ড করা হয়েছে, যা `String::new` কল করার ফলাফল, একটি ফাংশন যা `String` এর একটি নতুন উদাহরণ রিটার্ন করে। [`String`][string]<!-- ignore --> হল স্ট্যান্ডার্ড লাইব্রেরি দ্বারা প্রদত্ত একটি স্ট্রিং টাইপ যা একটি প্রসারণযোগ্য, UTF-8 এনকোডেড টেক্সট।

`::new` লাইনের `::` সিনট্যাক্স নির্দেশ করে যে `new` হল `String` টাইপের একটি associated ফাংশন। একটি _associated ফাংশন_ হল এমন একটি ফাংশন যা একটি টাইপের উপর প্রয়োগ করা হয়, এই ক্ষেত্রে `String`। এই `new` ফাংশনটি একটি নতুন, খালি স্ট্রিং তৈরি করে। আপনি অনেক টাইপে একটি `new` ফাংশন পাবেন কারণ এটি একটি ফাংশনের জন্য একটি সাধারণ নাম যা কোনো ধরনের নতুন মান তৈরি করে।

পুরোপুরিভাবে বললে, `let mut guess = String::new();` লাইনটি একটি পরিবর্তনযোগ্য ভেরিয়েবল তৈরি করেছে যা বর্তমানে একটি `String` এর নতুন, খালি উদাহরণের সাথে বাইন্ড করা হয়েছে। বাহ!

### ব্যবহারকারীর ইনপুট গ্রহণ

মনে রাখবেন যে আমরা প্রোগ্রামের প্রথম লাইনে `use std::io;` দিয়ে স্ট্যান্ডার্ড লাইব্রেরি থেকে ইনপুট/আউটপুট কার্যকারিতা অন্তর্ভুক্ত করেছি। এখন আমরা `io` মডিউল থেকে `stdin` ফাংশনটি কল করব, যা আমাদের ব্যবহারকারীর ইনপুট পরিচালনা করতে দেবে:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:read}}
```

যদি আমরা প্রোগ্রামের শুরুতে `use std::io;` দিয়ে `io` লাইব্রেরি ইম্পোর্ট না করতাম, তবে আমরা এখনও `std::io::stdin` হিসাবে এই ফাংশন কল লিখে ফাংশনটি ব্যবহার করতে পারতাম। `stdin` ফাংশনটি [`std::io::Stdin`][iostdin]<!-- ignore --> এর একটি উদাহরণ রিটার্ন করে, যা একটি টাইপ যা আপনার টার্মিনালের জন্য স্ট্যান্ডার্ড ইনপুটের একটি হ্যান্ডেল উপস্থাপন করে।

এরপর, `read_line` মেথডটিকে স্ট্যান্ডার্ড ইনপুট হ্যান্ডেলে কল করে ব্যবহারকারীর কাছ থেকে ইনপুট নেওয়ার জন্য `read_line(&mut guess)` লাইনটি ব্যবহার করা হয়েছে। আমরা `read_line` এর আর্গুমেন্ট হিসেবে `&mut guess` পাস করছি, যাতে এটি ব্যবহারকারীর ইনপুট কোন স্ট্রিং-এ স্টোর করবে তা জানতে পারে। `read_line` এর পুরো কাজ হল স্ট্যান্ডার্ড ইনপুটে ব্যবহারকারী যা কিছু টাইপ করে তা নেওয়া এবং একটি স্ট্রিং-এ যুক্ত করা (এর বিষয়বস্তু না মুছে), তাই আমরা সেই স্ট্রিংটিকে আর্গুমেন্ট হিসেবে পাস করি। স্ট্রিং আর্গুমেন্টটিকে পরিবর্তনযোগ্য হতে হবে যাতে মেথডটি স্ট্রিংয়ের বিষয়বস্তু পরিবর্তন করতে পারে।

`&` নির্দেশ করে যে এই আর্গুমেন্টটি একটি _রেফারেন্স_, যা আপনাকে আপনার কোডের একাধিক অংশকে মেমরিতে একাধিকবার ডেটা কপি করার প্রয়োজন ছাড়াই ডেটার একটি অংশে অ্যাক্সেস করতে দেওয়ার একটি উপায়। রেফারেন্স একটি জটিল বৈশিষ্ট্য, এবং Rust এর প্রধান সুবিধাগুলির মধ্যে একটি হল রেফারেন্স ব্যবহার করা কতটা নিরাপদ এবং সহজ। এই প্রোগ্রামটি শেষ করার জন্য আপনাকে এই বিশদগুলির অনেক কিছু জানতে হবে না। আপাতত, আপনার যা জানা দরকার তা হল, ভেরিয়েবলের মতো, রেফারেন্সগুলি ডিফল্টরূপে অপরিবর্তনীয়। সুতরাং, এটিকে পরিবর্তনযোগ্য করতে আপনাকে `&guess` এর পরিবর্তে `&mut guess` লিখতে হবে। (অধ্যায় 4 রেফারেন্স আরও পুঙ্খানুপুঙ্খভাবে ব্যাখ্যা করবে।)

<!-- Old heading. Do not remove or links may break. -->

<a id="handling-potential-failure-with-the-result-type"></a>

### `Result` টাইপ দিয়ে সম্ভাব্য ব্যর্থতা হ্যান্ডেল করা

আমরা এখনও এই কোডের লাইনে কাজ করছি। আমরা এখন পাঠ্যের তৃতীয় লাইন নিয়ে আলোচনা করছি, তবে মনে রাখবেন যে এটি এখনও কোডের একটি একক লজিক্যাল লাইনের অংশ। পরবর্তী অংশটি হল এই মেথড:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:expect}}
```

আমরা এই কোডটি এভাবে লিখতে পারতাম:

```rust,ignore
io::stdin().read_line(&mut guess).expect("Failed to read line");
```

তবে, একটি দীর্ঘ লাইন পড়া কঠিন, তাই এটিকে ভাগ করাই ভালো। যখন আপনি `.method_name()` সিনট্যাক্স দিয়ে একটি মেথড কল করেন, তখন দীর্ঘ লাইন ভাঙতে নতুন লাইন এবং অন্যান্য হোয়াইটস্পেস ব্যবহার করা বুদ্ধিমানের কাজ। এখন আসুন আলোচনা করি এই লাইনটি কী করে।

আগে যেমন উল্লেখ করা হয়েছে, `read_line` ব্যবহারকারী যা প্রবেশ করে তা স্ট্রিং-এ রাখে এবং এটি একটি `Result` মানও রিটার্ন করে। [`Result`][result]<!-- ignore --> হল একটি [_enumeration_][enums]<!-- ignore -->, যাকে প্রায়শই _enum_ বলা হয়, যা একটি টাইপ যা একাধিক সম্ভাব্য অবস্থায় থাকতে পারে। আমরা প্রতিটি সম্ভাব্য অবস্থাকে একটি _ভেরিয়েন্ট_ বলি।

[অধ্যায় 6][enums]<!-- ignore --> এ enums নিয়ে আরও বিস্তারিতভাবে আলোচনা করা হবে। এই `Result` টাইপগুলোর উদ্দেশ্য হল ত্রুটি-হ্যান্ডলিং তথ্য এনকোড করা।

`Result` এর ভেরিয়েন্টগুলি হল `Ok` এবং `Err`। `Ok` ভেরিয়েন্ট নির্দেশ করে যে অপারেশনটি সফল হয়েছে এবং এতে সফলভাবে জেনারেট করা মান রয়েছে। `Err` ভেরিয়েন্ট মানে অপারেশনটি ব্যর্থ হয়েছে এবং এতে অপারেশনটি কীভাবে বা কেন ব্যর্থ হয়েছে সে সম্পর্কে তথ্য রয়েছে।

`Result` টাইপের মান, যেকোনো টাইপের মানের মতো, তাদের উপর সংজ্ঞায়িত মেথড রয়েছে। `Result` এর একটি ইনস্ট্যান্সের একটি [`expect` মেথড][expect]<!-- ignore --> আছে যা আপনি কল করতে পারেন। যদি `Result` এর এই উদাহরণটি একটি `Err` মান হয়, তাহলে `expect` প্রোগ্রামটিকে ক্র্যাশ করিয়ে দেবে এবং `expect`-এর আর্গুমেন্ট হিসেবে আপনি যে বার্তাটি পাস করেছেন সেটি দেখাবে। যদি `read_line` মেথডটি একটি `Err` রিটার্ন করে, তবে সম্ভবত এটি আন্ডারলাইং অপারেটিং সিস্টেম থেকে আসা একটি ত্রুটির কারণে হবে। যদি `Result` এর এই উদাহরণটি একটি `Ok` মান হয়, তাহলে `expect` `Ok` ধারণ করা রিটার্ন মানটি নেবে এবং শুধুমাত্র সেই মানটি আপনাকে ফেরত দেবে যাতে আপনি এটি ব্যবহার করতে পারেন। এই ক্ষেত্রে, সেই মানটি হল ব্যবহারকারীর ইনপুটের বাইটের সংখ্যা।

যদি আপনি `expect` কল না করেন, তাহলে প্রোগ্রামটি কম্পাইল হবে, কিন্তু আপনি একটি সতর্কতা পাবেন:

```console
{{#include ../listings/ch02-guessing-game-tutorial/no-listing-02-without-expect/output.txt}}
```

Rust সতর্ক করে যে আপনি `read_line` থেকে রিটার্ন করা `Result` মানটি ব্যবহার করেননি, যা নির্দেশ করে যে প্রোগ্রামটি একটি সম্ভাব্য ত্রুটি হ্যান্ডেল করেনি।

সতর্কতা বন্ধ করার সঠিক উপায় হল আসলে ত্রুটি-হ্যান্ডলিং কোড লেখা, কিন্তু আমাদের ক্ষেত্রে যখন কোনও সমস্যা হয় তখন আমরা এই প্রোগ্রামটিকে ক্র্যাশ করাতে চাই, তাই আমরা `expect` ব্যবহার করতে পারি। আপনি [অধ্যায় 9][recover]<!-- ignore --> এ ত্রুটি থেকে পুনরুদ্ধারের বিষয়ে শিখবেন।

### `println!` প্লেসহোল্ডার দিয়ে মান প্রিন্ট করা

বন্ধনী বন্ধ করা কার্লি ব্র্যাকেট ছাড়াও, কোডে আলোচনা করার জন্য আরও একটি লাইন বাকি আছে:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-01/src/main.rs:print_guess}}
```

এই লাইনটি সেই স্ট্রিংটি প্রিন্ট করে যাতে এখন ব্যবহারকারীর ইনপুট রয়েছে। কার্লি ব্র্যাকেটের `{}` সেটটি একটি প্লেসহোল্ডার: `{}` কে ছোট কাঁকড়ার দাঁড়ার মতো মনে করুন যা একটি মান ধরে রাখে। যখন একটি ভেরিয়েবলের মান প্রিন্ট করা হয়, তখন ভেরিয়েবলের নামটি কার্লি ব্র্যাকেটের ভিতরে যেতে পারে। যখন একটি এক্সপ্রেশন মূল্যায়ন করার ফলাফল প্রিন্ট করা হয়, তখন ফরম্যাট স্ট্রিং-এ খালি কার্লি ব্র্যাকেট রাখুন, তারপর ফরম্যাট স্ট্রিং-এর পরে কমা-সেপারেটেড এক্সপ্রেশনের একটি তালিকা দিন, যাতে প্রতিটি খালি কার্লি ব্র্যাকেট প্লেসহোল্ডারে একই ক্রমে প্রিন্ট করা যায়। একটি ভেরিয়েবল এবং একটি এক্সপ্রেশনের ফলাফল `println!` এ প্রিন্ট করলে এমন দেখাবে:

```rust
let x = 5;
let y = 10;

println!("x = {x} এবং y + 2 = {}", y + 2);
```

এই কোডটি প্রিন্ট করবে `x = 5 এবং y + 2 = 12`।

### প্রথম অংশের পরীক্ষা

আসুন গেসিং গেমের প্রথম অংশ পরীক্ষা করি। `cargo run` ব্যবহার করে এটি রান করুন:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-01/
cargo clean
cargo run
input 6 -->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 6.44s
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
```

এই পর্যায়ে, গেমের প্রথম অংশটি সম্পন্ন হয়েছে: আমরা কীবোর্ড থেকে ইনপুট নিচ্ছি এবং তারপর তা প্রিন্ট করছি।

## একটি গোপন সংখ্যা তৈরি করা

পরবর্তী, আমাদের একটি গোপন সংখ্যা তৈরি করতে হবে যা ব্যবহারকারী অনুমান করার চেষ্টা করবে। গোপন সংখ্যাটি প্রতিবার আলাদা হওয়া উচিত যাতে গেমটি একাধিকবার খেলতে মজাদার হয়। আমরা 1 থেকে 100 এর মধ্যে একটি র্যান্ডম সংখ্যা ব্যবহার করব যাতে গেমটি খুব কঠিন না হয়। Rust এ এখনও স্ট্যান্ডার্ড লাইব্রেরিতে র্যান্ডম সংখ্যা কার্যকারিতা অন্তর্ভুক্ত করা হয়নি। তবে, Rust টিম উক্ত কার্যকারিতা সহ একটি [`rand` crate][randcrate] সরবরাহ করে।

### আরও কার্যকারিতা পেতে একটি Crate ব্যবহার করা

মনে রাখবেন যে একটি crate হল Rust সোর্স কোড ফাইলের একটি সংগ্রহ। আমরা যে প্রকল্পটি তৈরি করছি সেটি একটি _বাইনারি crate_, যা একটি এক্সিকিউটেবল। `rand` crate হল একটি _লাইব্রেরি crate_, যাতে এমন কোড রয়েছে যা অন্যান্য প্রোগ্রামে ব্যবহারের উদ্দেশ্যে তৈরি করা হয়েছে এবং এটি নিজে থেকে এক্সিকিউট করা যায় না।

বাহ্যিক crates এর Cargo এর সমন্বয়ই Cargo এর প্রধান বৈশিষ্ট্য। `rand` ব্যবহার করে এমন কোড লেখার আগে, আমাদের `rand` crate কে নির্ভরতা হিসেবে অন্তর্ভুক্ত করতে _Cargo.toml_ ফাইলটি পরিবর্তন করতে হবে। এখন সেই ফাইলটি খুলুন এবং Cargo আপনার জন্য তৈরি করা `[dependencies]` বিভাগ শিরোনামের নীচে নিম্নলিখিত লাইনটি যোগ করুন। এখানে আমরা যেভাবে দিয়েছি ঠিক সেভাবে `rand` উল্লেখ করতে ভুলবেন না, এই সংস্করণ নম্বর সহ, অথবা এই টিউটোরিয়ালের কোড উদাহরণগুলি কাজ নাও করতে পারে:

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch07-04-bringing-paths-into-scope-with-the-use-keyword.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">Filename: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:8:}}
```

_Cargo.toml_ ফাইলে, একটি হেডারের পরে যা কিছু থাকে তা সেই বিভাগের অংশ যা অন্য একটি বিভাগ শুরু না হওয়া পর্যন্ত চলতে থাকে। `[dependencies]` এ আপনি Cargo কে বলেন যে আপনার প্রকল্পের কোন বাহ্যিক crates এর উপর নির্ভরতা রয়েছে এবং সেই crates এর কোন সংস্করণগুলি আপনার প্রয়োজন। এই ক্ষেত্রে, আমরা `rand` crate কে সিমান্টিক সংস্করণ স্পেসিফায়ার `0.8.5` দিয়ে উল্লেখ করি। Cargo [Semantic Versioning][semver]<!-- ignore --> (কখনও কখনও _SemVer_ বলা হয়) বোঝে, যা সংস্করণ নম্বর লেখার একটি মান। স্পেসিফায়ার `0.8.5` আসলে `^0.8.5` এর সংক্ষিপ্ত রূপ, যার মানে 0.8.5 এর থেকে বেশি বা সমান কিন্তু 0.9.0 এর কম যেকোনো সংস্করণ।

Cargo এই সংস্করণগুলিকে 0.8.5 সংস্করণের সাথে সামঞ্জস্যপূর্ণ পাবলিক API আছে বলে মনে করে এবং এই স্পেসিফিকেশন নিশ্চিত করে যে আপনি সর্বশেষ প্যাচ রিলিজ পাবেন যা এখনও এই অধ্যায়ের কোডের সাথে কম্পাইল হবে। 0.9.0 বা তার বেশি সংস্করণের API গুলি নিম্নলিখিত উদাহরণগুলির মতো একই হওয়ার গ্যারান্টি নেই।

এখন, কোডের কোনো পরিবর্তন না করে, আসুন Listing 2-2 এ দেখানো হিসাবে প্রকল্পটি তৈরি করি।

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
rm Cargo.lock
cargo clean
cargo build -->

<Listing number="2-2" caption="নির্ভরতা হিসাবে rand crate যোগ করার পরে `cargo build` চালানোর আউটপুট">

```console
$ cargo build
    Updating crates.io index
     Locking 16 packages to latest compatible versions
      Adding wasi v0.11.0+wasi-snapshot-preview1 (latest: v0.13.3+wasi-0.2.2)
      Adding zerocopy v0.7.35 (latest: v0.8.9)
      Adding zerocopy-derive v0.7.35 (latest: v0.8.9)
  Downloaded syn v2.0.87
  Downloaded 1 crate (278.1 KB) in 0.16s
   Compiling proc-macro2 v1.0.89
   Compiling unicode-ident v1.0.13
   Compiling libc v0.2.161
   Compiling cfg-if v1.0.0
   Compiling byteorder v1.5.0
   Compiling getrandom v0.2.15
   Compiling rand_core v0.6.4
   Compiling quote v1.0.37
   Compiling syn v2.0.87
   Compiling zerocopy-derive v0.7.35
   Compiling zerocopy v0.7.35
   Compiling ppv-lite86 v0.2.20
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.5
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 3.69s
```

</Listing>

আপনি ভিন্ন সংস্করণ নম্বর দেখতে পারেন (তবে সেগুলি SemVer এর জন্য কোডের সাথে সামঞ্জস্যপূর্ণ হবে!) এবং বিভিন্ন লাইনও দেখতে পারেন (অপারেটিং সিস্টেমের উপর নির্ভর করে), এবং লাইনগুলি ভিন্ন ক্রমে থাকতে পারে।

যখন আমরা একটি বাহ্যিক নির্ভরতা অন্তর্ভুক্ত করি, Cargo _registry_ থেকে সেই নির্ভরতার প্রয়োজনীয় সবকিছু সর্বশেষ সংস্করণ নিয়ে আসে, যা [Crates.io][cratesio] থেকে ডেটার একটি অনুলিপি। Crates.io হল সেই জায়গা যেখানে Rust ইকোসিস্টেমের লোকেরা তাদের ওপেন সোর্স Rust প্রজেক্টগুলি অন্যদের ব্যবহারের জন্য পোস্ট করে।

রেজিস্ট্রি আপডেট করার পরে, Cargo `[dependencies]` বিভাগটি পরীক্ষা করে এবং তালিকাভুক্ত যেকোনো crates ডাউনলোড করে যা ইতিমধ্যে ডাউনলোড করা হয়নি। এই ক্ষেত্রে, যদিও আমরা শুধুমাত্র `rand` কে নির্ভরতা হিসাবে তালিকাভুক্ত করেছি, Cargo `rand` কাজ করার জন্য নির্ভর করে এমন অন্যান্য crates ও নিয়ে নেয়। crates ডাউনলোড করার পরে, Rust সেগুলোকে কম্পাইল করে এবং তারপর নির্ভরতা উপলব্ধ করে প্রকল্পের কম্পাইল করে।

যদি আপনি কোনো পরিবর্তন না করে সাথে সাথে আবার `cargo build` চালান, তাহলে আপনি `Finished` লাইন ছাড়া আর কোনো আউটপুট পাবেন না। Cargo জানে যে এটি ইতিমধ্যে নির্ভরতা ডাউনলোড এবং কম্পাইল করেছে, এবং আপনি আপনার _Cargo.toml_ ফাইলে সেগুলি সম্পর্কে কিছুই পরিবর্তন করেননি। Cargo এও জানে যে আপনি আপনার কোড সম্পর্কে কিছুই পরিবর্তন করেননি, তাই এটি সেটিও পুনরায় কম্পাইল করে না। করার কিছুই না থাকায়, এটি কেবল প্রস্থান করে।

যদি আপনি _src/main.rs_ ফাইলটি খোলেন, একটি সামান্য পরিবর্তন করেন, এবং তারপর এটি সংরক্ষণ করে আবার বিল্ড করেন, তাহলে আপনি শুধুমাত্র দুটি লাইনের আউটপুট দেখতে পাবেন:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
touch src/main.rs
cargo build -->

```console
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
```

এই লাইনগুলি দেখায় যে Cargo শুধুমাত্র _src/main.rs_ ফাইলে আপনার ছোট পরিবর্তনের সাথে বিল্ড আপডেট করে। আপনার নির্ভরতা পরিবর্তন হয়নি, তাই Cargo জানে যে এটি সেগুলোর জন্য যা ডাউনলোড এবং কম্পাইল করেছে তা পুনরায় ব্যবহার করতে পারে।

#### _Cargo.lock_ ফাইল দিয়ে পুনরুৎপাদনযোগ্য বিল্ড নিশ্চিত করা

Cargo এর একটি প্রক্রিয়া রয়েছে যা নিশ্চিত করে যে আপনি বা অন্য কেউ আপনার কোড তৈরি করার সময় প্রতিবার একই আর্টিফ্যাক্ট পুনর্নির্মাণ করতে পারেন: আপনি অন্যথায় নির্দেশ না করা পর্যন্ত Cargo শুধুমাত্র আপনার নির্দিষ্ট করা নির্ভরতার সংস্করণগুলি ব্যবহার করবে। উদাহরণস্বরূপ, ধরুন যে আগামী সপ্তাহে `rand` crate এর 0.8.6 সংস্করণ প্রকাশিত হয়েছে, এবং সেই সংস্করণে একটি গুরুত্বপূর্ণ বাগ ফিক্স রয়েছে, তবে এতে এমন একটি রিগ্রেশনও রয়েছে যা আপনার কোড ভেঙে দেবে। এটি হ্যান্ডেল করার জন্য, Rust প্রথমবার `cargo build` চালানোর সময় _Cargo.lock_ ফাইল তৈরি করে, তাই এখন আমাদের কাছে _guessing_game_ ডিরেক্টরিতে এটি রয়েছে।

আপনি যখন প্রথমবার একটি প্রকল্প তৈরি করেন, Cargo নির্ভরতার সমস্ত সংস্করণ খুঁজে বের করে যা মানদণ্ডের সাথে খাপ খায় এবং তারপরে সেগুলিকে _Cargo.lock_ ফাইলে লিখে দেয়। ভবিষ্যতে আপনি যখন আপনার প্রকল্প তৈরি করবেন, Cargo দেখবে যে _Cargo.lock_ ফাইলটি বিদ্যমান এবং আবার সংস্করণগুলি খুঁজে বের করার সমস্ত কাজ করার পরিবর্তে সেখানে নির্দিষ্ট করা সংস্করণগুলি ব্যবহার করবে। এটি আপনাকে স্বয়ংক্রিয়ভাবে একটি পুনরুৎপাদনযোগ্য বিল্ড করতে দেয়। অন্য কথায়, _Cargo.lock_ ফাইলের জন্য আপনার প্রকল্পটি 0.8.5 এ থাকবে যতক্ষণ না আপনি স্পষ্টভাবে আপগ্রেড করেন। যেহেতু _Cargo.lock_ ফাইলটি পুনরুৎপাদনযোগ্য বিল্ডের জন্য গুরুত্বপূর্ণ, তাই এটি প্রায়শই আপনার প্রকল্পের বাকি কোডের সাথে সোর্স কন্ট্রোলে চেক করা হয়।

#### নতুন সংস্করণ পেতে একটি Crate আপডেট করা

আপনি যখন একটি crate আপডেট করতে চান, Cargo `update` কমান্ড প্রদান করে, যা _Cargo.lock_ ফাইলটিকে উপেক্ষা করবে এবং _Cargo.toml_ এ আপনার স্পেসিফিকেশনগুলির সাথে খাপ খায় এমন সমস্ত সর্বশেষ সংস্করণ খুঁজে বের করবে। Cargo তারপর সেই সংস্করণগুলিকে _Cargo.lock_ ফাইলে লিখবে। এই ক্ষেত্রে, Cargo শুধুমাত্র 0.8.5 এর থেকে বেশি এবং 0.9.0 এর কম সংস্করণগুলি সন্ধান করবে। যদি `rand` crate দুটি নতুন সংস্করণ 0.8.6 এবং 0.9.0 প্রকাশ করে থাকে, তাহলে আপনি যদি `cargo update` চালান তবে নিম্নলিখিতটি দেখতে পাবেন:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-02/
cargo update
assuming there is a new 0.8.x version of rand; otherwise use another update
as a guide to creating the hypothetical output shown here -->

```console
$ cargo update
    Updating crates.io index
    Updating rand v0.8.5 -> v0.8.6
```

Cargo 0.9.0 রিলিজটিকে উপেক্ষা করে। এই সময়ে, আপনি আপনার _Cargo.lock_ ফাইলে একটি পরিবর্তনও লক্ষ্য করবেন যাতে উল্লেখ করা থাকবে যে আপনি এখন `rand` crate এর 0.8.6 সংস্করণ ব্যবহার করছেন। `rand` সংস্করণ 0.9.0 বা 0.9._x_ সিরিজের কোনো সংস্করণ ব্যবহার করতে, আপনাকে _Cargo.toml_ ফাইলটিকে পরিবর্তন করে এইরকম করতে হবে:
আপনি যখন পরবর্তীতে `cargo build` রান করবেন, Cargo উপলব্ধ crates এর রেজিস্ট্রি আপডেট করবে এবং আপনার নির্দিষ্ট করা নতুন সংস্করণ অনুযায়ী আপনার `rand` এর প্রয়োজনীয়তা পুনরায় মূল্যায়ন করবে।

[Cargo][doccargo]<!-- ignore --> এবং [এর ইকোসিস্টেম][doccratesio]<!-- ignore --> সম্পর্কে আরও অনেক কিছু বলার আছে, যা আমরা অধ্যায় 14 এ আলোচনা করব, তবে আপাতত, আপনার যা জানা দরকার তা এইটুকুই। Cargo লাইব্রেরিগুলি পুনরায় ব্যবহার করা খুব সহজ করে তোলে, তাই Rustaceans ছোট প্রকল্প লিখতে সক্ষম যা অনেকগুলি প্যাকেজ থেকে একত্রিত করা হয়।

### একটি র্যান্ডম সংখ্যা তৈরি করা

অনুমান করার জন্য একটি সংখ্যা তৈরি করতে `rand` ব্যবহার শুরু করা যাক। পরবর্তী ধাপ হল _src/main.rs_ আপডেট করা, যেমন Listing 2-3 এ দেখানো হয়েছে।

<Listing number="2-3" file-name="src/main.rs" caption="একটি র্যান্ডম সংখ্যা তৈরি করার জন্য কোড যোগ করা">

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:all}}
```

</Listing>

প্রথমে আমরা `use rand::Rng;` লাইনটি যোগ করি। `Rng` trait এমন মেথডগুলি সংজ্ঞায়িত করে যা র্যান্ডম সংখ্যা জেনারেটরগুলি প্রয়োগ করে, এবং সেই মেথডগুলি ব্যবহার করার জন্য এই trait টিকে স্কোপে থাকতে হবে। অধ্যায় 10 এ traits নিয়ে বিস্তারিত আলোচনা করা হবে।

এরপর, আমরা মাঝখানে দুটি লাইন যোগ করছি। প্রথম লাইনে, আমরা `rand::thread_rng` ফাংশনটি কল করি যা আমাদের বিশেষ র্যান্ডম নম্বর জেনারেটর দেয় যা আমরা ব্যবহার করতে যাচ্ছি: একটি যা এক্সিকিউশনের বর্তমান থ্রেডের জন্য স্থানীয় এবং অপারেটিং সিস্টেম দ্বারা বীজযুক্ত। তারপর আমরা র্যান্ডম নম্বর জেনারেটরের উপর `gen_range` মেথডটি কল করি। এই মেথডটি `Rng` trait দ্বারা সংজ্ঞায়িত করা হয়েছে যা আমরা `use rand::Rng;` স্টেটমেন্ট দিয়ে স্কোপে নিয়ে এসেছি। `gen_range` মেথডটি আর্গুমেন্ট হিসেবে একটি রেঞ্জ এক্সপ্রেশন নেয় এবং রেঞ্জের মধ্যে একটি র্যান্ডম সংখ্যা তৈরি করে। আমরা এখানে যে ধরনের রেঞ্জ এক্সপ্রেশন ব্যবহার করছি তা `start..=end` ফর্ম নেয় এবং নিম্ন এবং উপরের সীমাতে অন্তর্ভুক্ত থাকে, তাই 1 থেকে 100 এর মধ্যে একটি সংখ্যা অনুরোধ করতে আমাদের `1..=100` নির্দিষ্ট করতে হবে।

> দ্রষ্টব্য: আপনি কোনো crate থেকে কোন traits ব্যবহার করবেন এবং কোন মেথড ও ফাংশন কল করবেন তা শুধু জেনেই বুঝতে পারবেন না, তাই প্রতিটি crate এ এটি ব্যবহারের নির্দেশাবলী সহ ডকুমেন্টেশন থাকে। Cargo এর আরেকটি চমৎকার বৈশিষ্ট্য হল `cargo doc --open` কমান্ড চালালে আপনার সমস্ত নির্ভরতা দ্বারা সরবরাহ করা ডকুমেন্টেশন স্থানীয়ভাবে তৈরি হবে এবং আপনার ব্রাউজারে খুলবে। উদাহরণস্বরূপ, আপনি যদি `rand` crate-এর অন্যান্য কার্যকারিতা সম্পর্কে আগ্রহী হন, তাহলে `cargo doc --open` চালান এবং বাম পাশের সাইডবারে `rand`-এ ক্লিক করুন।

দ্বিতীয় নতুন লাইনটি গোপন সংখ্যাটি প্রিন্ট করে। প্রোগ্রামটি পরীক্ষা করার জন্য এটি ডেভেলপ করার সময় এটি কার্যকর, তবে আমরা চূড়ান্ত সংস্করণ থেকে এটি মুছে ফেলব। প্রোগ্রাম শুরু হওয়ার সাথে সাথেই উত্তর প্রিন্ট করলে তা খেলার মতো হবে না!

প্রোগ্রামটি কয়েকবার চালানোর চেষ্টা করুন:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-03/
cargo run
4
cargo run
5
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4

$ cargo run
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
```

আপনার বিভিন্ন র্যান্ডম সংখ্যা পাওয়া উচিত, এবং সেগুলি সবই 1 থেকে 100 এর মধ্যে সংখ্যা হওয়া উচিত। খুব ভালো!

## অনুমানের সাথে গোপন সংখ্যার তুলনা করা

এখন যেহেতু আমাদের কাছে ব্যবহারকারীর ইনপুট এবং একটি র্যান্ডম সংখ্যা আছে, আমরা তাদের তুলনা করতে পারি। সেই ধাপটি Listing 2-4 এ দেখানো হয়েছে। মনে রাখবেন যে এই কোডটি এখনও কম্পাইল হবে না, কারণ আমরা ব্যাখ্যা করব।

<Listing number="2-4" file-name="src/main.rs" caption="দুটি সংখ্যা তুলনা করার সম্ভাব্য রিটার্ন মানগুলি হ্যান্ডেল করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-04/src/main.rs:here}}
```

</Listing>

প্রথমে আমরা আরও একটি `use` স্টেটমেন্ট যোগ করি, স্ট্যান্ডার্ড লাইব্রেরি থেকে `std::cmp::Ordering` নামের একটি টাইপকে স্কোপে নিয়ে আসি। `Ordering` টাইপটি আরও একটি enum এবং এর ভেরিয়েন্ট রয়েছে `Less`, `Greater`, এবং `Equal`। এই তিনটি সম্ভাব্য ফলাফল যা আপনি দুটি মান তুলনা করলে পাওয়া যায়।

তারপর আমরা নীচে পাঁচটি নতুন লাইন যোগ করি যা `Ordering` টাইপ ব্যবহার করে। `cmp` মেথড দুটি মান তুলনা করে এবং যে কোনও কিছুর উপর কল করা যেতে পারে যা তুলনা করা যায়। এটি আপনি যার সাথে তুলনা করতে চান তার একটি রেফারেন্স নেয়: এখানে এটি `guess` এর সাথে `secret_number` এর তুলনা করছে। তারপর এটি `use` স্টেটমেন্টের মাধ্যমে আমরা যে `Ordering` enum টি স্কোপে এনেছি তার একটি ভেরিয়েন্ট রিটার্ন করে। `guess` এবং `secret_number` এর মান দিয়ে `cmp` কল থেকে রিটার্ন করা `Ordering` এর কোন ভেরিয়েন্টটি ফিরে এসেছে তার উপর ভিত্তি করে আমরা পরবর্তীতে কী করতে হবে তা সিদ্ধান্ত নিতে একটি [`match`][match]<!-- ignore --> এক্সপ্রেশন ব্যবহার করি।

একটি `match` এক্সপ্রেশন _arms_ দিয়ে গঠিত। একটি arm একটি _pattern_ নিয়ে গঠিত যা মিলানোর জন্য এবং কোড যা `match` কে দেওয়া মান সেই arm এর প্যাটার্নের সাথে খাপ খেলে রান করা উচিত। Rust `match` কে দেওয়া মানটি নেয় এবং প্রতিটি arm এর প্যাটার্ন একে একে দেখে। প্যাটার্ন এবং `match` গঠন শক্তিশালী Rust বৈশিষ্ট্য: তারা আপনাকে বিভিন্ন পরিস্থিতি প্রকাশ করতে দেয় যা আপনার কোড সম্মুখীন হতে পারে এবং তারা নিশ্চিত করে যে আপনি সেগুলি সবই পরিচালনা করেন। এই বৈশিষ্ট্যগুলি যথাক্রমে অধ্যায় 6 এবং অধ্যায় 19 এ বিস্তারিতভাবে আলোচনা করা হবে।

আসুন আমরা এখানে ব্যবহার করা `match` এক্সপ্রেশনের একটি উদাহরণ দেখি। ধরুন ব্যবহারকারী 50 অনুমান করেছে এবং এইবার র্যান্ডমলি জেনারেট করা গোপন সংখ্যাটি হল 38।

যখন কোডটি 50 কে 38 এর সাথে তুলনা করে, তখন `cmp` মেথড `Ordering::Greater` রিটার্ন করবে কারণ 50 38 এর থেকে বড়। `match` এক্সপ্রেশন `Ordering::Greater` মান পায় এবং প্রতিটি arm এর প্যাটার্ন পরীক্ষা করা শুরু করে। এটি প্রথম arm এর প্যাটার্ন, `Ordering::Less` দেখে এবং দেখে যে `Ordering::Greater` মান `Ordering::Less` এর সাথে মেলে না, তাই এটি সেই arm এর কোডটিকে উপেক্ষা করে এবং পরবর্তী arm এ চলে যায়। পরবর্তী arm এর প্যাটার্ন হল `Ordering::Greater`, যা `Ordering::Greater` এর সাথে _মিলে যায়_! সেই arm এর সাথে যুক্ত কোডটি এক্সিকিউট হবে এবং স্ক্রিনে `Too big!` প্রিন্ট করবে। `match` এক্সপ্রেশন প্রথম সফল মিলের পরে শেষ হয়, তাই এটি এই পরিস্থিতিতে শেষ arm টি দেখবে না।

তবে, Listing 2-4 এর কোডটি এখনও কম্পাইল হবে না। আসুন চেষ্টা করি:

<!--
The error numbers in this output should be that of the code **WITHOUT** the
anchor or snip comments
-->

```console
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-04/output.txt}}
```

ত্রুটির মূল অংশে বলা হয়েছে যে _mismatched types_ রয়েছে। Rust এর একটি শক্তিশালী, স্ট্যাটিক টাইপ সিস্টেম রয়েছে। তবে, এটির টাইপ ইনফারেন্সও রয়েছে। যখন আমরা `let mut guess = String::new()` লিখেছিলাম, তখন Rust অনুমান করতে সক্ষম হয়েছিল যে `guess` একটি `String` হওয়া উচিত এবং আমাদেরকে টাইপ লিখতে বাধ্য করেনি। অন্যদিকে, `secret_number` একটি সংখ্যা টাইপ। Rust এর কয়েকটি সংখ্যা টাইপের মান 1 থেকে 100 এর মধ্যে থাকতে পারে: `i32`, একটি 32-বিট সংখ্যা; `u32`, একটি আনসাইনড 32-বিট সংখ্যা; `i64`, একটি 64-বিট সংখ্যা; সেইসাথে অন্যান্য। অন্যথায় নির্দিষ্ট না করা হলে, Rust ডিফল্টরূপে একটি `i32` ব্যবহার করে, যা `secret_number` এর টাইপ যদি না আপনি অন্য কোথাও টাইপ তথ্য যোগ করেন যা Rust কে একটি ভিন্ন সংখ্যাসূচক টাইপ অনুমান করতে বাধ্য করবে। ত্রুটির কারণ হল Rust একটি স্ট্রিং এবং একটি সংখ্যা টাইপ তুলনা করতে পারে না।

অবশেষে, আমরা প্রোগ্রামটি ইনপুট হিসাবে যা পড়ে সেই `String` কে একটি সংখ্যা টাইপে রূপান্তর করতে চাই যাতে আমরা এটিকে গোপন সংখ্যার সাথে সংখ্যাগতভাবে তুলনা করতে পারি। আমরা `main` ফাংশন বডিতে এই লাইনটি যোগ করে তা করি:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/src/main.rs:here}}
```

লাইনটি হল:

```rust,ignore
let guess: u32 = guess.trim().parse().expect("Please type a number!");
```

আমরা `guess` নামের একটি ভেরিয়েবল তৈরি করি। কিন্তু অপেক্ষা করুন, প্রোগ্রামে কি ইতিমধ্যেই `guess` নামের একটি ভেরিয়েবল নেই? হ্যাঁ, আছে, তবে সহায়কভাবে Rust আমাদের `guess` এর পূর্ববর্তী মানটিকে একটি নতুন মান দিয়ে শ্যাডো করার অনুমতি দেয়। _Shadowing_ আমাদেরকে `guess` ভেরিয়েবলের নাম পুনরায় ব্যবহার করতে দেয়, উদাহরণস্বরূপ, `guess_str` এবং `guess` এর মতো দুটি অনন্য ভেরিয়েবল তৈরি করতে বাধ্য করার পরিবর্তে। আমরা [অধ্যায় 3][shadowing]<!-- ignore --> এ এটি আরও বিস্তারিতভাবে আলোচনা করব, তবে আপাতত জেনে রাখুন যে যখন আপনি একটি মানকে এক টাইপ থেকে অন্য টাইপে রূপান্তর করতে চান তখন এই বৈশিষ্ট্যটি প্রায়শই ব্যবহৃত হয়।

আমরা এই নতুন ভেরিয়েবলটিকে `guess.trim().parse()` এক্সপ্রেশনের সাথে বাইন্ড করি। এক্সপ্রেশনের `guess` মূল `guess` ভেরিয়েবলটিকে বোঝায় যাতে ইনপুটটি স্ট্রিং হিসাবে ছিল। একটি `String` ইনস্ট্যান্সের `trim` মেথডটি শুরু এবং শেষের যেকোনো হোয়াইটস্পেস দূর করবে, যা আমাদের স্ট্রিংটিকে একটি `u32`-এ রূপান্তর করার আগে করতে হবে, কারণ `u32`-এ শুধুমাত্র সংখ্যাসূচক ডেটা থাকতে পারে। ব্যবহারকারীকে `read_line` এবং তাদের অনুমান ইনপুট করার জন্য <kbd>enter</kbd> চাপতে হবে, যা স্ট্রিংটিতে একটি নতুন লাইন ক্যারেক্টার যোগ করে। উদাহরণস্বরূপ, যদি ব্যবহারকারী <kbd>5</kbd> টাইপ করে এবং <kbd>enter</kbd> চাপেন, তাহলে `guess` এইরকম দেখাবে: `5\n`। `\n` "নতুন লাইন" উপস্থাপন করে। (Windows এ, <kbd>enter</kbd> চাপলে একটি ক্যারেজ রিটার্ন এবং একটি নতুন লাইন, `\r\n` হয়।) `trim` মেথড `\n` বা `\r\n` সরিয়ে দেয়, যার ফলে শুধু `5` থাকে।

স্ট্রিং-এর [`parse` মেথড][parse]<!-- ignore --> একটি স্ট্রিংকে অন্য টাইপে রূপান্তর করে। এখানে, আমরা এটিকে একটি স্ট্রিং থেকে একটি সংখ্যায় রূপান্তর করতে ব্যবহার করি। `let guess: u32` ব্যবহার করে আমরা Rust কে সঠিক সংখ্যা টাইপটি জানাতে হবে। `guess` এর পরের কোলন (`:`) Rust কে বলে যে আমরা ভেরিয়েবলের টাইপটি ব্যাখ্যা করব। Rust এ কয়েকটি বিল্ট-ইন নম্বর টাইপ রয়েছে; এখানে দেখা `u32` হল একটি আনসাইনড, 32-বিট ইন্টিজার। এটি একটি ছোট ধনাত্মক সংখ্যার জন্য একটি ভাল ডিফল্ট পছন্দ। আপনি [অধ্যায় 3][integers]<!-- ignore --> এ অন্যান্য সংখ্যা টাইপ সম্পর্কে শিখবেন।

এছাড়াও, এই উদাহরণ প্রোগ্রামে `u32` টীকা এবং `secret_number` এর সাথে তুলনা করার অর্থ হল Rust অনুমান করবে যে `secret_number` ও একটি `u32` হওয়া উচিত। সুতরাং এখন তুলনা একই টাইপের দুটি মানের মধ্যে হবে!

`parse` মেথডটি শুধুমাত্র সেই অক্ষরগুলিতে কাজ করবে যেগুলিকে যৌক্তিকভাবে সংখ্যায় রূপান্তর করা যায় এবং তাই সহজেই ত্রুটি হতে পারে। উদাহরণস্বরূপ, যদি স্ট্রিংটিতে `A👍%` থাকে, তবে সেটিকে সংখ্যায় রূপান্তর করার কোনো উপায় থাকবে না। যেহেতু এটি ব্যর্থ হতে পারে, `parse` মেথড `read_line` মেথডের মতোই একটি `Result` টাইপ রিটার্ন করে (আগে [“`Result` টাইপ দিয়ে সম্ভাব্য ব্যর্থতা হ্যান্ডেল করা”](#handling-potential-failure-with-the-result-type)<!-- ignore--> এ আলোচনা করা হয়েছে)। আমরা `expect` মেথডটি আবার ব্যবহার করে এই `Result`টিকে একইভাবে ট্রিট করব। যদি `parse` একটি `Err` `Result` ভেরিয়েন্ট রিটার্ন করে কারণ এটি স্ট্রিং থেকে একটি সংখ্যা তৈরি করতে পারেনি, তাহলে `expect` কলটি গেমটিকে ক্র্যাশ করে দেবে এবং আমরা এটিকে দেওয়া বার্তাটি প্রিন্ট করবে। যদি `parse` স্ট্রিংটিকে সফলভাবে একটি সংখ্যায় রূপান্তর করতে পারে, তবে এটি `Result` এর `Ok` ভেরিয়েন্ট রিটার্ন করবে, এবং `expect` `Ok` মান থেকে আমরা যে সংখ্যাটি চাই সেটি রিটার্ন করবে।

আসুন এখন প্রোগ্রামটি চালাই:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-03-convert-string-to-number/
touch src/main.rs
cargo run
  76
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.26s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
```

সুন্দর! যদিও অনুমানের আগে স্পেস যোগ করা হয়েছিল, প্রোগ্রামটি এখনও বুঝতে পেরেছিল যে ব্যবহারকারী 76 অনুমান করেছে। বিভিন্ন ধরনের ইনপুট দিয়ে বিভিন্ন আচরণ যাচাই করার জন্য প্রোগ্রামটি কয়েকবার চালান: সঠিকভাবে সংখ্যাটি অনুমান করুন, এমন একটি সংখ্যা অনুমান করুন যা খুব বেশি, এবং এমন একটি সংখ্যা অনুমান করুন যা খুব কম।

আমরা এখন গেমের বেশিরভাগ অংশ কাজ করাচ্ছি, কিন্তু ব্যবহারকারী শুধুমাত্র একবার অনুমান করতে পারে। আসুন একটি লুপ যোগ করে এটি পরিবর্তন করি!

## লুপ দিয়ে একাধিক অনুমানের অনুমতি দেওয়া

`loop` কীওয়ার্ড একটি অসীম লুপ তৈরি করে। আমরা ব্যবহারকারীদের সংখ্যাটি অনুমান করার জন্য আরও সুযোগ দিতে একটি লুপ যোগ করব:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-04-looping/src/main.rs:here}}
```

আপনি দেখতে পাচ্ছেন, আমরা অনুমান ইনপুট প্রম্পট থেকে শুরু করে সবকিছু একটি লুপে সরিয়ে দিয়েছি। লুপের ভিতরের লাইনগুলিকে আরও চারটি স্পেস করে ইন্ডেন্ট করতে ভুলবেন না এবং আবার প্রোগ্রামটি চালান। প্রোগ্রামটি এখন চিরকাল আরও একটি অনুমানের জন্য জিজ্ঞাসা করবে, যা আসলে একটি নতুন সমস্যা তৈরি করে। মনে হচ্ছে ব্যবহারকারী প্রস্থান করতে পারবে না!

ব্যবহারকারী সবসময় কীবোর্ড শর্টকাট <kbd>ctrl</kbd>-<kbd>c</kbd> ব্যবহার করে প্রোগ্রামটিকে বাধা দিতে পারে। তবে এই অতৃপ্ত দানব থেকে পালানোর আরেকটি উপায় রয়েছে, যেমনটি [“অনুমানের সাথে গোপন সংখ্যার তুলনা করা”](#comparing-the-guess-to-the-secret-number)<!-- ignore --> এর `parse` আলোচনায় উল্লেখ করা হয়েছে: যদি ব্যবহারকারী একটি অ-সংখ্যা উত্তর প্রবেশ করে, প্রোগ্রামটি ক্র্যাশ করবে। আমরা ব্যবহারকারীকে প্রস্থান করার অনুমতি দেওয়ার জন্য এটির সুবিধা নিতে পারি, যেমন এখানে দেখানো হয়েছে:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/no-listing-04-looping/
touch src/main.rs
cargo run
(too small guess)
(too big guess)
(correct guess)
quit
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.23s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

`quit` টাইপ করলে গেমটি বন্ধ হয়ে যাবে, তবে আপনি যেমন লক্ষ্য করবেন, অন্য কোনো অ-সংখ্যা ইনপুট প্রবেশ করালেও বন্ধ হবে। এটি অন্ততপক্ষে সর্বোত্তম নয়; আমরা চাই যখন সঠিক সংখ্যা অনুমান করা হয় তখনও গেমটি বন্ধ হোক।

### সঠিক অনুমানের পরে প্রস্থান করা

আসুন একটি `break` স্টেটমেন্ট যোগ করে ব্যবহারকারী জিতলে গেমটি বন্ধ করার জন্য প্রোগ্রাম করি:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/no-listing-05-quitting/src/main.rs:here}}
```

`You win!` এর পরে `break` লাইন যোগ করা হলে ব্যবহারকারী সঠিকভাবে গোপন সংখ্যা অনুমান করলে প্রোগ্রামটি লুপ থেকে বেরিয়ে যাবে। লুপ থেকে বের হওয়ার মানে প্রোগ্রাম থেকে বেরিয়ে যাওয়াও, কারণ লুপটি `main` এর শেষ অংশ।

### অবৈধ ইনপুট হ্যান্ডেল করা

গেমের আচরণকে আরও উন্নত করার জন্য, ব্যবহারকারী যখন একটি অ-সংখ্যা ইনপুট করে তখন প্রোগ্রামটিকে ক্র্যাশ না করিয়ে, আসুন গেমটিকে একটি অ-সংখ্যা উপেক্ষা করি যাতে ব্যবহারকারী অনুমান করা চালিয়ে যেতে পারে। আমরা Listing 2-5 এ দেখানো হিসাবে, `guess` কে একটি `String` থেকে `u32`-এ রূপান্তর করার লাইনটি পরিবর্তন করে তা করতে পারি।

<Listing number="2-5" file-name="src/main.rs" caption="প্রোগ্রামটি ক্র্যাশ করার পরিবর্তে একটি অ-সংখ্যা অনুমান উপেক্ষা করা এবং অন্য অনুমানের জন্য জিজ্ঞাসা করা">

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-05/src/main.rs:here}}
```

</Listing>

আমরা ত্রুটিতে ক্র্যাশ করা থেকে ত্রুটি হ্যান্ডেল করার দিকে যেতে একটি `expect` কল থেকে `match` এক্সপ্রেশনে স্যুইচ করি। মনে রাখবেন যে `parse` একটি `Result` টাইপ রিটার্ন করে এবং `Result` হল একটি enum যার ভেরিয়েন্ট রয়েছে `Ok` এবং `Err`। আমরা এখানে একটি `match` এক্সপ্রেশন ব্যবহার করছি, যেমনটি আমরা `cmp` মেথডের `Ordering` ফলাফলের সাথে করেছি।

যদি `parse` সফলভাবে স্ট্রিংটিকে একটি সংখ্যায় রূপান্তর করতে সক্ষম হয়, তবে এটি একটি `Ok` মান রিটার্ন করবে যাতে ফলাফল সংখ্যা থাকে। সেই `Ok` মানটি প্রথম arm এর প্যাটার্নের সাথে মিলবে, এবং `match` এক্সপ্রেশনটি `parse` দ্বারা তৈরি করা এবং `Ok` মানের ভিতরে রাখা `num` মানটি শুধু রিটার্ন করবে। সেই সংখ্যাটি নতুন `guess` ভেরিয়েবলে যেখানে আমরা চাই সেখানেই শেষ হবে।

যদি `parse` স্ট্রিংটিকে একটি সংখ্যায় রূপান্তর করতে _না_ পারে, তবে এটি ত্রুটি সম্পর্কে আরও তথ্য ধারণকারী একটি `Err` মান রিটার্ন করবে। `Err` মানটি প্রথম `match` arm এর `Ok(num)` প্যাটার্নের সাথে মেলে না, তবে এটি দ্বিতীয় arm এর `Err(_)` প্যাটার্নের সাথে মেলে। আন্ডারস্কোর, `_`, হল একটি ক্যাচঅল মান; এই উদাহরণে, আমরা বলছি যে আমরা সমস্ত `Err` মান মেলাতে চাই, তাদের ভিতরে যে তথ্যই থাকুক না কেন। সুতরাং প্রোগ্রামটি দ্বিতীয় arm এর কোডটি এক্সিকিউট করবে, `continue`, যা প্রোগ্রামটিকে লুপের পরবর্তী পুনরাবৃত্তিতে যেতে এবং অন্য অনুমানের জন্য জিজ্ঞাসা করতে বলে। সুতরাং, কার্যকরভাবে, প্রোগ্রামটি `parse` এর সম্মুখীন হতে পারে এমন সমস্ত ত্রুটি উপেক্ষা করে!

এখন প্রোগ্রামের সবকিছু প্রত্যাশা অনুযায়ী কাজ করা উচিত। আসুন চেষ্টা করি:

<!-- manual-regeneration
cd listings/ch02-guessing-game-tutorial/listing-02-05/
cargo run
(too small guess)
(too big guess)
foo
(correct guess)
-->

```console
$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
```

অসাধারণ! একটি ছোট চূড়ান্ত পরিবর্তন করে, আমরা গেসিং গেমটি শেষ করব। মনে রাখবেন যে প্রোগ্রামটি এখনও গোপন সংখ্যাটি প্রিন্ট করছে। এটি পরীক্ষার জন্য ভাল কাজ করেছে, কিন্তু এটি গেমটিকে নষ্ট করে। আসুন `println!` সরিয়ে দিই যা গোপন সংখ্যা আউটপুট করে। Listing 2-6 চূড়ান্ত কোড দেখায়।

<Listing number="2-6" file-name="src/main.rs" caption="সম্পূর্ণ গেসিং গেম কোড">

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-06/src/main.rs}}
```

</Listing>

এই পর্যায়ে, আপনি সফলভাবে গেসিং গেম তৈরি করেছেন। অভিনন্দন!

## সারসংক্ষেপ

এই প্রকল্পটি `let`, `match`, ফাংশন, বাহ্যিক crates এর ব্যবহার এবং আরও অনেক নতুন Rust ধারণাগুলির সাথে পরিচয় করিয়ে দেওয়ার একটি হাতে-কলমে উপায় ছিল। নিম্নলিখিত কয়েকটি অধ্যায়ে, আপনি এই ধারণাগুলি আরও বিস্তারিতভাবে শিখবেন। অধ্যায় 3 ভেরিয়েবল, ডেটা টাইপ এবং ফাংশনের মতো বেশিরভাগ প্রোগ্রামিং ভাষার ধারণাগুলি আলোচনা করে এবং Rust এ সেগুলি কীভাবে ব্যবহার করতে হয় তা দেখায়। অধ্যায় 4 মালিকানা নিয়ে আলোচনা করে, এমন একটি বৈশিষ্ট্য যা Rust কে অন্যান্য ভাষা থেকে আলাদা করে। অধ্যায় 5 struct এবং মেথড সিনট্যাক্স নিয়ে আলোচনা করে এবং অধ্যায় 6 enum কিভাবে কাজ করে তা ব্যাখ্যা করে।

[prelude]: ../std/prelude/index.html
[variables-and-mutability]: ch03-01-variables-and-mutability.html#variables-and-mutability
[comments]: ch03-04-comments.html
[string]: ../std/string/struct.String.html
[iostdin]: ../std/io/struct.Stdin.html
[read_line]: ../std/io/struct.Stdin.html#method.read_line
[result]: ../std/result/enum.Result.html
[enums]: ch06-00-enums.html
[expect]: ../std/result/enum.Result.html#method.expect
[recover]: ch09-02-recoverable-errors-with-result.html
[randcrate]: https://crates.io/crates/rand
[semver]: http://semver.org
[cratesio]: https://crates.io/
[doccargo]: https://doc.rust-lang.org/cargo/
[doccratesio]: https://doc.rust-lang.org/cargo/reference/publishing.html
[match]: ch06-02-match.html
[shadowing]: ch03-01-variables-and-mutability.html#shadowing
[parse]: ../std/primitive.str.html#method.parse
[integers]: ch03-02-data-types.html#integer-types
