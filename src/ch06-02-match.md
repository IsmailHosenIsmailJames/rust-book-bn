<!-- Old heading. Do not remove or links may break. -->

<a id="the-match-control-flow-operator"></a>

## `match` কন্ট্রোল ফ্লো কনস্ট্রাক্ট

Rust এ `match` নামক একটি অত্যন্ত শক্তিশালী কন্ট্রোল ফ্লো কনস্ট্রাক্ট রয়েছে যা আপনাকে একটি মানের সাথে patterns এর একটি সিরিজের তুলনা করতে এবং তারপর কোন pattern টি মেলে তার উপর ভিত্তি করে কোড এক্সিকিউট করতে দেয়। Patterns আক্ষরিক মান, ভেরিয়েবলের নাম, ওয়াইল্ডকার্ড এবং আরও অনেক কিছু দিয়ে তৈরি করা যেতে পারে; [Chapter 19][ch19-00-patterns]<!-- ignore --> সমস্ত বিভিন্ন ধরণের pattern এবং তারা কী করে তা কভার করে। `match` এর ক্ষমতা আসে patterns এর অভিব্যক্তি এবং কম্পাইলার নিশ্চিত করে যে সমস্ত সম্ভাব্য ক্ষেত্রে পরিচালনা করা হয়েছে এই কারণে।

একটি `match` এক্সপ্রেশনকে একটি কয়েন বাছাই করার মেশিনের মতো মনে করুন: কয়েনগুলি বিভিন্ন আকারের গর্ত সহ একটি ট্র্যাকের নীচে স্লাইড করে এবং প্রতিটি কয়েন প্রথম গর্ত দিয়ে পড়ে যার সাথে এটি ফিট করে। একইভাবে, মানগুলি `match` এর প্রতিটি pattern এর মধ্যে দিয়ে যায় এবং প্রথম pattern যেখানে মান "ফিট" হয়, সেই মানটি এক্সিকিউশনের সময় ব্যবহার করার জন্য সংশ্লিষ্ট কোড ব্লকের মধ্যে পড়ে যায়।

কয়েনের কথা বলতে গেলে, আসুন `match` ব্যবহার করে সেগুলিকে একটি উদাহরণ হিসাবে ব্যবহার করি! আমরা একটি ফাংশন লিখতে পারি যা একটি অজানা US কয়েন নেয় এবং, গণনা মেশিনের মতোই, এটি কোন কয়েন তা নির্ধারণ করে এবং সেন্টে এর মান ফেরত দেয়, যেমন Listing 6-3 এ দেখানো হয়েছে।

<Listing number="6-3" caption="একটি enum এবং একটি `match` এক্সপ্রেশন যার pattern হিসাবে enum এর variant গুলি রয়েছে">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-03/src/main.rs:here}}
```

</Listing>

আসুন `value_in_cents` ফাংশনে `match` বিশ্লেষণ করি। প্রথমে আমরা `match` কীওয়ার্ড তালিকাভুক্ত করি এবং তারপরে একটি এক্সপ্রেশন, এই ক্ষেত্রে যা `coin` মান। এটি `if` এর সাথে ব্যবহৃত একটি শর্তাধীন এক্সপ্রেশনের মতোই মনে হয়, তবে একটি বড় পার্থক্য রয়েছে: `if` এর সাথে, শর্তটিকে একটি বুলিয়ান মানে মূল্যায়ন করতে হবে, তবে এখানে এটি যেকোনো প্রকারের হতে পারে। এই উদাহরণে `coin` এর প্রকার হল `Coin` enum যা আমরা প্রথম লাইনে সংজ্ঞায়িত করেছি।

এর পরে `match` এর arm গুলি। একটি arm এর দুটি অংশ রয়েছে: একটি pattern এবং কিছু কোড। এখানে প্রথম arm টির একটি pattern আছে যা `Coin::Penny` মান এবং তারপরে `=>` অপারেটর যা pattern এবং রান করার কোডকে আলাদা করে। এই ক্ষেত্রে কোডটি কেবল `1` মান। প্রতিটি arm কমা দিয়ে পরেরটি থেকে আলাদা করা হয়েছে।

যখন `match` এক্সপ্রেশন এক্সিকিউট হয়, তখন এটি প্রতিটি arm এর pattern এর সাথে ফলাফলের মানের তুলনা করে, ক্রমানুসারে। যদি কোনো pattern মানের সাথে মেলে, তবে সেই pattern এর সাথে যুক্ত কোডটি এক্সিকিউট করা হয়। যদি সেই pattern মানের সাথে না মেলে, তবে এক্সিকিউশনটি পরবর্তী arm এ চলতে থাকে, অনেকটা কয়েন বাছাই করার মেশিনের মতো। আমাদের যতগুলি arm প্রয়োজন ততগুলি রাখতে পারি: Listing 6-3 এ, আমাদের `match` এ চারটি arm রয়েছে।

প্রতিটি arm এর সাথে যুক্ত কোডটি একটি এক্সপ্রেশন এবং matching arm এর এক্সপ্রেশনের ফলস্বরূপ মান হল সেই মান যা পুরো `match` এক্সপ্রেশনের জন্য ফেরত দেওয়া হয়।

আমরা সাধারণত কার্লি ব্র্যাকেট ব্যবহার করি না যদি match arm কোডটি ছোট হয়, যেমন Listing 6-3 এ, যেখানে প্রতিটি arm শুধু একটি মান ফেরত দেয়। আপনি যদি একটি match arm এ একাধিক লাইনের কোড রান করতে চান, তবে আপনাকে কার্লি ব্র্যাকেট ব্যবহার করতে হবে এবং তারপরে arm এর পরে কমাটি ঐচ্ছিক। উদাহরণস্বরূপ, নিম্নলিখিত কোডটি প্রতিবার `Coin::Penny` দিয়ে method টি কল করা হলে "Lucky penny!" প্রিন্ট করে, কিন্তু তবুও ব্লকের শেষ মান `1` ফেরত দেয়:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-08-match-arm-multiple-lines/src/main.rs:here}}
```

### Patterns যা মানের সাথে বাইন্ড করে

Match arm এর আরেকটি কার্যকর বৈশিষ্ট্য হল যে তারা pattern এর সাথে মেলে এমন মানগুলির অংশগুলির সাথে বাইন্ড করতে পারে। এইভাবেই আমরা enum variant থেকে মান বের করতে পারি।

একটি উদাহরণ হিসাবে, আসুন আমাদের enum variant গুলির একটিকে এর ভিতরে ডেটা রাখার জন্য পরিবর্তন করি। 1999 থেকে 2008 সাল পর্যন্ত, মার্কিন যুক্তরাষ্ট্র একপাশে 50 টি রাজ্যের জন্য বিভিন্ন ডিজাইন সহ কোয়ার্টার তৈরি করত। অন্য কোনো কয়েনে রাজ্যের ডিজাইন ছিল না, তাই শুধুমাত্র কোয়ার্টারে এই অতিরিক্ত মান রয়েছে। আমরা `Quarter` variant কে এর ভিতরে একটি `UsState` মান অন্তর্ভুক্ত করার জন্য পরিবর্তন করে আমাদের `enum` এ এই তথ্য যোগ করতে পারি, যা আমরা Listing 6-4 এ করেছি।

<Listing number="6-4" caption="একটি `Coin` enum যেখানে `Quarter` variant একটি `UsState` মানও ধারণ করে">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-04/src/main.rs:here}}
```

</Listing>

ধরা যাক যে একজন বন্ধু 50টি রাজ্যের কোয়ার্টার সংগ্রহ করার চেষ্টা করছে। আমরা যখন কয়েন প্রকার অনুসারে আমাদের খুচরা পয়সা বাছাই করি, তখন আমরা প্রতিটি কোয়ার্টারের সাথে যুক্ত রাজ্যের নামও উল্লেখ করব যাতে যদি সেটি এমন একটি হয় যা আমাদের বন্ধুর কাছে নেই, তবে তারা এটিকে তাদের সংগ্রহে যোগ করতে পারে।

এই কোডের জন্য match এক্সপ্রেশনে, আমরা `Coin::Quarter` variant এর মানের সাথে মেলে এমন pattern এ `state` নামের একটি ভেরিয়েবল যোগ করি। যখন একটি `Coin::Quarter` মেলে, তখন `state` ভেরিয়েবলটি সেই কোয়ার্টারের রাজ্যের মানের সাথে বাইন্ড হবে। তারপরে আমরা সেই arm এর কোডে `state` ব্যবহার করতে পারি, যেমন:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-09-variable-in-pattern/src/main.rs:here}}
```

যদি আমরা `value_in_cents(Coin::Quarter(UsState::Alaska))` কল করি, তবে `coin` হবে `Coin::Quarter(UsState::Alaska)`। যখন আমরা সেই মানটিকে প্রতিটি match arm এর সাথে তুলনা করি, তখন `Coin::Quarter(state)` এ না পৌঁছানো পর্যন্ত সেগুলির কোনটিই মেলে না। সেই সময়ে, `state` এর বাইন্ডিং হবে `UsState::Alaska` মান। তারপরে আমরা `println!` এক্সপ্রেশনে সেই বাইন্ডিং ব্যবহার করতে পারি, এইভাবে `Quarter` এর জন্য `Coin` enum variant থেকে ভিতরের state মানটি বের করতে পারি।

### `Option<T>` এর সাথে ম্যাচিং

পূর্ববর্তী বিভাগে, আমরা `Option<T>` ব্যবহার করার সময় `Some` case থেকে ভিতরের `T` মানটি বের করতে চেয়েছিলাম; আমরা `match` ব্যবহার করে `Option<T>` ও পরিচালনা করতে পারি, যেমনটি আমরা `Coin` enum এর সাথে করেছি! কয়েনগুলির তুলনা করার পরিবর্তে, আমরা `Option<T>` এর variant গুলির তুলনা করব, তবে `match` এক্সপ্রেশনটি যেভাবে কাজ করে তা একই থাকে।

ধরুন আমরা এমন একটি ফাংশন লিখতে চাই যা একটি `Option<i32>` নেয় এবং যদি এর ভিতরে কোনো মান থাকে, তবে সেই মানের সাথে 1 যোগ করে। যদি এর ভিতরে কোনো মান না থাকে, তবে ফাংশনটির `None` মান ফেরত দেওয়া উচিত এবং কোনো অপারেশন করার চেষ্টা করা উচিত নয়।

`match` এর জন্য এই ফাংশনটি লেখা খুবই সহজ এবং এটি Listing 6-5 এর মতো দেখাবে।

<Listing number="6-5" caption="একটি ফাংশন যা `Option<i32>` এ একটি `match` এক্সপ্রেশন ব্যবহার করে">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:here}}
```

</Listing>

আসুন `plus_one` এর প্রথম এক্সিকিউশনটি আরও বিস্তারিতভাবে পরীক্ষা করি। যখন আমরা `plus_one(five)` কল করি, তখন `plus_one` এর বডিতে ভেরিয়েবল `x` এর মান হবে `Some(5)`। তারপরে আমরা সেটিকে প্রতিটি match arm এর সাথে তুলনা করি:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

`Some(5)` মানটি `None` pattern এর সাথে মেলে না, তাই আমরা পরবর্তী arm এ চলতে থাকি:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:second_arm}}
```

`Some(5)` কি `Some(i)` এর সাথে মেলে? হ্যাঁ! আমাদের একই variant আছে। `i` `Some` এর মধ্যে থাকা মানের সাথে বাইন্ড করে, তাই `i` মান `5` নেয়। তারপরে match arm এর কোডটি এক্সিকিউট করা হয়, তাই আমরা `i` এর মানের সাথে 1 যোগ করি এবং ভিতরে আমাদের মোট `6` দিয়ে একটি নতুন `Some` মান তৈরি করি।

এখন Listing 6-5 এ `plus_one` এর দ্বিতীয় কলটি বিবেচনা করা যাক, যেখানে `x` হল `None`। আমরা `match` এ প্রবেশ করি এবং প্রথম arm এর সাথে তুলনা করি:

```rust,ignore
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-05/src/main.rs:first_arm}}
```

এটি মেলে! যোগ করার মতো কোনো মান নেই, তাই প্রোগ্রামটি বন্ধ হয়ে যায় এবং `=>` এর ডানদিকে `None` মানটি ফেরত দেয়। যেহেতু প্রথম arm টি মিলেছে, তাই অন্য কোনো arm তুলনা করা হয় না।

`match` এবং enums একত্রিত করা অনেক পরিস্থিতিতে কার্যকর। আপনি Rust কোডে এই pattern টি অনেক দেখবেন: একটি enum এর বিপরীতে `match`, ভিতরে ডেটাতে একটি ভেরিয়েবল বাইন্ড করুন এবং তারপরে এর উপর ভিত্তি করে কোড এক্সিকিউট করুন। প্রথমে এটি একটু কঠিন, তবে একবার আপনি এতে অভ্যস্ত হয়ে গেলে, আপনি চাইবেন যে এটি সমস্ত ভাষাতেই থাকুক। এটি ধারাবাহিকভাবে ব্যবহারকারীদের পছন্দের।

### Matches সম্পূর্ণ হতে হবে

আমাদের `match` নিয়ে আলোচনা করার জন্য আরও একটি দিক রয়েছে: arm এর pattern গুলিকে সমস্ত সম্ভাবনা কভার করতে হবে। আমাদের `plus_one` ফাংশনের এই সংস্করণটি বিবেচনা করুন, যার একটি বাগ রয়েছে এবং এটি কম্পাইল হবে না:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/src/main.rs:here}}
```

আমরা `None` ক্ষেত্রটি পরিচালনা করিনি, তাই এই কোডটি একটি বাগ তৈরি করবে। সৌভাগ্যবশত, এটি একটি বাগ যা Rust জানে কিভাবে ধরতে হয়। যদি আমরা এই কোডটি কম্পাইল করার চেষ্টা করি, তাহলে আমরা এই ত্রুটিটি পাব:

```console
{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-10-non-exhaustive-match/output.txt}}
```

Rust জানে যে আমরা প্রতিটি সম্ভাব্য ক্ষেত্র কভার করিনি এবং এমনকি আমরা কোন pattern টি ভুলে গেছি তাও জানে! Rust এ Matches _সম্পূর্ণ_ হতে হবে: কোডটিকে বৈধ হওয়ার জন্য আমাদের অবশ্যই প্রতিটি শেষ সম্ভাবনাকে শেষ করতে হবে। বিশেষ করে `Option<T>` এর ক্ষেত্রে, যখন Rust আমাদের `None` ক্ষেত্রটিকে স্পষ্টভাবে পরিচালনা করতে ভুলে যাওয়া থেকে বাধা দেয়, তখন এটি আমাদের null থাকতে পারে এমন সময় একটি মান আছে বলে ধরে নেওয়া থেকে রক্ষা করে, এইভাবে আগে আলোচিত বিলিয়ন ডলারের ভুলটিকে অসম্ভব করে তোলে।

### Catch-all Patterns এবং `_` প্লেসহোল্ডার

enums ব্যবহার করে, আমরা কয়েকটি নির্দিষ্ট মানের জন্য বিশেষ পদক্ষেপ নিতে পারি, কিন্তু অন্য সব মানের জন্য একটি ডিফল্ট পদক্ষেপ নিতে পারি। কল্পনা করুন যে আমরা এমন একটি গেম প্রয়োগ করছি যেখানে, আপনি যদি ডাইস রোলে 3 রোল করেন, তবে আপনার খেলোয়াড় সরবে না, তবে পরিবর্তে একটি নতুন অভিনব টুপি পাবে। আপনি যদি 7 রোল করেন, তবে আপনার খেলোয়াড় একটি অভিনব টুপি হারাবে। অন্য সব মানের জন্য, আপনার খেলোয়াড় গেম বোর্ডে সেই সংখ্যার স্থান সরবে। এখানে একটি `match` রয়েছে যা সেই যুক্তিটি প্রয়োগ করে, ডাইস রোলের ফলাফলের পরিবর্তে একটি র্যান্ডম মান এবং অন্যান্য সমস্ত যুক্তি বডি ছাড়া ফাংশন দ্বারা উপস্থাপিত হয় কারণ সেগুলিকে বাস্তবায়ন করা এই উদাহরণের জন্য খুব বেশি গুরুত্বপূর্ণ নয়:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-15-binding-catchall/src/main.rs:here}}
```

প্রথম দুটি arm এর জন্য, pattern গুলি হল আক্ষরিক মান `3` এবং `7`। শেষ arm টির জন্য, যা অন্য সব সম্ভাব্য মান কভার করে, pattern টি হল সেই ভেরিয়েবল যাকে আমরা `other` নাম দিতে পছন্দ করেছি। `other` arm এর জন্য রান করা কোডটি `move_player` ফাংশনে পাস করে ভেরিয়েবলটি ব্যবহার করে।

এই কোডটি কম্পাইল হয়, যদিও আমরা একটি `u8` এর সম্ভাব্য সমস্ত মান তালিকাভুক্ত করিনি, কারণ শেষ pattern টি বিশেষভাবে তালিকাভুক্ত নয় এমন সমস্ত মানের সাথে মিলবে। এই catch-all pattern টি `match` এর সম্পূর্ণ হওয়ার প্রয়োজনীয়তা পূরণ করে। মনে রাখবেন যে আমাদের catch-all arm টিকে শেষ রাখতে হবে কারণ pattern গুলি ক্রমানুসারে মূল্যায়ন করা হয়। যদি আমরা catch-all arm টিকে আগে রাখি, তবে অন্যান্য arm গুলো কখনই রান হবে না, তাই আমরা যদি catch-all এর পরে arm যোগ করি তবে Rust আমাদের সতর্ক করবে!

Rust এর এমন একটি pattern ও রয়েছে যা আমরা ব্যবহার করতে পারি যখন আমরা একটি catch-all চাই কিন্তু catch-all pattern এ মানটি _ব্যবহার_ করতে চাই না: `_` হল একটি বিশেষ pattern যা যেকোনো মানের সাথে মেলে এবং সেই মানের সাথে বাইন্ড করে না। এটি Rust কে বলে যে আমরা মানটি ব্যবহার করতে যাচ্ছি না, তাই Rust আমাদের অব্যবহৃত ভেরিয়েবল সম্পর্কে সতর্ক করবে না।

আসুন গেমের নিয়মগুলি পরিবর্তন করি: এখন, আপনি যদি 3 বা 7 ছাড়া অন্য কিছু রোল করেন তবে আপনাকে আবার রোল করতে হবে। আমাদের আর catch-all মানটি ব্যবহার করার প্রয়োজন নেই, তাই আমরা আমাদের কোড পরিবর্তন করে `other` নামের ভেরিয়েবলের পরিবর্তে `_` ব্যবহার করতে পারি:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-16-underscore-catchall/src/main.rs:here}}
```

এই উদাহরণটিও সম্পূর্ণতার প্রয়োজনীয়তা পূরণ করে কারণ আমরা শেষ arm এ স্পষ্টভাবে অন্য সমস্ত মান উপেক্ষা করছি; আমরা কিছুই ভুলিনি।

অবশেষে, আমরা গেমের নিয়মগুলি আরও একবার পরিবর্তন করব যাতে আপনি যদি 3 বা 7 ছাড়া অন্য কিছু রোল করেন তবে আপনার পালাক্রমে আর কিছুই ঘটবে না। আমরা `_` arm এর সাথে যাওয়া কোড হিসাবে unit মান (খালি tuple প্রকার যা আমরা [“The Tuple Type”][tuples]<!-- ignore --> বিভাগে উল্লেখ করেছি) ব্যবহার করে এটি প্রকাশ করতে পারি:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-17-underscore-unit/src/main.rs:here}}
```

এখানে, আমরা Rust কে স্পষ্টভাবে বলছি যে আমরা অন্য কোনো মান ব্যবহার করতে যাচ্ছি না যা আগের arm এ একটি pattern এর সাথে মেলে না এবং আমরা এই ক্ষেত্রে কোনো কোড রান করতে চাই না।

patterns এবং matching সম্পর্কে আরও অনেক কিছু আছে যা আমরা [Chapter 19][ch19-00-patterns]<!-- ignore --> এ কভার করব। আপাতত, আমরা `if let` সিনট্যাক্সে যাব, যা এমন পরিস্থিতিতে কার্যকর হতে পারে যেখানে `match` এক্সপ্রেশনটি একটু বেশি শব্দবহুল।

[tuples]: ch03-02-data-types.html#the-tuple-type
[ch19-00-patterns]: ch19-00-patterns.html
