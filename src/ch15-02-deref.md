## `Deref` trait ব্যবহার করে স্মার্ট পয়েন্টারগুলোকে সাধারণ রেফারেন্সের মতো ব্যবহার করা

`Deref` trait প্রয়োগ করার মাধ্যমে আপনি _ডিরেফারেন্স অপারেটর_ `*`-এর আচরণ কাস্টমাইজ করতে পারবেন (গুণ বা গ্লোব অপারেটরের সাথে বিভ্রান্ত হবেন না)। এমনভাবে `Deref` প্রয়োগ করার মাধ্যমে যে একটি স্মার্ট পয়েন্টারকে সাধারণ রেফারেন্সের মতো ব্যবহার করা যায়, আপনি এমন কোড লিখতে পারেন যা রেফারেন্সের উপর কাজ করে এবং সেই কোড স্মার্ট পয়েন্টারগুলোর সাথেও ব্যবহার করতে পারেন।

আসুন প্রথমে দেখি কিভাবে ডিরেফারেন্স অপারেটর সাধারণ রেফারেন্সের সাথে কাজ করে। তারপর আমরা `Box<T>`-এর মতো আচরণ করে এমন একটি কাস্টম টাইপ সংজ্ঞায়িত করার চেষ্টা করব, এবং দেখব কেন ডিরেফারেন্স অপারেটর আমাদের নতুন সংজ্ঞায়িত টাইপের উপর রেফারেন্সের মতো কাজ করে না। আমরা আলোচনা করব কিভাবে `Deref` trait প্রয়োগ করলে স্মার্ট পয়েন্টারগুলো রেফারেন্সের মতোই কাজ করতে পারে। তারপর আমরা Rust-এর _ডিরেফ কোয়েরশন_ বৈশিষ্ট্য এবং কিভাবে এটি আমাদের রেফারেন্স বা স্মার্ট পয়েন্টারগুলোর সাথে কাজ করতে দেয় তা দেখব।

> দ্রষ্টব্য: `MyBox<T>` টাইপ যা আমরা তৈরি করতে যাচ্ছি এবং আসল `Box<T>`-এর মধ্যে একটি বড় পার্থক্য আছে: আমাদের সংস্করণটি হিপে তার ডেটা সংরক্ষণ করবে না। আমরা এই উদাহরণে `Deref`-এর উপর ফোকাস করছি, তাই ডেটা কোথায় আসলে সংরক্ষিত আছে সেটা পয়েন্টার-সদৃশ আচরণের চেয়ে কম গুরুত্বপূর্ণ।

<!-- Old link, do not remove -->

<a id="following-the-pointer-to-the-value-with-the-dereference-operator"></a>

### পয়েন্টার অনুসরণ করে ভ্যালুতে যাওয়া

একটি সাধারণ রেফারেন্স হল এক ধরনের পয়েন্টার, এবং পয়েন্টারকে অন্য কোথাও সংরক্ষিত একটি ভ্যালুর দিকে নির্দেশিত তীর হিসেবে মনে করা যেতে পারে। Listing 15-6-এ, আমরা একটি `i32` ভ্যালুর রেফারেন্স তৈরি করি এবং তারপর ডিরেফারেন্স অপারেটর ব্যবহার করে রেফারেন্সটিকে অনুসরণ করে ভ্যালুতে যাই:

<Listing number="15-6" file-name="src/main.rs" caption="একটি `i32` ভ্যালুর রেফারেন্স অনুসরণ করতে ডিরেফারেন্স অপারেটর ব্যবহার করা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-06/src/main.rs}}
```

</Listing>

ভেরিয়েবল `x` একটি `i32` ভ্যালু `5` ধরে রাখে। আমরা `y`-কে `x`-এর একটি রেফারেন্সের সমান করি। আমরা নিশ্চিত করতে পারি যে `x`, `5`-এর সমান। তবে, যদি আমরা `y`-এর ভ্যালু সম্পর্কে কোনো নিশ্চিততা তৈরি করতে চাই, তাহলে `y`-এর পয়েন্ট করা ভ্যালু অনুসরণ করার জন্য আমাদের `*y` ব্যবহার করতে হবে (তাই _ডিরেফারেন্স_), যাতে কম্পাইলার প্রকৃত ভ্যালু তুলনা করতে পারে। একবার আমরা `y`-কে ডিরেফারেন্স করলে, আমরা `y` যে ইন্টিজার ভ্যালু পয়েন্ট করছে, সেই ভ্যালুতে অ্যাক্সেস পাই, যা আমরা `5`-এর সাথে তুলনা করতে পারি।

যদি আমরা `assert_eq!(5, y);` লেখার চেষ্টা করতাম, তাহলে আমরা এই কম্পাইলেশন এরর পেতাম:

```console
{{#include ../listings/ch15-smart-pointers/output-only-01-comparing-to-reference/output.txt}}
```

একটি সংখ্যা এবং একটি সংখ্যার রেফারেন্সের তুলনা করার অনুমতি নেই কারণ তারা ভিন্ন টাইপ। যে ভ্যালুটির দিকে এটি নির্দেশ করছে, সেখানে যাওয়ার জন্য আমাদের অবশ্যই ডিরেফারেন্স অপারেটর ব্যবহার করতে হবে।

### রেফারেন্সের মতো `Box<T>` ব্যবহার করা

আমরা Listing 15-6-এর কোডটিকে রেফারেন্সের পরিবর্তে `Box<T>` ব্যবহার করার জন্য পুনরায় লিখতে পারি; Listing 15-7-এ `Box<T>`-এর উপর ব্যবহৃত ডিরেফারেন্স অপারেটর Listing 15-6-এ রেফারেন্সের উপর ব্যবহৃত ডিরেফারেন্স অপারেটরের মতোই কাজ করে:

<Listing number="15-7" file-name="src/main.rs" caption="একটি `Box<i32>`-এর উপর ডিরেফারেন্স অপারেটর ব্যবহার করা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-07/src/main.rs}}
```

</Listing>

Listing 15-7 এবং Listing 15-6-এর মধ্যে প্রধান পার্থক্য হল এখানে আমরা `y`-কে `x`-এর ভ্যালুর রেফারেন্স পয়েন্ট করার পরিবর্তে `x`-এর একটি কপি করা ভ্যালু পয়েন্ট করে এমন একটি `Box<T>`-এর উদাহরণ হিসেবে সেট করি। শেষ অ্যাসারশনে, `Box<T>`-এর পয়েন্টার অনুসরণ করতে আমরা ডিরেফারেন্স অপারেটর ব্যবহার করতে পারি, ঠিক যেমনটি আমরা করেছিলাম যখন `y` একটি রেফারেন্স ছিল। এরপর, আমরা আলোচনা করব `Box<T>` সম্পর্কে যা আমাদের নিজস্ব টাইপ সংজ্ঞায়িত করে ডিরেফারেন্স অপারেটর ব্যবহার করতে সক্ষম করে।

### আমাদের নিজস্ব স্মার্ট পয়েন্টার সংজ্ঞায়িত করা

আসুন স্ট্যান্ডার্ড লাইব্রেরি দ্বারা প্রদত্ত `Box<T>` টাইপের মতো একটি স্মার্ট পয়েন্টার তৈরি করি যাতে স্মার্ট পয়েন্টারগুলি ডিফল্টভাবে রেফারেন্স থেকে কীভাবে আলাদা আচরণ করে তা অনুভব করা যায়। তারপরে আমরা ডিরেফারেন্স অপারেটর ব্যবহার করার ক্ষমতা যুক্ত করার উপায় দেখব।

`Box<T>` টাইপটি মূলত একটি উপাদান সহ একটি টাপল স্ট্রাক্ট হিসাবে সংজ্ঞায়িত করা হয়েছে, তাই Listing 15-8 একইভাবে একটি `MyBox<T>` টাইপ সংজ্ঞায়িত করে। আমরা `Box<T>`-এ সংজ্ঞায়িত `new` ফাংশনের সাথে মিল রাখার জন্য একটি `new` ফাংশনও সংজ্ঞায়িত করব।

<Listing number="15-8" file-name="src/main.rs" caption="একটি `MyBox<T>` টাইপ সংজ্ঞায়িত করা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-08/src/main.rs:here}}
```

</Listing>

আমরা `MyBox` নামের একটি স্ট্রাক্ট সংজ্ঞায়িত করি এবং একটি জেনেরিক প্যারামিটার `T` ঘোষণা করি, কারণ আমরা চাই আমাদের টাইপ যেন যেকোনো টাইপের ভ্যালু ধরে রাখতে পারে। `MyBox` টাইপটি `T` টাইপের একটি উপাদান সহ একটি টাপল স্ট্রাক্ট। `MyBox::new` ফাংশনটি `T` টাইপের একটি প্যারামিটার নেয় এবং একটি `MyBox` উদাহরণ রিটার্ন করে যা ভিতরে পাস করা ভ্যালু ধরে রাখে।

আসুন Listing 15-7-এর `main` ফাংশনটি Listing 15-8-এ যোগ করার চেষ্টা করি এবং `Box<T>`-এর পরিবর্তে আমরা সংজ্ঞায়িত করা `MyBox<T>` টাইপ ব্যবহার করার জন্য এটিকে পরিবর্তন করি। Listing 15-9-এর কোডটি কম্পাইল হবে না কারণ Rust জানে না কিভাবে `MyBox`-কে ডিরেফারেন্স করতে হয়।

<Listing number="15-9" file-name="src/main.rs" caption="`MyBox<T>`-কে সেইভাবে ব্যবহার করার চেষ্টা করছি যেভাবে আমরা রেফারেন্স এবং `Box<T>` ব্যবহার করতাম">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-09/src/main.rs:here}}
```

</Listing>

এখানে কম্পাইলেশন এরর দেওয়া হলো:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-09/output.txt}}
```

আমাদের `MyBox<T>` টাইপ ডিরেফারেন্স করা যাবে না কারণ আমরা আমাদের টাইপে সেই ক্ষমতা প্রয়োগ করিনি। `*` অপারেটর দিয়ে ডিরেফারেন্সিং সক্ষম করতে, আমরা `Deref` trait প্রয়োগ করি।

### `Deref` Trait প্রয়োগ করার মাধ্যমে একটি টাইপকে রেফারেন্সের মতো ব্যবহার করা

অধ্যায় 10-এর [“একটি টাইপের উপর একটি Trait প্রয়োগ করা”][impl-trait]<!-- ignore --> বিভাগে আলোচনা করা হয়েছে, একটি trait প্রয়োগ করতে, আমাদের trait-এর প্রয়োজনীয় পদ্ধতির জন্য বাস্তবায়ন প্রদান করতে হবে। স্ট্যান্ডার্ড লাইব্রেরি দ্বারা প্রদত্ত `Deref` trait-এর জন্য আমাদের `deref` নামের একটি পদ্ধতি প্রয়োগ করতে হবে যা `self`-কে ধার করে এবং ভিতরের ডেটার একটি রেফারেন্স প্রদান করে। Listing 15-10-এ `MyBox` সংজ্ঞায় যোগ করার জন্য `Deref`-এর একটি প্রয়োগ রয়েছে:

<Listing number="15-10" file-name="src/main.rs" caption="`MyBox<T>`-এর উপর `Deref` প্রয়োগ করা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-10/src/main.rs:here}}
```

</Listing>

`type Target = T;` সিনট্যাক্স `Deref` trait ব্যবহার করার জন্য একটি অ্যাসোসিয়েটেড টাইপ সংজ্ঞায়িত করে। অ্যাসোসিয়েটেড টাইপগুলি জেনেরিক প্যারামিটার ঘোষণার একটি সামান্য ভিন্ন উপায়, তবে আপাতত আপনাকে সেগুলি নিয়ে চিন্তা করতে হবে না; আমরা সেগুলি অধ্যায় 20-এ আরও বিস্তারিতভাবে আলোচনা করব।

আমরা `deref` পদ্ধতির বডি `&self.0` দিয়ে পূরণ করি, যাতে `deref` সেই ভ্যালুটির একটি রেফারেন্স রিটার্ন করে যা আমরা `*` অপারেটর দিয়ে অ্যাক্সেস করতে চাই; অধ্যায় 5-এর [“বিভিন্ন টাইপ তৈরি করার জন্য নামবিহীন ফিল্ড সহ টাপল স্ট্রাক্ট ব্যবহার করা”][tuple-structs]<!-- ignore --> বিভাগ থেকে মনে করুন যে `.0` একটি টাপল স্ট্রাক্টের প্রথম ভ্যালু অ্যাক্সেস করে। Listing 15-9-এর `main` ফাংশন যা `MyBox<T>` ভ্যালুতে `*` কল করে, এখন কম্পাইল হয় এবং অ্যাসারশনগুলো পাস হয়!

`Deref` trait ছাড়া, কম্পাইলার শুধুমাত্র `&` রেফারেন্সগুলোকে ডিরেফারেন্স করতে পারে। `deref` পদ্ধতি কম্পাইলারকে `Deref` প্রয়োগ করে এমন যেকোনো টাইপের একটি ভ্যালু নিতে এবং একটি `&` রেফারেন্স পেতে `deref` পদ্ধতি কল করার ক্ষমতা দেয় যা এটি ডিরেফারেন্স করতে জানে।

যখন আমরা Listing 15-9-এ `*y` লিখি, তখন Rust আসলে ব্যাকগ্রাউন্ডে এই কোডটি চালায়:

```rust,ignore
*(y.deref())
```

Rust `*` অপারেটরের পরিবর্তে `deref` পদ্ধতিতে কল করে এবং তারপর একটি সাধারণ ডিরেফারেন্স করে, তাই আমাদের `deref` পদ্ধতি কল করার প্রয়োজন আছে কিনা তা নিয়ে ভাবতে হয় না। এই Rust বৈশিষ্ট্যটি আমাদের এমন কোড লিখতে দেয় যা আমরা একটি সাধারণ রেফারেন্স বা `Deref` প্রয়োগ করে এমন একটি টাইপ ব্যবহার করি কিনা তা নির্বিশেষে একই রকম কাজ করে।

`deref` পদ্ধতি একটি ভ্যালুর রেফারেন্স রিটার্ন করার কারণ, এবং `*(y.deref())`-এ প্যারেন্থেসিসের বাইরের সাধারণ ডিরেফারেন্স এখনও প্রয়োজনীয়, এর কারণ হল মালিকানা সিস্টেমের সাথে এর সম্পর্ক। যদি `deref` পদ্ধতি ভ্যালুর রেফারেন্সের পরিবর্তে সরাসরি ভ্যালু রিটার্ন করত, তাহলে ভ্যালুটি `self` থেকে সরিয়ে নেওয়া হত। আমরা এই ক্ষেত্রে বা বেশিরভাগ ক্ষেত্রে যেখানে আমরা ডিরেফারেন্স অপারেটর ব্যবহার করি, সেখানে `MyBox<T>`-এর ভিতরের ভ্যালুর মালিকানা নিতে চাই না।

লক্ষ্য করুন যে `*` অপারেটরটি `deref` পদ্ধতিতে কল এবং তারপর `*` অপারেটরের কলে প্রতিস্থাপিত হয়, প্রত্যেকবার যখন আমরা আমাদের কোডে `*` ব্যবহার করি। যেহেতু `*` অপারেটরের প্রতিস্থাপন অসীমভাবে পুনরাবৃত্তি হয় না, তাই আমরা `i32` টাইপের ডেটা পাই, যা Listing 15-9-এ `assert_eq!`-এ `5`-এর সাথে মিলে যায়।

### ফাংশন এবং পদ্ধতির সাথে অন্তর্নিহিত ডিরেফ কোয়েরশন

_ডিরেফ কোয়েরশন_ একটি টাইপের রেফারেন্সকে `Deref` trait প্রয়োগ করে এমন অন্য টাইপের রেফারেন্সে রূপান্তরিত করে। উদাহরণস্বরূপ, ডিরেফ কোয়েরশন `&String`-কে `&str`-এ রূপান্তর করতে পারে কারণ `String` `Deref` trait প্রয়োগ করে যা `&str` রিটার্ন করে। ডিরেফ কোয়েরশন হল একটি সুবিধা যা Rust ফাংশন এবং পদ্ধতির আর্গুমেন্টগুলিতে প্রয়োগ করে এবং এটি শুধুমাত্র `Deref` trait প্রয়োগ করে এমন টাইপগুলির উপর কাজ করে। যখন আমরা একটি ফাংশন বা পদ্ধতির সংজ্ঞায় প্যারামিটার টাইপের সাথে মেলে না এমন একটি ফাংশন বা পদ্ধতিতে একটি নির্দিষ্ট টাইপের ভ্যালুর রেফারেন্স আর্গুমেন্ট হিসাবে পাস করি তখন এটি স্বয়ংক্রিয়ভাবে ঘটে। `deref` পদ্ধতিতে কল করার একটি ক্রম আমাদের দেওয়া টাইপটিকে প্যারামিটারের প্রয়োজনীয় টাইপে রূপান্তর করে।

Rust-এ ডিরেফ কোয়েরশন যোগ করা হয়েছে যাতে ফাংশন এবং মেথড কল লেখার প্রোগ্রামারদের `&` এবং `*` দিয়ে অনেক বেশি স্পষ্ট রেফারেন্স এবং ডিরেফারেন্স যোগ করার প্রয়োজন না হয়। ডিরেফ কোয়েরশন বৈশিষ্ট্যটি আমাদের আরও কোড লিখতে দেয় যা রেফারেন্স বা স্মার্ট পয়েন্টার উভয়ের জন্যই কাজ করতে পারে।

ডিরেফ কোয়েরশন বাস্তবে দেখতে, আসুন আমরা Listing 15-8-এ সংজ্ঞায়িত `MyBox<T>` টাইপ এবং Listing 15-10-এ যোগ করা `Deref`-এর প্রয়োগ ব্যবহার করি। Listing 15-11 একটি ফাংশনের সংজ্ঞা দেখায় যেখানে একটি স্ট্রিং স্লাইস প্যারামিটার রয়েছে:

<Listing number="15-11" file-name="src/main.rs" caption="একটি `hello` ফাংশন যেখানে প্যারামিটার `name` -এর টাইপ `&str`">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-11/src/main.rs:here}}
```

</Listing>

আমরা একটি স্ট্রিং স্লাইস আর্গুমেন্ট যেমন, `hello("Rust");` দিয়ে `hello` ফাংশন কল করতে পারি। ডিরেফ কোয়েরশন `MyBox<String>` টাইপের একটি ভ্যালুর রেফারেন্স সহ `hello` কল করা সম্ভব করে, যেমনটি Listing 15-12-এ দেখানো হয়েছে:

<Listing number="15-12" file-name="src/main.rs" caption="একটি `MyBox<String>` ভ্যালুর রেফারেন্স দিয়ে `hello` কল করা, যা ডিরেফ কোয়েরশনের কারণে কাজ করে">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-12/src/main.rs:here}}
```

</Listing>

এখানে আমরা `hello` ফাংশনটি `&m` আর্গুমেন্ট দিয়ে কল করছি, যা একটি `MyBox<String>` ভ্যালুর রেফারেন্স। যেহেতু আমরা Listing 15-10-এ `MyBox<T>`-এ `Deref` trait প্রয়োগ করেছি, Rust `&MyBox<String>`-কে `deref` কল করে `&String`-এ রূপান্তর করতে পারে। স্ট্যান্ডার্ড লাইব্রেরি `String`-এ `Deref`-এর একটি প্রয়োগ প্রদান করে যা একটি স্ট্রিং স্লাইস রিটার্ন করে এবং এটি `Deref`-এর API ডকুমেন্টেশনে রয়েছে। Rust `&String`-কে `&str`-এ পরিণত করতে আবার `deref` কল করে, যা `hello` ফাংশনের সংজ্ঞার সাথে মিলে যায়।

যদি Rust ডিরেফ কোয়েরশন প্রয়োগ না করত, তাহলে `&MyBox<String>` টাইপের একটি ভ্যালু দিয়ে `hello` কল করতে Listing 15-12-এর কোডের পরিবর্তে Listing 15-13-এর কোড লিখতে হত।

<Listing number="15-13" file-name="src/main.rs" caption="যদি Rust-এর ডিরেফ কোয়েরশন না থাকত তাহলে আমাদের এই কোড লিখতে হত">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-13/src/main.rs:here}}
```

</Listing>

`(*m)` `MyBox<String>`-কে ডিরেফারেন্স করে একটি `String`-এ পরিণত করে। তারপর `&` এবং `[..]` `String`-এর একটি স্ট্রিং স্লাইস নেয় যা `hello`-এর সিগনেচারের সাথে মেলানোর জন্য পুরো স্ট্রিংটির সমান। ডিরেফ কোয়েরশন ছাড়া এই কোডটি এই সমস্ত চিহ্নগুলির সাথে পড়া, লেখা এবং বোঝা কঠিন। ডিরেফ কোয়েরশন Rust-কে আমাদের জন্য স্বয়ংক্রিয়ভাবে এই রূপান্তরগুলি পরিচালনা করতে দেয়।

যখন জড়িত টাইপগুলির জন্য `Deref` trait সংজ্ঞায়িত করা হয়, তখন Rust টাইপগুলি বিশ্লেষণ করবে এবং প্যারামিটারের টাইপের সাথে মেলে এমন একটি রেফারেন্স পেতে যতবার প্রয়োজন ততবার `Deref::deref` ব্যবহার করবে। `Deref::deref` কতবার যোগ করতে হবে তা কম্পাইল করার সময় সমাধান করা হয়, তাই ডিরেফ কোয়েরশনের সুবিধা নেওয়ার জন্য কোনো রানটাইম জরিমানা নেই!

### মিউটেবিলিটির সাথে ডিরেফ কোয়েরশন কিভাবে কাজ করে

ঠিক যেভাবে আপনি অপরিবর্তনযোগ্য রেফারেন্সের উপর `*` অপারেটরটিকে ওভাররাইড করতে `Deref` trait ব্যবহার করেন, তেমনি আপনি পরিবর্তনযোগ্য রেফারেন্সের উপর `*` অপারেটরটিকে ওভাররাইড করতে `DerefMut` trait ব্যবহার করতে পারেন।

Rust তিনটি ক্ষেত্রে টাইপ এবং trait বাস্তবায়ন খুঁজে পেলে ডিরেফ কোয়েরশন করে:

- `&T` থেকে `&U`-এ যখন `T: Deref<Target=U>`
- `&mut T` থেকে `&mut U`-এ যখন `T: DerefMut<Target=U>`
- `&mut T` থেকে `&U`-এ যখন `T: Deref<Target=U>`

প্রথম দুটি ক্ষেত্র একে অপরের মতোই, শুধু দ্বিতীয়টি পরিবর্তনযোগ্যতা প্রয়োগ করে। প্রথম ক্ষেত্রটি বলছে যে যদি আপনার কাছে একটি `&T` থাকে এবং `T` কিছু টাইপ `U`-এর জন্য `Deref` প্রয়োগ করে, তাহলে আপনি স্বচ্ছভাবে একটি `&U` পেতে পারেন। দ্বিতীয় ক্ষেত্রটি বলছে যে একই ডিরেফ কোয়েরশন পরিবর্তনযোগ্য রেফারেন্সের জন্য ঘটে।

তৃতীয় ক্ষেত্রটি আরও জটিল: Rust একটি পরিবর্তনযোগ্য রেফারেন্সকে একটি অপরিবর্তনযোগ্য রেফারেন্সেও বাধ্য করবে। কিন্তু বিপরীতটি সম্ভব _নয়_: অপরিবর্তনযোগ্য রেফারেন্সগুলি কখনই পরিবর্তনযোগ্য রেফারেন্সে বাধ্য করবে না। ধার করার নিয়মগুলির কারণে, যদি আপনার কাছে একটি পরিবর্তনযোগ্য রেফারেন্স থাকে, তবে সেই পরিবর্তনযোগ্য রেফারেন্সটি সেই ডেটার একমাত্র রেফারেন্স হতে হবে (অন্যথায়, প্রোগ্রামটি কম্পাইল হবে না)। একটি পরিবর্তনযোগ্য রেফারেন্সকে একটি অপরিবর্তনযোগ্য রেফারেন্সে রূপান্তর করলে ধার করার নিয়ম ভাঙবে না। একটি অপরিবর্তনযোগ্য রেফারেন্সকে পরিবর্তনযোগ্য রেফারেন্সে রূপান্তর করার জন্য প্রয়োজন হবে যে প্রাথমিক অপরিবর্তনযোগ্য রেফারেন্সটি সেই ডেটার একমাত্র অপরিবর্তনযোগ্য রেফারেন্স, কিন্তু ধার করার নিয়মগুলি এটির নিশ্চয়তা দেয় না। অতএব, Rust এই অনুমান করতে পারে না যে একটি অপরিবর্তনযোগ্য রেফারেন্সকে পরিবর্তনযোগ্য রেফারেন্সে রূপান্তর করা সম্ভব।

[impl-trait]: ch10-02-traits.html#implementing-a-trait-on-a-type
[tuple-structs]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types
