## হ্যালো, কার্গো!

কার্গো হল Rust এর বিল্ড সিস্টেম এবং প্যাকেজ ম্যানেজার। বেশিরভাগ Rustaceans তাদের Rust প্রোজেক্টগুলি পরিচালনা করতে এই সরঞ্জামটি ব্যবহার করে কারণ কার্গো আপনার জন্য অনেক কাজ পরিচালনা করে, যেমন আপনার কোড তৈরি করা, আপনার কোড যে লাইব্রেরিগুলির উপর নির্ভর করে সেগুলি ডাউনলোড করা এবং সেই লাইব্রেরিগুলি তৈরি করা। (আমরা যে লাইব্রেরিগুলির আপনার কোডের প্রয়োজন সেগুলিকে _নির্ভরতা_ বলি।)

সহজ Rust প্রোগ্রামগুলি, যেমন আমরা এখন পর্যন্ত যা লিখেছি, তার কোনো নির্ভরতা নেই। আমরা যদি কার্গো দিয়ে "Hello, world!" প্রোজেক্ট তৈরি করতাম, তবে এটি শুধুমাত্র কার্গোর সেই অংশটি ব্যবহার করত যা আপনার কোড তৈরি করে। আপনি আরও জটিল Rust প্রোগ্রাম লেখার সাথে সাথে, আপনি নির্ভরতা যোগ করবেন এবং আপনি যদি কার্গো ব্যবহার করে একটি প্রোজেক্ট শুরু করেন, তবে নির্ভরতা যোগ করা অনেক সহজ হবে।

যেহেতু Rust প্রোজেক্টের বিশাল সংখ্যাগরিষ্ঠ কার্গো ব্যবহার করে, তাই এই বইটির বাকি অংশে ধরে নেওয়া হয়েছে যে আপনিও কার্গো ব্যবহার করছেন। আপনি যদি [ "ইনস্টলেশন" ] [installation] বিভাগে আলোচিত অফিসিয়াল ইনস্টলার ব্যবহার করেন, তবে কার্গো Rust এর সাথে ইনস্টল হয়ে আসে। যদি আপনি অন্য কোনো উপায়ে Rust ইনস্টল করেন, তবে আপনার টার্মিনালে নিম্নলিখিতটি প্রবেশ করে কার্গো ইনস্টল করা আছে কিনা তা পরীক্ষা করুন:

```console
$ cargo --version
```

যদি আপনি একটি সংস্করণ নম্বর দেখেন তবে আপনার কাছে এটি আছে! আপনি যদি `command not found` এর মতো কোনো এরর দেখেন তবে, কার্গোকে আলাদাভাবে ইনস্টল করার জন্য আপনার ইনস্টলেশন পদ্ধতির ডকুমেন্টেশন দেখুন।

### কার্গো দিয়ে একটি প্রোজেক্ট তৈরি করা

আসুন কার্গো ব্যবহার করে একটি নতুন প্রোজেক্ট তৈরি করি এবং দেখি এটি আমাদের আসল "Hello, world!" প্রোজেক্ট থেকে কীভাবে আলাদা। আপনার _projects_ ডিরেক্টরিতে ফিরে যান (বা আপনি যেখানে আপনার কোড সংরক্ষণ করার সিদ্ধান্ত নিয়েছেন)। তারপর, যেকোনো অপারেটিং সিস্টেমে, নিম্নলিখিতটি চালান:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

প্রথম কমান্ডটি _hello_cargo_ নামে একটি নতুন ডিরেক্টরি এবং প্রোজেক্ট তৈরি করে। আমরা আমাদের প্রোজেক্টের নাম _hello_cargo_ দিয়েছি এবং কার্গো একই নামে একটি ডিরেক্টরিতে এর ফাইলগুলি তৈরি করে।

_hello_cargo_ ডিরেক্টরিতে প্রবেশ করুন এবং ফাইলগুলির তালিকা দিন। আপনি দেখতে পাবেন যে কার্গো আমাদের জন্য দুটি ফাইল এবং একটি ডিরেক্টরি তৈরি করেছে: একটি _Cargo.toml_ ফাইল এবং _src_ ডিরেক্টরির ভিতরে একটি _main.rs_ ফাইল।

এটি একটি _.gitignore_ ফাইল সহ একটি নতুন Git রিপোজিটরিও শুরু করেছে। আপনি যদি একটি বিদ্যমান Git রিপোজিটরির মধ্যে `cargo new` চালান তবে Git ফাইল তৈরি হবে না; `cargo new --vcs=git` ব্যবহার করে আপনি এই আচরণ পরিবর্তন করতে পারেন।

> দ্রষ্টব্য: Git হল একটি সাধারণ সংস্করণ নিয়ন্ত্রণ ব্যবস্থা। আপনি `--vcs` ফ্ল্যাগ ব্যবহার করে একটি ভিন্ন সংস্করণ নিয়ন্ত্রণ ব্যবস্থা ব্যবহার করতে বা কোনো সংস্করণ নিয়ন্ত্রণ ব্যবস্থা ব্যবহার না করতে `cargo new` পরিবর্তন করতে পারেন। উপলব্ধ বিকল্পগুলি দেখতে `cargo new --help` চালান।

আপনার পছন্দের টেক্সট এডিটরে _Cargo.toml_ খুলুন। এটি তালিকা 1-2-এর কোডের মতো হওয়া উচিত।

<Listing number="1-2" file-name="Cargo.toml" caption="`cargo new` দ্বারা তৈরি *Cargo.toml* এর বিষয়বস্তু">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

</Listing>

এই ফাইলটি [_TOML_][toml] (_টম'স অভিয়াস, মিনিমাল ল্যাঙ্গুয়েজ_) ফর্ম্যাটে আছে, যা কার্গোর কনফিগারেশন ফর্ম্যাট।

প্রথম লাইন, `[package]`, একটি বিভাগ শিরোনাম যা নির্দেশ করে যে নিম্নলিখিত স্টেটমেন্টগুলি একটি প্যাকেজ কনফিগার করছে। আমরা যখন এই ফাইলে আরও তথ্য যোগ করব, তখন আমরা অন্যান্য বিভাগ যোগ করব।

পরের তিনটি লাইন কার্গোকে আপনার প্রোগ্রাম কম্পাইল করার জন্য প্রয়োজনীয় কনফিগারেশন তথ্য সেট করে: নাম, সংস্করণ এবং Rust-এর সংস্করণ ব্যবহার করতে। আমরা [পরিশিষ্ট E][appendix-e]-এ `edition` কী নিয়ে কথা বলব।

শেষ লাইন, `[dependencies]`, আপনার প্রোজেক্টের কোনো নির্ভরতা তালিকাভুক্ত করার জন্য একটি বিভাগের শুরু। Rust-এ, কোডের প্যাকেজগুলিকে _ক্রেইটস_ হিসাবে উল্লেখ করা হয়। এই প্রোজেক্টের জন্য আমাদের অন্য কোনো ক্রেইটের প্রয়োজন হবে না, তবে আমরা দ্বিতীয় অধ্যায়ের প্রথম প্রোজেক্টে ব্যবহার করব, তাই আমরা তখন এই নির্ভরতা বিভাগটি ব্যবহার করব।

এখন _src/main.rs_ খুলুন এবং একবার দেখে নিন:

<span class="filename">Filename: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

কার্গো আপনার জন্য একটি "Hello, world!" প্রোগ্রাম তৈরি করেছে, ঠিক যেমনটি আমরা তালিকা 1-1 এ লিখেছিলাম! এখন পর্যন্ত, আমাদের প্রোজেক্ট এবং কার্গো দ্বারা জেনারেট করা প্রোজেক্টের মধ্যে পার্থক্য হল যে কার্গো কোডটিকে _src_ ডিরেক্টরিতে রেখেছে এবং আমাদের শীর্ষ ডিরেক্টরিতে একটি _Cargo.toml_ কনফিগারেশন ফাইল রয়েছে।

কার্গো আশা করে যে আপনার সোর্স ফাইলগুলি _src_ ডিরেক্টরির ভিতরে থাকবে। টপ-লেভেল প্রোজেক্ট ডিরেক্টরি শুধুমাত্র README ফাইল, লাইসেন্সের তথ্য, কনফিগারেশন ফাইল এবং আপনার কোডের সাথে সম্পর্কিত নয় এমন অন্য যেকোনো কিছুর জন্য। কার্গো ব্যবহার করা আপনাকে আপনার প্রোজেক্টগুলিকে সংগঠিত করতে সাহায্য করে। এখানে সবকিছু জন্য একটি স্থান আছে এবং সবকিছু তার স্থানে আছে।

আপনি যদি কোনো প্রোজেক্ট শুরু করেন যা কার্গো ব্যবহার করে না, যেমনটি আমরা "Hello, world!" প্রোজেক্টের সাথে করেছিলাম, তবে আপনি এটিকে কার্গো ব্যবহার করে এমন একটি প্রোজেক্টে রূপান্তর করতে পারেন। প্রোজেক্ট কোডটি _src_ ডিরেক্টরিতে সরান এবং একটি উপযুক্ত _Cargo.toml_ ফাইল তৈরি করুন। _Cargo.toml_ ফাইল পাওয়ার একটি সহজ উপায় হল `cargo init` চালানো, যা স্বয়ংক্রিয়ভাবে আপনার জন্য এটি তৈরি করবে।

### একটি কার্গো প্রোজেক্ট তৈরি এবং চালানো

এখন আসুন দেখি কার্গোর সাথে "Hello, world!" প্রোগ্রামটি তৈরি এবং চালানোর সময় কী পার্থক্য রয়েছে! আপনার _hello_cargo_ ডিরেক্টরি থেকে, নিম্নলিখিত কমান্ডটি প্রবেশ করে আপনার প্রোজেক্টটি তৈরি করুন:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

এই কমান্ডটি আপনার বর্তমান ডিরেক্টরির পরিবর্তে _target/debug/hello_cargo_ (_target\debug\hello_cargo.exe_ on Windows) এ একটি এক্সিকিউটেবল ফাইল তৈরি করে। যেহেতু ডিফল্ট বিল্ড হল একটি ডিবাগ বিল্ড, কার্গো বাইনারিটিকে _debug_ নামের একটি ডিরেক্টরিতে রাখে। আপনি এই কমান্ডের মাধ্যমে এক্সিকিউটেবলটি চালাতে পারেন:

```console
$ ./target/debug/hello_cargo # অথবা Windows-এ .\target\debug\hello_cargo.exe
Hello, world!
```

যদি সবকিছু ঠিকঠাক থাকে, `Hello, world!` টার্মিনালে প্রিন্ট হওয়া উচিত। প্রথমবারের জন্য `cargo build` চালানোর কারণে কার্গো টপ লেভেলে একটি নতুন ফাইল তৈরি করে: _Cargo.lock_। এই ফাইলটি আপনার প্রোজেক্টের নির্ভরতার সঠিক সংস্করণ ট্র্যাক করে। এই প্রোজেক্টের কোনো নির্ভরতা নেই, তাই ফাইলটি কিছুটা হালকা। আপনাকে কখনই এই ফাইলটি ম্যানুয়ালি পরিবর্তন করার প্রয়োজন হবে না; কার্গো আপনার জন্য এর বিষয়বস্তু পরিচালনা করে।

আমরা এইমাত্র `cargo build` দিয়ে একটি প্রোজেক্ট তৈরি করেছি এবং `./target/debug/hello_cargo` দিয়ে রান করেছি, তবে আমরা কোড কম্পাইল করতে এবং তারপর ফলাফলস্বরূপ এক্সিকিউটেবলটিকে একটি কমান্ডে রান করতে `cargo run`-ও ব্যবহার করতে পারি:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

`cargo run` ব্যবহার করা `cargo build` চালানো এবং তারপর বাইনারির পুরো পাথ ব্যবহার করার চেয়ে অনেক বেশি সুবিধাজনক, তাই বেশিরভাগ ডেভেলপার `cargo run` ব্যবহার করেন।

লক্ষ্য করুন যে এইবার আমরা কোনো আউটপুট দেখিনি যা নির্দেশ করে যে কার্গো `hello_cargo` কম্পাইল করছে। কার্গো বুঝতে পেরেছিল যে ফাইলগুলি পরিবর্তন হয়নি, তাই এটি পুনরায় তৈরি করেনি, তবে বাইনারিটি রান করেছে। আপনি যদি আপনার সোর্স কোড পরিবর্তন করতেন, তবে কার্গো রান করার আগে প্রোজেক্টটি পুনরায় তৈরি করত এবং আপনি এই আউটপুটটি দেখতে পেতেন:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

কার্গো `cargo check` নামে একটি কমান্ডও প্রদান করে। এই কমান্ডটি দ্রুত আপনার কোড চেক করে, যাতে এটি কম্পাইল হয় কিনা তা নিশ্চিত করা যায়, তবে এটি কোনো এক্সিকিউটেবল তৈরি করে না:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

কেন আপনি একটি এক্সিকিউটেবল চাইবেন না? প্রায়শই, `cargo check`, `cargo build` এর চেয়ে অনেক দ্রুত কারণ এটি একটি এক্সিকিউটেবল তৈরির ধাপটি এড়িয়ে যায়। আপনি যখন কোড লেখার সময় ক্রমাগত আপনার কাজ পরীক্ষা করেন, তখন `cargo check` ব্যবহার করলে আপনার প্রোজেক্ট কম্পাইল হচ্ছে কিনা তা আপনাকে জানাতে প্রক্রিয়াটিকে দ্রুততর করবে! সেই কারণে, অনেক Rustacean তাদের প্রোগ্রাম লেখার সময় পর্যায়ক্রমে `cargo check` চালান, যাতে এটি কম্পাইল হচ্ছে কিনা তা নিশ্চিত করা যায়। তারপর যখন তারা এক্সিকিউটেবল ব্যবহার করার জন্য প্রস্তুত হন তখন তারা `cargo build` চালান।

আসুন কার্গো সম্পর্কে এখন পর্যন্ত আমরা যা শিখেছি তা পুনরায় দেখি:

- আমরা `cargo new` ব্যবহার করে একটি প্রোজেক্ট তৈরি করতে পারি।
- আমরা `cargo build` ব্যবহার করে একটি প্রোজেক্ট তৈরি করতে পারি।
- আমরা `cargo run` ব্যবহার করে একটি ধাপে একটি প্রোজেক্ট তৈরি করতে এবং রান করতে পারি।
- আমরা `cargo check` ব্যবহার করে এরর চেক করার জন্য বাইনারি তৈরি না করেই একটি প্রোজেক্ট তৈরি করতে পারি।
- আমাদের কোডের মতো একই ডিরেক্টরিতে বিল্ডের ফলাফল সংরক্ষণ করার পরিবর্তে কার্গো এটিকে _target/debug_ ডিরেক্টরিতে সংরক্ষণ করে।

কার্গো ব্যবহারের অতিরিক্ত সুবিধা হল কমান্ডগুলি আপনি যে অপারেটিং সিস্টেমেই কাজ করেন না কেন একই থাকে। সুতরাং, এই সময়ে, আমরা Linux এবং macOS বনাম Windows-এর জন্য নির্দিষ্ট নির্দেশাবলী আর প্রদান করব না।

### রিলিজের জন্য তৈরি করা

যখন আপনার প্রোজেক্ট অবশেষে রিলিজের জন্য প্রস্তুত হয়ে যায়, তখন আপনি অপটিমাইজেশন সহ কম্পাইল করার জন্য `cargo build --release` ব্যবহার করতে পারেন। এই কমান্ডটি _target/debug_ এর পরিবর্তে _target/release_ এ একটি এক্সিকিউটেবল তৈরি করবে। অপটিমাইজেশনগুলি আপনার Rust কোডকে দ্রুত রান করতে সাহায্য করে, তবে সেগুলিকে চালু করলে আপনার প্রোগ্রামটি কম্পাইল করার জন্য যে সময় লাগে তা দীর্ঘ হয়। এই কারণে দুটি ভিন্ন প্রোফাইল রয়েছে: একটি ডেভেলপমেন্টের জন্য, যখন আপনি দ্রুত এবং প্রায়শই পুনরায় তৈরি করতে চান, এবং অন্যটি চূড়ান্ত প্রোগ্রাম তৈরি করার জন্য যা আপনি এমন ব্যবহারকারীকে দেবেন যা বারবার পুনরায় তৈরি করা হবে না এবং যত দ্রুত সম্ভব রান হবে। আপনি যদি আপনার কোডের রানিং টাইমের বেঞ্চমার্কিং করছেন, তাহলে `cargo build --release` এবং _target/release_-এর এক্সিকিউটেবল দিয়ে বেঞ্চমার্ক করতে ভুলবেন না।

### কনভেনশন হিসাবে কার্গো

সহজ প্রোজেক্টগুলির সাথে, কার্গো শুধুমাত্র `rustc` ব্যবহার করার চেয়ে বেশি সুবিধা দেয় না, তবে আপনার প্রোগ্রামগুলি আরও জটিল হওয়ার সাথে সাথে এটি তার মূল্য প্রমাণ করবে। একবার প্রোগ্রামগুলি একাধিক ফাইলে বৃদ্ধি পেলে বা একটি নির্ভরতার প্রয়োজন হলে, কার্গোকে বিল্ডের সমন্বয় করতে দেওয়া অনেক সহজ।

এমনকি যদিও `hello_cargo` প্রোজেক্টটি সহজ, তবে এটি এখন সেইসব সরঞ্জামের বেশিরভাগই ব্যবহার করে যা আপনি আপনার বাকি Rust ক্যারিয়ারে ব্যবহার করবেন। প্রকৃতপক্ষে, যেকোনো বিদ্যমান প্রোজেক্টে কাজ করার জন্য, আপনি Git ব্যবহার করে কোড চেক আউট করতে, সেই প্রোজেক্টের ডিরেক্টরিতে পরিবর্তন করতে এবং তৈরি করতে নিম্নলিখিত কমান্ডগুলি ব্যবহার করতে পারেন:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

কার্গো সম্পর্কে আরও তথ্যের জন্য, [এর ডকুমেন্টেশন][cargo] দেখুন।

## সারসংক্ষেপ

আপনি ইতিমধ্যে আপনার Rust যাত্রায় একটি দুর্দান্ত শুরু করেছেন! এই অধ্যায়ে, আপনি শিখেছেন কিভাবে:

- `rustup` ব্যবহার করে Rust-এর সর্বশেষ স্থিতিশীল সংস্করণ ইনস্টল করতে হয়
- Rust-এর নতুন সংস্করণে আপডেট করতে হয়
- স্থানীয়ভাবে ইনস্টল করা ডকুমেন্টেশন খুলতে হয়
- সরাসরি `rustc` ব্যবহার করে একটি "Hello, world!" প্রোগ্রাম লিখতে এবং চালাতে হয়
- কার্গোর নিয়ম ব্যবহার করে একটি নতুন প্রোজেক্ট তৈরি এবং রান করতে হয়

Rust কোড পড়া এবং লেখার সাথে অভ্যস্ত হওয়ার জন্য একটি আরও বড় প্রোগ্রাম তৈরি করার এটি একটি দুর্দান্ত সময়। সুতরাং, দ্বিতীয় অধ্যায়ে আমরা একটি সংখ্যা অনুমান করার গেম প্রোগ্রাম তৈরি করব। আপনি যদি Rust-এ সাধারণ প্রোগ্রামিং ধারণাগুলি কীভাবে কাজ করে তা শিখে শুরু করতে চান, তাহলে অধ্যায় 3 দেখুন এবং তারপর অধ্যায় 2-এ ফিরে আসুন।

[installation]: ch01-01-installation.html#installation
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.html
[cargo]: https://doc.rust-lang.org/cargo/
