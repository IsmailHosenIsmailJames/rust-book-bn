## হ্যালো, কার্গো!

কার্গো হলো রাস্টের বিল্ড সিস্টেম এবং প্যাকেজ ম্যানেজার। বেশিরভাগ রাস্টেশিয়ান (Rustaceans) এই টুলটি তাদের রাস্ট প্রজেক্ট পরিচালনার জন্য ব্যবহার করেন কারণ কার্গো আপনার জন্য অনেক কাজ করে দেয়, যেমন আপনার কোড বিল্ড করা, আপনার কোডের উপর নির্ভরশীল লাইব্রেরিগুলো ডাউনলোড করা এবং সেই লাইব্রেরিগুলো বিল্ড করা। (আমরা আপনার কোডের প্রয়োজনীয় লাইব্রেরিগুলোকে _dependencies_ বলি।)

সবচেয়ে সহজ রাস্ট প্রোগ্রামগুলোতে, যেমন আমরা এখন পর্যন্ত যেটি লিখেছি, কোনো dependencies থাকে না। যদি আমরা কার্গো দিয়ে "Hello, world!" প্রজেক্টটি তৈরি করতাম, তবে এটি কেবল কার্গোর সেই অংশটি ব্যবহার করত যা আপনার কোড বিল্ড করার কাজটি করে। যখন আপনি আরও জটিল রাস্ট প্রোগ্রাম লিখবেন, তখন আপনি dependencies যোগ করবেন, এবং যদি আপনি কার্গো ব্যবহার করে একটি প্রজেক্ট শুরু করেন, তবে dependencies যোগ করা অনেক সহজ হবে।

যেহেতু বিশাল সংখ্যক রাস্ট প্রজেক্ট কার্গো ব্যবহার করে, তাই এই বইয়ের বাকি অংশে ধরে নেওয়া হয়েছে যে আপনিও কার্গো ব্যবহার করছেন। আপনি যদি ["Installation"][installation]<!-- ignore --> বিভাগে আলোচিত অফিসিয়াল ইনস্টলারগুলো ব্যবহার করে থাকেন, তবে কার্গো রাস্টের সাথেই ইনস্টল হয়ে আসে। যদি আপনি অন্য কোনো উপায়ে রাস্ট ইনস্টল করে থাকেন, তবে আপনার টার্মিনালে নিম্নলিখিত কমান্ডটি প্রবেশ করিয়ে কার্গো ইনস্টল করা আছে কিনা তা পরীক্ষা করুন:

```console
$ cargo --version
```

আপনি যদি একটি ভার্সন নম্বর দেখতে পান, তাহলে আপনার কাছে এটি আছে! যদি আপনি `command not found` এর মতো কোনো এরর দেখতে পান, তাহলে কার্গো কীভাবে আলাদাভাবে ইনস্টল করতে হয় তা জানতে আপনার ইনস্টলেশন পদ্ধতির ডকুমেন্টেশন দেখুন।

### কার্গো দিয়ে একটি প্রজেক্ট তৈরি করা

আসুন, কার্গো ব্যবহার করে একটি নতুন প্রজেক্ট তৈরি করি এবং দেখি এটি আমাদের মূল "Hello, world!" প্রজেক্ট থেকে কীভাবে আলাদা। আপনার _projects_ ডিরেক্টরিতে (অথবা যেখানে আপনি আপনার কোড সংরক্ষণ করার সিদ্ধান্ত নিয়েছেন) ফিরে যান। তারপর, যেকোনো অপারেটিং সিস্টেমে, নিম্নলিখিত কমান্ড চালান:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

প্রথম কমান্ডটি _hello_cargo_ নামে একটি নতুন ডিরেক্টরি এবং প্রজেক্ট তৈরি করে। আমরা আমাদের প্রজেক্টের নাম দিয়েছি _hello_cargo_, এবং কার্গো একই নামের একটি ডিরেক্টরিতে এর ফাইলগুলো তৈরি করে।

_hello_cargo_ ডিরেক্টরিতে যান এবং ফাইলগুলো তালিকাভুক্ত করুন। আপনি দেখবেন যে কার্গো আমাদের জন্য দুটি ফাইল এবং একটি ডিরেক্টরি তৈরি করেছে: একটি _Cargo.toml_ ফাইল এবং একটি _src_ ডিরেক্টরি যার ভিতরে একটি _main.rs_ ফাইল রয়েছে।

এটি একটি _.gitignore_ ফাইলের সাথে একটি নতুন গিট রিপোজিটরিও ইনিশিয়ালাইজ করেছে। আপনি যদি একটি বিদ্যমান গিট রিপোজিটরির ভিতরে `cargo new` চালান তবে গিট ফাইল তৈরি হবে না; আপনি `cargo new --vcs=git` ব্যবহার করে এই আচরণটি পরিবর্তন করতে পারেন।

> দ্রষ্টব্য: গিট একটি সাধারণ ভার্সন কন্ট্রোল সিস্টেম। আপনি `--vcs` ফ্ল্যাগ ব্যবহার করে `cargo new` কে একটি ভিন্ন ভার্সন কন্ট্রোল সিস্টেম বা কোনো ভার্সন কন্ট্রোল সিস্টেম ব্যবহার না করার জন্য পরিবর্তন করতে পারেন। উপলব্ধ বিকল্পগুলো দেখতে `cargo new --help` চালান।

আপনার পছন্দের টেক্সট এডিটরে _Cargo.toml_ ফাইলটি খুলুন। এটি লিস্টিং ১-২ এর কোডের মতো দেখতে হওয়া উচিত।

<Listing number="1-2" file-name="Cargo.toml" caption="`cargo new` দ্বারা তৈরি *Cargo.toml* ফাইলের বিষয়বস্তু">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
```

</Listing>

এই ফাইলটি [_TOML_][toml]<!-- ignore --> (_Tom’s Obvious, Minimal Language_) ফরম্যাটে লেখা, যা কার্গোর কনফিগারেশন ফরম্যাট।

প্রথম লাইন, `[package]`, একটি সেকশন হেডিং যা নির্দেশ করে যে নিম্নলিখিত স্টেটমেন্টগুলো একটি প্যাকেজ কনফিগার করছে। আমরা এই ফাইলে আরও তথ্য যোগ করার সাথে সাথে অন্যান্য সেকশন যোগ করব।

পরবর্তী তিনটি লাইন আপনার প্রোগ্রাম কম্পাইল করার জন্য কার্গোর প্রয়োজনীয় কনফিগারেশন তথ্য সেট করে: নাম, ভার্সন এবং রাস্টের এডিশন যা ব্যবহার করতে হবে। আমরা [পরিশিষ্ট ই][appendix-e]<!-- ignore --> -তে `edition` কী সম্পর্কে কথা বলব।

শেষ লাইন, `[dependencies]`, আপনার প্রজেক্টের যেকোনো dependencies তালিকাভুক্ত করার জন্য একটি সেকশনের শুরু। রাস্ট-এ, কোডের প্যাকেজগুলোকে _crates_ বলা হয়। এই প্রজেক্টের জন্য আমাদের অন্য কোনো ক্রেটসের প্রয়োজন হবে না, তবে অধ্যায় ২-এর প্রথম প্রজেক্টে আমাদের প্রয়োজন হবে, তাই আমরা তখন এই dependencies সেকশনটি ব্যবহার করব।

এখন _src/main.rs_ খুলুন এবং একবার দেখুন:

<span class="filename">ফাইলের নাম: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

কার্গো আপনার জন্য একটি "Hello, world!" প্রোগ্রাম তৈরি করেছে, ঠিক যেমনটি আমরা লিস্টিং ১-১ এ লিখেছিলাম! এখন পর্যন্ত, আমাদের প্রজেক্ট এবং কার্গো দ্বারা তৈরি প্রজেক্টের মধ্যে পার্থক্য হলো কার্গো কোডটি _src_ ডিরেক্টরিতে রেখেছে এবং আমাদের টপ ডিরেক্টরিতে একটি _Cargo.toml_ কনফিগারেশন ফাইল রয়েছে।

কার্গো আশা করে যে আপনার সোর্স ফাইলগুলো _src_ ডিরেক্টরির ভিতরে থাকবে। টপ-লেভেল প্রজেক্ট ডিরেক্টরিটি শুধুমাত্র README ফাইল, লাইসেন্সের তথ্য, কনফিগারেশন ফাইল এবং আপনার কোডের সাথে সম্পর্কিত নয় এমন অন্য কিছুর জন্য। কার্গো ব্যবহার করা আপনাকে আপনার প্রজেক্টগুলো সংগঠিত করতে সাহায্য করে। সবকিছুর জন্য একটি জায়গা আছে, এবং সবকিছু তার জায়গায় আছে।

আপনি যদি এমন একটি প্রজেক্ট শুরু করেন যা কার্গো ব্যবহার করে না, যেমন আমরা "Hello, world!" প্রজেক্টের সাথে করেছি, আপনি এটিকে এমন একটি প্রজেক্টে রূপান্তর করতে পারেন যা কার্গো ব্যবহার করে। প্রজেক্ট কোডটি _src_ ডিরেক্টরিতে সরান এবং একটি উপযুক্ত _Cargo.toml_ ফাইল তৈরি করুন। সেই _Cargo.toml_ ফাইলটি পাওয়ার একটি সহজ উপায় হল `cargo init` চালানো, যা আপনার জন্য এটি স্বয়ংক্রিয়ভাবে তৈরি করবে।

### একটি কার্গো প্রজেক্ট বিল্ড এবং রান করা

এখন চলুন দেখি কার্গো দিয়ে "Hello, world!" প্রোগ্রামটি বিল্ড এবং রান করার সময় কী ভিন্ন হয়! আপনার _hello_cargo_ ডিরেক্টরি থেকে, নিম্নলিখিত কমান্ডটি প্রবেশ করে আপনার প্রজেক্টটি বিল্ড করুন:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

এই কমান্ডটি আপনার বর্তমান ডিরেক্টরির পরিবর্তে _target/debug/hello_cargo_ (অথবা Windows-এ _target\debug\hello_cargo.exe_) তে একটি এক্সিকিউটেবল ফাইল তৈরি করে। যেহেতু ডিফল্ট বিল্ডটি একটি ডিবাগ বিল্ড, কার্গো বাইনারিটিকে _debug_ নামের একটি ডিরেক্টরিতে রাখে। আপনি এই কমান্ড দিয়ে এক্সিকিউটেবলটি চালাতে পারেন:

```console
$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
```

যদি সবকিছু ঠিকঠাক চলে, `Hello, world!` টার্মিনালে প্রিন্ট হওয়া উচিত। প্রথমবার `cargo build` চালানোর ফলে কার্গো টপ লেভেলে একটি নতুন ফাইল তৈরি করে: _Cargo.lock_। এই ফাইলটি আপনার প্রজেক্টের dependencies-এর সঠিক ভার্সনগুলোর ট্র্যাক রাখে। এই প্রজেক্টের কোনো dependencies নেই, তাই ফাইলটি কিছুটা ফাঁকা। আপনাকে এই ফাইলটি ম্যানুয়ালি পরিবর্তন করার প্রয়োজন হবে না; কার্গো আপনার জন্য এর বিষয়বস্তু পরিচালনা করে।

আমরা এইমাত্র `cargo build` দিয়ে একটি প্রজেক্ট বিল্ড করেছি এবং `./target/debug/hello_cargo` দিয়ে এটি রান করেছি, কিন্তু আমরা `cargo run` ব্যবহার করে কোডটি কম্পাইল করে এবং তারপর ফলাফল এক্সিকিউটেবলটি এক কমান্ডে চালাতে পারি:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

`cargo build` চালানো এবং তারপর বাইনারির পুরো পাথ ব্যবহার করার কথা মনে রাখার চেয়ে `cargo run` ব্যবহার করা বেশি সুবিধাজনক, তাই বেশিরভাগ ডেভেলপার `cargo run` ব্যবহার করেন।

লক্ষ্য করুন যে এবার আমরা কার্গো `hello_cargo` কম্পাইল করছে এমন কোনো আউটপুট দেখিনি। কার্গো বুঝতে পেরেছে যে ফাইলগুলো পরিবর্তন হয়নি, তাই এটি পুনরায় বিল্ড না করে শুধু বাইনারিটি চালিয়েছে। আপনি যদি আপনার সোর্স কোড পরিবর্তন করতেন, কার্গো প্রজেক্টটি চালানোর আগে পুনরায় বিল্ড করত, এবং আপনি এই আউটপুটটি দেখতে পেতেন:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

কার্গো `cargo check` নামে একটি কমান্ডও সরবরাহ করে। এই কমান্ডটি দ্রুত আপনার কোড পরীক্ষা করে নিশ্চিত করে যে এটি কম্পাইল হয় কিন্তু একটি এক্সিকিউটেবল তৈরি করে না:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

আপনি কেন একটি এক্সিকিউটেবল চাইবেন না? প্রায়শই, `cargo check` `cargo build` এর চেয়ে অনেক দ্রুত হয় কারণ এটি একটি এক্সিকিউটেবল তৈরির ধাপটি এড়িয়ে যায়। আপনি যদি কোড লেখার সময় ক্রমাগত আপনার কাজ পরীক্ষা করতে থাকেন, তবে `cargo check` ব্যবহার করা আপনার প্রজেক্ট এখনও কম্পাইল হচ্ছে কিনা তা জানানোর প্রক্রিয়াটিকে দ্রুততর করবে! এই কারণে, অনেক রাস্টেশিয়ান তাদের প্রোগ্রাম লেখার সময় পর্যায়ক্রমে `cargo check` চালান যাতে এটি কম্পাইল হয় তা নিশ্চিত করা যায়। তারপর তারা যখন এক্সিকিউটেবল ব্যবহার করার জন্য প্রস্তুত হয় তখন `cargo build` চালান।

আসুন আমরা এখন পর্যন্ত কার্গো সম্পর্কে যা শিখেছি তার সারসংক্ষেপ করি:

- আমরা `cargo new` ব্যবহার করে একটি প্রজেক্ট তৈরি করতে পারি।
- আমরা `cargo build` ব্যবহার করে একটি প্রজেক্ট বিল্ড করতে পারি।
- আমরা `cargo run` ব্যবহার করে এক ধাপে একটি প্রজেক্ট বিল্ড এবং রান করতে পারি।
- আমরা `cargo check` ব্যবহার করে এরর পরীক্ষা করার জন্য বাইনারি তৈরি না করে একটি প্রজেক্ট বিল্ড করতে পারি।
- বিল্ডের ফলাফল আমাদের কোডের একই ডিরেক্টরিতে সংরক্ষণ করার পরিবর্তে, কার্গো এটি _target/debug_ ডিরেক্টরিতে সংরক্ষণ করে।

কার্গো ব্যবহারের একটি অতিরিক্ত সুবিধা হলো, আপনি যে অপারেটিং সিস্টেমেই কাজ করুন না কেন কমান্ডগুলো একই থাকে। তাই, এই মুহূর্তে থেকে, আমরা আর লিনাক্স এবং ম্যাকওএস বনাম উইন্ডোজের জন্য নির্দিষ্ট নির্দেশনা প্রদান করব না।

### রিলিজের জন্য বিল্ড করা

যখন আপনার প্রজেক্ট অবশেষে রিলিজের জন্য প্রস্তুত হবে, আপনি অপটিমাইজেশন সহ এটি কম্পাইল করতে `cargo build --release` ব্যবহার করতে পারেন। এই কমান্ডটি _target/debug_ এর পরিবর্তে _target/release_-এ একটি এক্সিকিউটেবল তৈরি করবে। অপটিমাইজেশনগুলো আপনার রাস্ট কোডকে দ্রুত চালাতে সাহায্য করে, কিন্তু সেগুলো চালু করলে আপনার প্রোগ্রাম কম্পাইল হতে বেশি সময় লাগে। এই কারণেই দুটি ভিন্ন প্রোফাইল রয়েছে: একটি ডেভেলপমেন্টের জন্য, যখন আপনি দ্রুত এবং প্রায়শই পুনর্নির্মাণ করতে চান, এবং অন্যটি চূড়ান্ত প্রোগ্রাম তৈরির জন্য যা আপনি একজন ব্যবহারকারীকে দেবেন যা বারবার পুনর্নির্মাণ করা হবে না এবং যা যত দ্রুত সম্ভব চলবে। আপনি যদি আপনার কোডের চলার সময় বেঞ্চমার্কিং করেন, তবে `cargo build --release` চালাতে এবং _target/release_-এর এক্সিকিউটেবল দিয়ে বেঞ্চমার্ক করতে ভুলবেন না।

### কার্গো একটি কনভেনশন হিসাবে

সহজ প্রজেক্টগুলোর ক্ষেত্রে, কার্গো শুধু `rustc` ব্যবহারের চেয়ে খুব বেশি সুবিধা দেয় না, কিন্তু আপনার প্রোগ্রামগুলো আরও জটিল হওয়ার সাথে সাথে এটি তার যোগ্যতা প্রমাণ করবে। যখন প্রোগ্রাম একাধিক ফাইলে বিস্তৃত হয় বা কোনো dependency-র প্রয়োজন হয়, তখন কার্গোকে বিল্ড সমন্বয় করতে দেওয়া অনেক সহজ।

যদিও `hello_cargo` প্রজেক্টটি সহজ, এটি এখন আপনার বাকি রাস্ট ক্যারিয়ারে ব্যবহার করার মতো অনেক আসল টুলিং ব্যবহার করে। প্রকৃতপক্ষে, যেকোনো বিদ্যমান প্রজেক্টে কাজ করার জন্য, আপনি গিট ব্যবহার করে কোড চেক আউট করতে, সেই প্রজেক্টের ডিরেক্টরিতে পরিবর্তন করতে এবং বিল্ড করতে নিম্নলিখিত কমান্ডগুলো ব্যবহার করতে পারেন:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

কার্গো সম্পর্কে আরও তথ্যের জন্য, [এর ডকুমেন্টেশন][cargo] দেখুন।

## সারসংক্ষেপ

আপনি ইতিমধ্যে আপনার রাস্ট যাত্রায় একটি দুর্দান্ত শুরু করেছেন! এই অধ্যায়ে, আপনি শিখেছেন কীভাবে:

- `rustup` ব্যবহার করে রাস্টের সর্বশেষ স্টেবল ভার্সন ইনস্টল করতে হয়
- একটি নতুন রাস্ট ভার্সনে আপডেট করতে হয়
- স্থানীয়ভাবে ইনস্টল করা ডকুমেন্টেশন খুলতে হয়
- `rustc` সরাসরি ব্যবহার করে একটি "Hello, world!" প্রোগ্রাম লিখতে এবং চালাতে হয়
- কার্গোর কনভেনশন ব্যবহার করে একটি নতুন প্রজেক্ট তৈরি এবং চালাতে হয়

রাস্ট কোড পড়া এবং লেখাতে অভ্যস্ত হওয়ার জন্য আরও একটি গুরুত্বপূর্ণ প্রোগ্রাম তৈরি করার জন্য এটি একটি দুর্দান্ত সময়। তাই, অধ্যায় ২-এ, আমরা একটি অনুমান করার খেলার প্রোগ্রাম তৈরি করব। আপনি যদি রাস্ট-এ সাধারণ প্রোগ্রামিং ধারণাগুলো কীভাবে কাজ করে তা শেখার মাধ্যমে শুরু করতে চান, তবে অধ্যায় ৩ দেখুন এবং তারপর অধ্যায় ২-এ ফিরে আসুন।

[installation]: ch01-01-installation.html#installation
[toml]: https://toml.io
[appendix-e]: appendix-05-editions.html
[cargo]: https://doc.rust-lang.org/cargo/