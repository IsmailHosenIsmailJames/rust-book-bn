## থ্রেডগুলির মধ্যে ডেটা স্থানান্তর করতে মেসেজ পাসিং ব্যবহার করা

নিরাপদ কনকারেন্সি নিশ্চিত করার জন্য ক্রমবর্ধমান জনপ্রিয় একটি পদ্ধতি হল _মেসেজ পাসিং_, যেখানে থ্রেড বা অভিনেতা একে অপরের কাছে ডেটা সম্বলিত বার্তা পাঠিয়ে যোগাযোগ করে। এখানে [Go ভাষা ডকুমেন্টেশন](https://golang.org/doc/effective_go.html#concurrency) থেকে একটি স্লোগানে ধারণাটি দেওয়া হল: "মেমরি শেয়ার করে যোগাযোগ করবেন না; পরিবর্তে, যোগাযোগের মাধ্যমে মেমরি শেয়ার করুন।"

মেসেজ-সেন্ডিং কনকারেন্সি সম্পন্ন করার জন্য, Rust-এর স্ট্যান্ডার্ড লাইব্রেরি _চ্যানেলগুলির_ একটি বাস্তবায়ন প্রদান করে। একটি চ্যানেল হল একটি সাধারণ প্রোগ্রামিং ধারণা যার মাধ্যমে একটি থ্রেড থেকে অন্য থ্রেডে ডেটা পাঠানো হয়।

আপনি প্রোগ্রামিং-এ একটি চ্যানেলকে জলের একটি দিকনির্দেশক চ্যানেলের মতো কল্পনা করতে পারেন, যেমন একটি স্রোত বা একটি নদী। আপনি যদি নদীর মতো কোনো কিছুর মধ্যে একটি রাবারের হাঁস রাখেন, তবে এটি জলপথের শেষ পর্যন্ত নিচের দিকে ভ্রমণ করবে।

একটি চ্যানেলের দুটি অংশ রয়েছে: একটি ট্রান্সমিটার এবং একটি রিসিভার। ট্রান্সমিটার অংশটি হল সেই আপস্ট্রিম অবস্থান যেখানে আপনি নদীতে রাবারের হাঁস রাখেন এবং রিসিভার অংশটি হল যেখানে রাবারের হাঁসটি শেষ পর্যন্ত নিচের দিকে এসে পৌঁছায়। আপনার কোডের একটি অংশ আপনি যে ডেটা পাঠাতে চান তা দিয়ে ট্রান্সমিটারের পদ্ধতিগুলিতে কল করে এবং অন্য অংশটি আগত বার্তাগুলির জন্য রিসিভিং প্রান্ত পরীক্ষা করে। একটি চ্যানেলকে _বন্ধ_ বলা হয় যদি ট্রান্সমিটার বা রিসিভার অংশের যেকোনো একটি ড্রপ করা হয়।

এখানে, আমরা এমন একটি প্রোগ্রামের দিকে কাজ করব যেখানে মান তৈরি করতে এবং সেগুলিকে একটি চ্যানেলে পাঠাতে একটি থ্রেড থাকবে এবং অন্য একটি থ্রেড থাকবে যা মানগুলি গ্রহণ করবে এবং সেগুলিকে প্রিন্ট করবে। বৈশিষ্ট্যটি চিত্রিত করার জন্য আমরা একটি চ্যানেল ব্যবহার করে থ্রেডগুলির মধ্যে সাধারণ মান পাঠাব। একবার আপনি কৌশলের সাথে পরিচিত হয়ে গেলে, আপনি যে কোনও থ্রেডের জন্য চ্যানেলগুলি ব্যবহার করতে পারেন যেগুলির মধ্যে একে অপরের সাথে যোগাযোগ করার প্রয়োজন হয়, যেমন একটি চ্যাট সিস্টেম বা এমন একটি সিস্টেম যেখানে অনেক থ্রেড একটি গণনার অংশগুলি সম্পাদন করে এবং ফলাফলগুলিকে একত্রিত করে এমন একটি থ্রেডে অংশগুলি পাঠায়।

প্রথমত, Listing 16-6-এ, আমরা একটি চ্যানেল তৈরি করব কিন্তু এটি দিয়ে কিছুই করব না। মনে রাখবেন যে এটি এখনও কম্পাইল হবে না কারণ Rust বলতে পারে না যে আমরা চ্যানেলের মাধ্যমে কোন ধরনের মান পাঠাতে চাই।

<span class="filename">ফাইলের নাম: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-06/src/main.rs}}
```

<span class="caption">Listing 16-6: একটি চ্যানেল তৈরি করা এবং দুটি অংশ `tx` এবং `rx`-এ বরাদ্দ করা</span>

আমরা `mpsc::channel` ফাংশন ব্যবহার করে একটি নতুন চ্যানেল তৈরি করি; `mpsc` মানে _মাল্টিপল প্রডিউসার, সিঙ্গেল কনজিউমার_। সংক্ষেপে, Rust-এর স্ট্যান্ডার্ড লাইব্রেরি যেভাবে চ্যানেলগুলি প্রয়োগ করে তার অর্থ হল একটি চ্যানেলে একাধিক _প্রেরণকারী_ প্রান্ত থাকতে পারে যা মান তৈরি করে কিন্তু শুধুমাত্র একটি _গ্রহীতা_ প্রান্ত থাকে যা সেই মানগুলি গ্রহণ করে। কল্পনা করুন একাধিক স্রোত একসাথে একটি বড় নদীতে প্রবাহিত হচ্ছে: কোনো স্রোতের মধ্য দিয়ে যা কিছু পাঠানো হোক না কেন, সবকিছু শেষে একটি নদীতে গিয়ে শেষ হবে। আমরা এখন একটি একক প্রডিউসার দিয়ে শুরু করব, তবে আমরা এই উদাহরণটি কাজ করার সময় একাধিক প্রডিউসার যুক্ত করব।

`mpsc::channel` ফাংশন একটি টাপল রিটার্ন করে, যার প্রথম উপাদানটি প্রেরণের প্রান্ত—ট্রান্সমিটার—এবং দ্বিতীয় উপাদানটি হল গ্রহণের প্রান্ত—রিসিভার। `tx` এবং `rx` সংক্ষিপ্ত রূপগুলি ঐতিহ্যগতভাবে অনেক ক্ষেত্রে যথাক্রমে _ট্রান্সমিটার_ এবং _রিসিভারের_ জন্য ব্যবহৃত হয়, তাই আমরা আমাদের ভেরিয়েবলগুলিকে এই প্রান্তগুলি নির্দেশ করার জন্য এই নামে নামকরণ করি। আমরা একটি প্যাটার্ন সহ একটি `let` স্টেটমেন্ট ব্যবহার করছি যা টাপলগুলিকে ধ্বংস করে; আমরা অধ্যায় 19-এ `let` স্টেটমেন্ট এবং ধ্বংস করার ক্ষেত্রে প্যাটার্নের ব্যবহার নিয়ে আলোচনা করব। আপাতত, জেনে রাখুন যে এইভাবে `let` স্টেটমেন্ট ব্যবহার করা `mpsc::channel` দ্বারা ফেরত দেওয়া টাপলের অংশগুলি বের করার একটি সুবিধাজনক পদ্ধতি।

আসুন ট্রান্সমিটিং প্রান্তটিকে একটি স্পন করা থ্রেডে সরিয়ে দিই এবং এটিকে একটি স্ট্রিং পাঠাই যাতে স্পন করা থ্রেডটি প্রধান থ্রেডের সাথে যোগাযোগ করে, যেমন Listing 16-7-এ দেখানো হয়েছে। এটি নদীর উজানে একটি রাবারের হাঁস রাখার বা একটি থ্রেড থেকে অন্য থ্রেডে একটি চ্যাট বার্তা পাঠানোর মতো।

<Listing number="16-7" file-name="src/main.rs" caption="`tx`-কে একটি স্পন করা থ্রেডে সরানো এবং “hi” পাঠানো">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-07/src/main.rs}}
```

</Listing>

আবার, আমরা একটি নতুন থ্রেড তৈরি করতে `thread::spawn` ব্যবহার করছি এবং তারপর `tx`-কে ক্লোজারে সরাতে `move` ব্যবহার করছি যাতে স্পন করা থ্রেড `tx`-এর মালিক হয়। চ্যানেলের মাধ্যমে বার্তা পাঠাতে সক্ষম হওয়ার জন্য স্পন করা থ্রেডের ট্রান্সমিটারের মালিক হওয়া দরকার। ট্রান্সমিটারের একটি `send` পদ্ধতি রয়েছে যা আমরা যে মানটি পাঠাতে চাই তা গ্রহণ করে। `send` পদ্ধতিটি একটি `Result<T, E>` টাইপ রিটার্ন করে, তাই যদি রিসিভারটি ইতিমধ্যেই ড্রপ হয়ে যায় এবং মান পাঠানোর কোথাও না থাকে, তাহলে `send` অপারেশনটি একটি এরর রিটার্ন করবে। এই উদাহরণে, আমরা কোনো এরর হলে প্যানিক করার জন্য `unwrap` কল করছি। কিন্তু একটি বাস্তব অ্যাপ্লিকেশনে, আমরা এটিকে সঠিকভাবে পরিচালনা করব: সঠিক এরর হ্যান্ডলিংয়ের কৌশলগুলির জন্য অধ্যায় 9-এ ফিরে যান।

Listing 16-8-এ, আমরা প্রধান থ্রেডে রিসিভার থেকে মানটি পাব। এটি নদীর শেষে জল থেকে রাবারের হাঁসটি পুনরুদ্ধার করার বা একটি চ্যাট বার্তা পাওয়ার মতো।

<Listing number="16-8" file-name="src/main.rs" caption="প্রধান থ্রেডে “hi” মানটি গ্রহণ করা এবং তা প্রিন্ট করা">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-08/src/main.rs}}
```

</Listing>

রিসিভারের দুটি দরকারী পদ্ধতি রয়েছে: `recv` এবং `try_recv`। আমরা `recv` ব্যবহার করছি, যার অর্থ _রিসিভ_, যা প্রধান থ্রেডের নির্বাহকে ব্লক করবে এবং চ্যানেলটিতে একটি মান পাঠানো না হওয়া পর্যন্ত অপেক্ষা করবে। একবার একটি মান পাঠানো হলে, `recv` এটিকে একটি `Result<T, E>`-এ ফেরত দেবে। যখন ট্রান্সমিটার বন্ধ হয়ে যায়, তখন `recv` একটি এরর ফেরত দেবে এই সংকেত দিতে যে আর কোনো মান আসছে না।

`try_recv` পদ্ধতিটি ব্লক করে না, তবে এর পরিবর্তে একটি `Result<T, E>` অবিলম্বে রিটার্ন করবে: একটি `Ok` মান যদি কোনো বার্তা উপলব্ধ থাকে তবে সেই মান ধারণ করে এবং যদি এই সময়ে কোনো বার্তা না থাকে তবে একটি `Err` মান। যদি বার্তাগুলির জন্য অপেক্ষা করার সময় এই থ্রেডের অন্য কাজ করার থাকে তবে `try_recv` ব্যবহার করা কার্যকর: আমরা একটি লুপ লিখতে পারি যা কিছুক্ষণ পর পর `try_recv` কল করে, কোনো বার্তা উপলব্ধ থাকলে তা পরিচালনা করে এবং অন্যথায় আবার পরীক্ষা না করা পর্যন্ত কিছুক্ষণ অন্য কাজ করে।

আমরা সরলতার জন্য এই উদাহরণে `recv` ব্যবহার করেছি; বার্তাগুলির জন্য অপেক্ষা করা ছাড়া প্রধান থ্রেডের আর কোনো কাজ নেই, তাই প্রধান থ্রেডটিকে ব্লক করা উপযুক্ত।

যখন আমরা Listing 16-8-এর কোডটি চালাই, তখন আমরা প্রধান থ্রেড থেকে প্রিন্ট করা মান দেখতে পাব:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
```

চমৎকার!

### চ্যানেল এবং মালিকানা হস্তান্তর

মালিকানার নিয়মগুলি বার্তা পাঠানোর ক্ষেত্রে একটি গুরুত্বপূর্ণ ভূমিকা পালন করে কারণ তারা আপনাকে নিরাপদ, কনকারেন্ট কোড লিখতে সাহায্য করে। কনকারেন্ট প্রোগ্রামিংয়ে এরর প্রতিরোধ করাই হল আপনার Rust প্রোগ্রাম জুড়ে মালিকানা নিয়ে চিন্তা করার সুবিধা। চ্যানেল এবং মালিকানা কীভাবে একসাথে কাজ করে সমস্যা প্রতিরোধ করে তা দেখানোর জন্য আসুন একটি পরীক্ষা করি: আমরা স্পন করা থ্রেডে `val` মানটি ব্যবহার করার চেষ্টা করব _পরে_ আমরা এটিকে চ্যানেলে পাঠিয়েছি। কেন এই কোডের অনুমতি নেই তা দেখতে Listing 16-9-এর কোডটি কম্পাইল করার চেষ্টা করুন:

<Listing number="16-9" file-name="src/main.rs" caption="চ্যানেলে পাঠানোর পরে `val` ব্যবহার করার চেষ্টা করা হচ্ছে">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-09/src/main.rs}}
```

</Listing>

এখানে, আমরা `tx.send` এর মাধ্যমে চ্যানেলে পাঠানোর পরে `val` প্রিন্ট করার চেষ্টা করি। এটির অনুমতি দেওয়া একটি খারাপ ধারণা হবে: একবার মানটি অন্য থ্রেডে পাঠানো হয়ে গেলে, সেই থ্রেডটি আবার মানটি ব্যবহার করার চেষ্টা করার আগে এটি পরিবর্তন বা ড্রপ করতে পারত। সম্ভাব্যভাবে, অন্য থ্রেডের পরিবর্তনের কারণে অসামঞ্জস্যপূর্ণ বা অস্তিত্বহীন ডেটার কারণে এরর বা অপ্রত্যাশিত ফলাফল হতে পারত। যাইহোক, Rust Listing 16-9-এর কোড কম্পাইল করার চেষ্টা করলে আমাদের একটি এরর দেয়:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-09/output.txt}}
```

আমাদের কনকারেন্সির ভুলের কারণে একটি কম্পাইল টাইম এরর হয়েছে। `send` ফাংশনটি তার প্যারামিটারের মালিকানা গ্রহণ করে এবং যখন মানটি সরানো হয়, তখন রিসিভার এটির মালিকানা গ্রহণ করে। এটি আমাদের পাঠানোর পরে দুর্ঘটনাক্রমে মানটি আবার ব্যবহার করা থেকে বিরত রাখে; মালিকানা সিস্টেম পরীক্ষা করে যে সবকিছু ঠিক আছে।

### একাধিক মান পাঠানো এবং রিসিভারের অপেক্ষা দেখা

Listing 16-8-এর কোডটি কম্পাইল এবং রান করেছে, কিন্তু এটি স্পষ্টভাবে আমাদের দেখায়নি যে দুটি পৃথক থ্রেড চ্যানেলের মাধ্যমে একে অপরের সাথে কথা বলছে। Listing 16-10-এ আমরা কিছু পরিবর্তন করেছি যা প্রমাণ করবে যে Listing 16-8-এর কোডটি একই সাথে চলছে: স্পন করা থ্রেডটি এখন একাধিক বার্তা পাঠাবে এবং প্রতিটি বার্তার মধ্যে এক সেকেন্ডের জন্য বিরতি দেবে।

<Listing number="16-10" file-name="src/main.rs" caption="একাধিক বার্তা পাঠানো এবং প্রতিটির মধ্যে বিরতি দেওয়া">

```rust,noplayground
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-10/src/main.rs}}
```

</Listing>

এইবার, স্পন করা থ্রেডে স্ট্রিংগুলির একটি ভেক্টর রয়েছে যা আমরা প্রধান থ্রেডে পাঠাতে চাই। আমরা সেগুলির উপর পুনরাবৃত্তি করি, প্রতিটি আলাদাভাবে পাঠাই এবং 1 সেকেন্ডের `Duration` মান সহ `thread::sleep` ফাংশন কল করে প্রতিটির মধ্যে বিরতি দিই।

প্রধান থ্রেডে, আমরা আর স্পষ্টভাবে `recv` ফাংশনটি কল করছি না: পরিবর্তে, আমরা `rx`-কে একটি পুনরাবৃত্তিকারী হিসাবে ব্যবহার করছি। প্রতিটি প্রাপ্ত মানের জন্য, আমরা এটিকে প্রিন্ট করছি। চ্যানেল বন্ধ হয়ে গেলে, পুনরাবৃত্তি শেষ হয়ে যাবে।

Listing 16-10-এর কোডটি চালানোর সময়, প্রতিটি লাইনের মধ্যে 1-সেকেন্ডের বিরতি সহ আপনার নিম্নলিখিত আউটপুটটি দেখতে হবে:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
Got: from
Got: the
Got: thread
```

যেহেতু আমাদের প্রধান থ্রেডের `for` লুপে কোনো কোড নেই যা বিরতি বা বিলম্ব ঘটায়, তাই আমরা বলতে পারি যে প্রধান থ্রেডটি স্পন করা থ্রেড থেকে মান পাওয়ার জন্য অপেক্ষা করছে।

### ট্রান্সমিটার ক্লোন করে একাধিক প্রডিউসার তৈরি করা

পূর্বে আমরা উল্লেখ করেছি যে `mpsc` মানে ছিল _মাল্টিপল প্রডিউসার, সিঙ্গেল কনজিউমার_। আসুন `mpsc` ব্যবহার করি এবং Listing 16-10-এর কোডটিকে প্রসারিত করে একাধিক থ্রেড তৈরি করি যা একই রিসিভারে সমস্ত মান পাঠায়। আমরা ট্রান্সমিটারটি ক্লোন করে তা করতে পারি, যেমন Listing 16-11-এ দেখানো হয়েছে:

<Listing number="16-11" file-name="src/main.rs" caption="একাধিক প্রডিউসার থেকে একাধিক বার্তা পাঠানো">

```rust,noplayground
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-11/src/main.rs:here}}
```

</Listing>

এইবার, প্রথম স্পন করা থ্রেড তৈরি করার আগে, আমরা ট্রান্সমিটারের উপর `clone` কল করি। এটি আমাদের একটি নতুন ট্রান্সমিটার দেবে যা আমরা প্রথম স্পন করা থ্রেডে পাস করতে পারি। আমরা দ্বিতীয় স্পন করা থ্রেডে আসল ট্রান্সমিটারটি পাস করি। এটি আমাদের দুটি থ্রেড দেয়, প্রতিটি একটি রিসিভারে বিভিন্ন বার্তা পাঠাচ্ছে।

যখন আপনি কোডটি চালান, তখন আপনার আউটপুটটি নীচের মত দেখতে হবে:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```

আপনার সিস্টেমের উপর নির্ভর করে আপনি মানগুলি অন্য ক্রমে দেখতে পারেন। এটি কনকারেন্সিকেও আকর্ষণীয় করে তোলে এবং সেইসাথে কঠিনও করে তোলে। আপনি যদি `thread::sleep` নিয়ে পরীক্ষা করেন, বিভিন্ন থ্রেডে বিভিন্ন মান দেন, তবে প্রতিটি রান আরও অনির্দিষ্ট হবে এবং প্রতিবার আলাদা আউটপুট তৈরি করবে।

যেহেতু আমরা চ্যানেলগুলি কীভাবে কাজ করে তা দেখেছি, তাই আসুন কনকারেন্সির একটি ভিন্ন পদ্ধতি দেখি।
