## একই সাথে কোড চালানোর জন্য থ্রেড ব্যবহার করা

বেশিরভাগ বর্তমান অপারেটিং সিস্টেমে, একটি কার্যকর প্রোগ্রামের কোড একটি _প্রসেস_-এ চালানো হয় এবং অপারেটিং সিস্টেম একসাথে একাধিক প্রসেস পরিচালনা করবে। একটি প্রোগ্রামের মধ্যে, আপনার স্বাধীন অংশও থাকতে পারে যা একই সাথে চলে। এই স্বাধীন অংশগুলি চালায় এমন বৈশিষ্ট্যগুলিকে _থ্রেড_ বলা হয়। উদাহরণস্বরূপ, একটি ওয়েব সার্ভারে একাধিক থ্রেড থাকতে পারে যাতে এটি একই সময়ে একাধিক অনুরোধের প্রতিক্রিয়া জানাতে পারে।

একই সময়ে একাধিক কাজ চালানোর জন্য আপনার প্রোগ্রামের গণনাকে একাধিক থ্রেডে বিভক্ত করা পারফরম্যান্স উন্নত করতে পারে, তবে এটি জটিলতাও যোগ করে। যেহেতু থ্রেডগুলি একই সাথে চলতে পারে, তাই বিভিন্ন থ্রেডের আপনার কোডের অংশগুলি যে ক্রমে চলবে সে সম্পর্কে কোনও অন্তর্নিহিত গ্যারান্টি নেই। এটি সমস্যা তৈরি করতে পারে, যেমন:

- রেস কন্ডিশন, যেখানে থ্রেডগুলি ডেটা বা রিসোর্সগুলিতে একটি অসামঞ্জস্যপূর্ণ ক্রমে অ্যাক্সেস করছে
- ডেডলক, যেখানে দুটি থ্রেড একে অপরের জন্য অপেক্ষা করছে, উভয় থ্রেডকে চলতে বাধা দিচ্ছে
- এমন বাগ যা শুধুমাত্র নির্দিষ্ট পরিস্থিতিতে ঘটে এবং নির্ভরযোগ্যভাবে পুনরুত্পাদন এবং ঠিক করা কঠিন

Rust থ্রেড ব্যবহারের নেতিবাচক প্রভাবগুলি হ্রাস করার চেষ্টা করে, তবে মাল্টিথ্রেডেড প্রেক্ষাপটে প্রোগ্রামিং করার জন্য এখনও সতর্কতার সাথে চিন্তা করতে হয় এবং একক থ্রেডে চলমান প্রোগ্রামগুলির থেকে আলাদা একটি কোড কাঠামোর প্রয়োজন হয়।

প্রোগ্রামিং ভাষাগুলি কয়েকটি ভিন্ন উপায়ে থ্রেডগুলি প্রয়োগ করে এবং অনেক অপারেটিং সিস্টেম নতুন থ্রেড তৈরি করার জন্য ভাষাটি কল করতে পারে এমন একটি API প্রদান করে। Rust স্ট্যান্ডার্ড লাইব্রেরি থ্রেড বাস্তবায়নের একটি _1:1_ মডেল ব্যবহার করে, যার মাধ্যমে একটি প্রোগ্রাম প্রতি একটি ভাষা থ্রেডের জন্য একটি অপারেটিং সিস্টেম থ্রেড ব্যবহার করে। থ্রেডিংয়ের অন্যান্য মডেল বাস্তবায়নকারী ক্রেট রয়েছে যা 1:1 মডেলে বিভিন্ন ট্রেডঅফ করে। (Rust-এর অ্যাসিঙ্ক সিস্টেম, যা আমরা পরবর্তী অধ্যায়ে দেখব, সেটিও কনকারেন্সির আরেকটি পদ্ধতি প্রদান করে।)

### `spawn` দিয়ে একটি নতুন থ্রেড তৈরি করা

একটি নতুন থ্রেড তৈরি করতে, আমরা `thread::spawn` ফাংশনটি কল করি এবং এটিকে একটি ক্লোজার (আমরা অধ্যায় 13-এ ক্লোজার নিয়ে আলোচনা করেছি) পাস করি যাতে নতুন থ্রেডে আমরা যে কোডটি চালাতে চাই তা থাকে। Listing 16-1-এর উদাহরণটি একটি প্রধান থ্রেড থেকে কিছু টেক্সট এবং একটি নতুন থ্রেড থেকে অন্যান্য টেক্সট প্রিন্ট করে:

<Listing number="16-1" file-name="src/main.rs" caption="প্রধান থ্রেড অন্য কিছু প্রিন্ট করার সময় একটি জিনিস প্রিন্ট করার জন্য একটি নতুন থ্রেড তৈরি করা">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-01/src/main.rs}}
```

</Listing>

লক্ষ্য করুন যে যখন Rust প্রোগ্রামের প্রধান থ্রেডটি সম্পূর্ণ হয়, তখন সমস্ত স্পন করা থ্রেড বন্ধ হয়ে যায়, সেগুলি চালানো শেষ হোক বা না হোক। এই প্রোগ্রাম থেকে আউটপুট প্রতিবার একটু ভিন্ন হতে পারে, তবে এটি নীচের মতো দেখাবে:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
```

`thread::sleep`-এর কলগুলি একটি থ্রেডকে অল্প সময়ের জন্য তার নির্বাহ বন্ধ করতে বাধ্য করে, যা অন্য থ্রেডকে চালানোর অনুমতি দেয়। থ্রেডগুলি সম্ভবত পালা করে নেবে, তবে এটির গ্যারান্টি নেই: এটি নির্ভর করে আপনার অপারেটিং সিস্টেম কীভাবে থ্রেডগুলি শিডিউল করে তার উপর। এই রানে, স্পন করা থ্রেড থেকে প্রিন্ট স্টেটমেন্টটি কোডে প্রথমে দেখা গেলেও প্রধান থ্রেড প্রথমে প্রিন্ট করেছে। এবং যদিও আমরা স্পন করা থ্রেডটিকে `i` 9 না হওয়া পর্যন্ত প্রিন্ট করতে বলেছিলাম, প্রধান থ্রেডটি বন্ধ করার আগে এটি কেবল 5 পর্যন্ত পৌঁছেছিল।

আপনি যদি এই কোডটি চালান এবং শুধুমাত্র প্রধান থ্রেড থেকে আউটপুট দেখেন বা কোনো ওভারল্যাপ না দেখেন, তাহলে অপারেটিং সিস্টেমের থ্রেডগুলির মধ্যে স্যুইচ করার জন্য আরও বেশি সুযোগ তৈরি করতে রেঞ্জগুলির সংখ্যা বাড়ানোর চেষ্টা করুন।

### `join` হ্যান্ডেল ব্যবহার করে সমস্ত থ্রেডের কাজ শেষ হওয়ার জন্য অপেক্ষা করা

Listing 16-1-এর কোডটি প্রধান থ্রেড শেষ হওয়ার কারণে বেশিরভাগ সময় অকালে স্পন করা থ্রেডটিকে থামিয়ে দেয় তা নয়, তবে থ্রেডগুলি যে ক্রমে চলে তার কোনো গ্যারান্টি না থাকার কারণে, আমরা এও গ্যারান্টি দিতে পারি না যে স্পন করা থ্রেডটি আদৌ চলবে কিনা!

আমরা `thread::spawn`-এর রিটার্ন ভ্যালু একটি ভেরিয়েবলে সংরক্ষণ করে স্পন করা থ্রেডটি না চলার বা অকালে শেষ হওয়ার সমস্যাটি সমাধান করতে পারি। `thread::spawn`-এর রিটার্ন টাইপ হল `JoinHandle`। `JoinHandle` হল একটি মালিকানাধীন মান যা, যখন আমরা এটির উপর `join` পদ্ধতিটি কল করি, তখন তার থ্রেডটি শেষ হওয়ার জন্য অপেক্ষা করবে। Listing 16-2 দেখায় যে কীভাবে আমরা Listing 16-1-এ তৈরি করা থ্রেডের `JoinHandle` ব্যবহার করতে পারি এবং `main` প্রস্থান করার আগে স্পন করা থ্রেডটি শেষ হয়েছে কিনা তা নিশ্চিত করার জন্য `join` কল করতে পারি:

<Listing number="16-2" file-name="src/main.rs" caption="থ্রেডটি সম্পূর্ণভাবে চালানোর গ্যারান্টি দিতে `thread::spawn` থেকে একটি `JoinHandle` সংরক্ষণ করা">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-02/src/main.rs}}
```

</Listing>

হ্যান্ডেলে `join` কল করা বর্তমানে চলমান থ্রেডটিকে ব্লক করে যতক্ষণ না হ্যান্ডেল দ্বারা উপস্থাপিত থ্রেডটি শেষ হয়। একটি থ্রেড _ব্লক_ করার অর্থ হল সেই থ্রেডটিকে কাজ করা বা প্রস্থান করা থেকে বিরত রাখা। যেহেতু আমরা `main` থ্রেডের `for` লুপের পরে `join`-এর কলটি রেখেছি, Listing 16-2 চালালে নীচের মত আউটপুট তৈরি করা উচিত:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
```

দুটি থ্রেড পর্যায়ক্রমে চলতে থাকে, কিন্তু প্রধান থ্রেডটি `handle.join()`-এর কলের কারণে অপেক্ষা করে এবং স্পন করা থ্রেডটি শেষ না হওয়া পর্যন্ত শেষ হয় না।

তবে আসুন দেখি কি হয় যখন আমরা `main`-এ `for` লুপের আগে `handle.join()` সরিয়ে নিই, এইরকম:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/no-listing-01-join-too-early/src/main.rs}}
```

</Listing>

প্রধান থ্রেডটি স্পন করা থ্রেডের কাজ শেষ করার জন্য অপেক্ষা করবে এবং তারপর তার `for` লুপ চালাবে, তাই আউটপুট আর ইন্টারলিভ করা হবে না, যেমনটি এখানে দেখানো হয়েছে:

<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->

```text
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```

ছোটখাটো বিবরণ, যেমন `join` কোথায় কল করা হয়েছে, আপনার থ্রেডগুলি একই সময়ে চলে কিনা তা প্রভাবিত করতে পারে।

### থ্রেড সহ `move` ক্লোজার ব্যবহার করা

আমরা প্রায়শই `thread::spawn`-এ পাস করা ক্লোজারগুলির সাথে `move` কীওয়ার্ড ব্যবহার করব কারণ ক্লোজারটি তখন পরিবেশ থেকে এটির ব্যবহৃত মানগুলির মালিকানা গ্রহণ করবে, এইভাবে সেই মানগুলির মালিকানা একটি থ্রেড থেকে অন্য থ্রেডে স্থানান্তর করবে। অধ্যায় 13-এর [“রেফারেন্স ক্যাপচার করা বা মালিকানা সরানো”][capture]<!-- ignore --> বিভাগে, আমরা ক্লোজারের প্রেক্ষাপটে `move` নিয়ে আলোচনা করেছি। এখন, আমরা `move` এবং `thread::spawn`-এর মধ্যে মিথস্ক্রিয়ার উপর আরও বেশি মনোযোগ দেব।

Listing 16-1-এ লক্ষ্য করুন যে আমরা `thread::spawn`-এ পাস করা ক্লোজারটি কোনও আর্গুমেন্ট নেয় না: আমরা স্পন করা থ্রেডের কোডে প্রধান থ্রেড থেকে কোনও ডেটা ব্যবহার করছি না। স্পন করা থ্রেডে প্রধান থ্রেড থেকে ডেটা ব্যবহার করার জন্য, স্পন করা থ্রেডের ক্লোজারটিকে তার প্রয়োজনীয় মানগুলি ক্যাপচার করতে হবে। Listing 16-3 প্রধান থ্রেডে একটি ভেক্টর তৈরি করার এবং এটিকে স্পন করা থ্রেডে ব্যবহার করার একটি প্রচেষ্টা দেখায়। যাইহোক, এটি এখনও কাজ করবে না, যেমনটি আপনি একটু পরেই দেখতে পাবেন।

<Listing number="16-3" file-name="src/main.rs" caption="অন্য থ্রেডে প্রধান থ্রেড দ্বারা তৈরি একটি ভেক্টর ব্যবহার করার চেষ্টা করা হচ্ছে">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-03/src/main.rs}}
```

</Listing>

ক্লোজার `v` ব্যবহার করে, তাই এটি `v`-কে ক্যাপচার করবে এবং এটিকে ক্লোজারের পরিবেশের অংশ করে তুলবে। যেহেতু `thread::spawn` এই ক্লোজারটিকে একটি নতুন থ্রেডে চালায়, তাই আমাদের সেই নতুন থ্রেডের ভিতরে `v` অ্যাক্সেস করতে সক্ষম হওয়া উচিত। কিন্তু যখন আমরা এই উদাহরণটি কম্পাইল করি, তখন আমরা নিম্নলিখিত এররটি পাই:

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-03/output.txt}}
```

Rust _অনুমান_ করে কিভাবে `v` ক্যাপচার করতে হয়, এবং যেহেতু `println!`-এর শুধুমাত্র `v`-এর একটি রেফারেন্স প্রয়োজন, তাই ক্লোজারটি `v` ধার করার চেষ্টা করে। যাইহোক, একটি সমস্যা আছে: Rust বলতে পারে না যে স্পন করা থ্রেডটি কতক্ষণ চলবে, তাই এটি জানে না `v`-এর রেফারেন্স সবসময় বৈধ হবে কিনা।

Listing 16-4 এমন একটি পরিস্থিতি প্রদান করে যেখানে `v`-এর রেফারেন্স অবৈধ হওয়ার সম্ভাবনা বেশি:

<Listing number="16-4" file-name="src/main.rs" caption="একটি ক্লোজার সহ একটি থ্রেড যা একটি প্রধান থ্রেড থেকে `v`-এর একটি রেফারেন্স ক্যাপচার করার চেষ্টা করে যা `v` ড্রপ করে">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-04/src/main.rs}}
```

</Listing>

যদি Rust আমাদের এই কোডটি চালানোর অনুমতি দিত, তাহলে এমন একটি সম্ভাবনা রয়েছে যে স্পন করা থ্রেডটি কোনো কাজ না করেই অবিলম্বে ব্যাকগ্রাউন্ডে চলে যেত। স্পন করা থ্রেডের ভিতরে `v`-এর একটি রেফারেন্স আছে, কিন্তু প্রধান থ্রেডটি অধ্যায় 15-এ আলোচনা করা `drop` ফাংশন ব্যবহার করে অবিলম্বে `v` ড্রপ করে। তারপর, যখন স্পন করা থ্রেডটি কার্যকর করা শুরু করে, তখন `v` আর বৈধ থাকে না, তাই এর একটি রেফারেন্সও অবৈধ। ওহ না!

Listing 16-3-এর কম্পাইলার এররটি ঠিক করতে, আমরা এরর বার্তার পরামর্শ ব্যবহার করতে পারি:

<!-- manual-regeneration
after automatic regeneration, look at listings/ch16-fearless-concurrency/listing-16-03/output.txt and copy the relevant part
-->

```text
help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ++++
```

ক্লোজারের আগে `move` কীওয়ার্ড যোগ করে, আমরা ক্লোজারটিকে Rust-কে মানগুলি ধার করা উচিত কিনা তা অনুমান করার অনুমতি দেওয়ার পরিবর্তে এটি ব্যবহার করা মানগুলির মালিকানা নিতে বাধ্য করি। Listing 16-5-এ দেখানো Listing 16-3-এর পরিবর্তন কম্পাইল হবে এবং আমরা যেমনটি চেয়েছি তেমনভাবে চলবে:

<Listing number="16-5" file-name="src/main.rs" caption="ক্লোজারকে এটি ব্যবহার করে এমন মানগুলির মালিকানা নিতে বাধ্য করতে `move` কীওয়ার্ড ব্যবহার করা">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-05/src/main.rs}}
```

</Listing>

আমরা `move` ক্লোজার ব্যবহার করে Listing 16-4-এর কোডটি ঠিক করার জন্য একই জিনিস চেষ্টা করতে প্রলুব্ধ হতে পারি যেখানে প্রধান থ্রেডটি `drop` কল করেছে। যাইহোক, এই সমাধানটি কাজ করবে না কারণ Listing 16-4 যা করার চেষ্টা করছে তা অন্য কারণে নিষিদ্ধ করা হয়েছে। যদি আমরা ক্লোজারে `move` যোগ করি, তাহলে আমরা `v`-কে ক্লোজারের পরিবেশে সরিয়ে দেব, এবং আমরা প্রধান থ্রেডে আর এটির উপর `drop` কল করতে পারব না। পরিবর্তে আমরা এই কম্পাইলার এরর পাব:

```console
{{#include ../listings/ch16-fearless-concurrency/output-only-01-move-drop/output.txt}}
```

Rust-এর মালিকানার নিয়মগুলি আমাদের আবার বাঁচিয়েছে! আমরা Listing 16-3-এর কোড থেকে একটি এরর পেয়েছি কারণ Rust রক্ষণশীল ছিল এবং শুধুমাত্র থ্রেডের জন্য `v` ধার করছিল, যার মানে প্রধান থ্রেডটি তাত্ত্বিকভাবে স্পন করা থ্রেডের রেফারেন্সটিকে অবৈধ করতে পারত। Rust-কে স্পন করা থ্রেডে `v`-এর মালিকানা সরানোর কথা বলার মাধ্যমে, আমরা Rust-কে গ্যারান্টি দিচ্ছি যে প্রধান থ্রেডটি আর `v` ব্যবহার করবে না। যদি আমরা একইভাবে Listing 16-4 পরিবর্তন করি, তাহলে আমরা যখন প্রধান থ্রেডে `v` ব্যবহার করার চেষ্টা করি তখন আমরা মালিকানার নিয়ম লঙ্ঘন করছি। `move` কীওয়ার্ড ধার করার Rust-এর রক্ষণশীল ডিফল্টকে ওভাররাইড করে; এটি আমাদের মালিকানার নিয়ম লঙ্ঘন করতে দেয় না।

থ্রেড এবং থ্রেড API-এর প্রাথমিক ধারণা থাকার সাথে, আসুন দেখি আমরা থ্রেডগুলির সাথে কী _করতে_ পারি।

[capture]: ch13-01-closures.html#capturing-references-or-moving-ownership
