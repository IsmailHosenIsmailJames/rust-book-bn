## `Rc<T>`, রেফারেন্স গণনা করা স্মার্ট পয়েন্টার

বেশিরভাগ ক্ষেত্রে, মালিকানা স্পষ্ট: আপনি সঠিকভাবে জানেন যে কোন ভেরিয়েবলের একটি নির্দিষ্ট ভ্যালুর মালিকানা রয়েছে। তবে, এমন কিছু ক্ষেত্র রয়েছে যেখানে একটি একক ভ্যালুর একাধিক মালিক থাকতে পারে। উদাহরণস্বরূপ, গ্রাফ ডেটা স্ট্রাকচারে, একাধিক প্রান্ত একই নোডের দিকে নির্দেশ করতে পারে, এবং সেই নোডটি ধারণাগতভাবে এটির দিকে নির্দেশ করা সমস্ত প্রান্তের মালিকানাধীন। একটি নোড ততক্ষণ পর্যন্ত পরিষ্কার করা উচিত নয় যতক্ষণ না এটির দিকে নির্দেশ করা কোনো প্রান্ত না থাকে এবং তাই এর কোনো মালিক থাকে না।

Rust টাইপ `Rc<T>` ব্যবহার করে আপনাকে একাধিক মালিকানাকে স্পষ্টভাবে সক্ষম করতে হবে, যা _রেফারেন্স কাউন্টিং_-এর সংক্ষিপ্ত রূপ। `Rc<T>` টাইপ একটি ভ্যালুর রেফারেন্সের সংখ্যা ট্র্যাক করে নির্ধারণ করে যে ভ্যালুটি এখনও ব্যবহার করা হচ্ছে কিনা। যদি একটি ভ্যালুর শূন্য রেফারেন্স থাকে, তাহলে কোনো রেফারেন্স অবৈধ না হয়েই ভ্যালুটিকে পরিষ্কার করা যেতে পারে।

`Rc<T>`-কে একটি ফ্যামিলি রুমে থাকা টিভির মতো কল্পনা করুন। যখন একজন ব্যক্তি টিভি দেখার জন্য প্রবেশ করেন, তখন তারা এটি চালু করেন। অন্যরা রুমে এসে টিভি দেখতে পারে। যখন শেষ ব্যক্তি রুম থেকে চলে যায়, তখন তারা টিভি বন্ধ করে দেয় কারণ এটি আর ব্যবহার করা হচ্ছে না। যদি কেউ টিভি বন্ধ করে দেয় যখন অন্যরা এখনও দেখছে, তাহলে বাকি টিভি দর্শকদের মধ্যে হট্টগোল হবে!

আমরা `Rc<T>` টাইপ ব্যবহার করি যখন আমরা আমাদের প্রোগ্রামের একাধিক অংশের জন্য হিপে কিছু ডেটা বরাদ্দ করতে চাই এবং আমরা কম্পাইল করার সময় নির্ধারণ করতে পারি না যে কোন অংশটি শেষ পর্যন্ত ডেটা ব্যবহার করা শেষ করবে। যদি আমরা জানতে পারতাম যে কোন অংশটি শেষ পর্যন্ত শেষ হবে, তাহলে আমরা সেই অংশটিকে ডেটার মালিক বানাতে পারতাম, এবং কম্পাইল করার সময় প্রয়োগ করা সাধারণ মালিকানার নিয়মগুলি কার্যকর হত।

মনে রাখবেন যে `Rc<T>` শুধুমাত্র সিঙ্গেল-থ্রেডেড পরিস্থিতিতে ব্যবহারের জন্য। যখন আমরা অধ্যায় 16-এ কনকারেন্সি নিয়ে আলোচনা করব, তখন আমরা মাল্টিথ্রেডেড প্রোগ্রামগুলিতে কীভাবে রেফারেন্স গণনা করতে হয় তা নিয়ে আলোচনা করব।

### ডেটা শেয়ার করতে `Rc<T>` ব্যবহার করা

আসুন Listing 15-5-এর আমাদের কন্স লিস্টের উদাহরণে ফিরে যাই। মনে রাখবেন যে আমরা এটিকে `Box<T>` ব্যবহার করে সংজ্ঞায়িত করেছি। এইবার, আমরা দুটি তালিকা তৈরি করব যা উভয়ই তৃতীয় তালিকার মালিকানা ভাগ করে নেবে। ধারণাগতভাবে, এটি চিত্র 15-3-এর মতো দেখায়:

<img alt="দুটি তালিকা যা তৃতীয় তালিকার মালিকানা ভাগ করে" src="img/trpl15-03.svg" class="center" />

<span class="caption">চিত্র 15-3: দুটি তালিকা, `b` এবং `c`, একটি তৃতীয় তালিকা `a`-এর মালিকানা ভাগ করে নিচ্ছে</span>

আমরা তালিকা `a` তৈরি করব যাতে 5 এবং তারপর 10 থাকে। তারপর আমরা আরও দুটি তালিকা তৈরি করব: `b` যা 3 দিয়ে শুরু হয় এবং `c` যা 4 দিয়ে শুরু হয়। `b` এবং `c` উভয় তালিকা 5 এবং 10 ধারণকারী প্রথম `a` তালিকা পর্যন্ত চলবে। অন্য কথায়, উভয় তালিকা 5 এবং 10 ধারণকারী প্রথম তালিকা ভাগ করবে।

`Box<T>`-এর সাথে `List`-এর আমাদের সংজ্ঞা ব্যবহার করে এই পরিস্থিতি বাস্তবায়ন করার চেষ্টা করলে কাজ হবে না, যেমনটি Listing 15-17-এ দেখানো হয়েছে:

<Listing number="15-17" file-name="src/main.rs" caption="দেখানো হচ্ছে যে আমাদের `Box<T>` ব্যবহার করে দুটি তালিকা রাখার অনুমতি নেই যা তৃতীয় তালিকার মালিকানা ভাগ করার চেষ্টা করে">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-17/src/main.rs}}
```

</Listing>

যখন আমরা এই কোডটি কম্পাইল করি, তখন আমরা এই এররটি পাই:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-17/output.txt}}
```

`Cons` ভেরিয়েন্টগুলি তাদের ধারণ করা ডেটার মালিক, তাই যখন আমরা `b` তালিকা তৈরি করি, তখন `a` কে `b`-এ স্থানান্তরিত করা হয় এবং `b` `a`-এর মালিক হয়। তারপরে, যখন আমরা `c` তৈরি করার সময় `a` আবার ব্যবহার করার চেষ্টা করি, তখন আমাদের অনুমতি নেই কারণ `a` স্থানান্তরিত হয়েছে।

আমরা `Cons`-এর সংজ্ঞা পরিবর্তন করে রেফারেন্স রাখতে পারি, তবে আমাদের লাইফটাইম প্যারামিটার নির্দিষ্ট করতে হবে। লাইফটাইম প্যারামিটার নির্দিষ্ট করার মাধ্যমে, আমরা নির্দিষ্ট করব যে তালিকার প্রতিটি উপাদান কমপক্ষে পুরো তালিকার মতো দীর্ঘ হবে। Listing 15-17-এর উপাদান এবং তালিকাগুলির ক্ষেত্রে এটি প্রযোজ্য, তবে প্রতিটি পরিস্থিতিতে নয়।

পরিবর্তে, আমরা `Box<T>`-এর পরিবর্তে `Rc<T>` ব্যবহার করার জন্য আমাদের `List`-এর সংজ্ঞা পরিবর্তন করব, যেমনটি Listing 15-18-এ দেখানো হয়েছে। প্রতিটি `Cons` ভেরিয়েন্ট এখন একটি ভ্যালু এবং একটি `List`-এর দিকে নির্দেশিত একটি `Rc<T>` ধারণ করবে। যখন আমরা `b` তৈরি করি, তখন `a`-এর মালিকানা নেওয়ার পরিবর্তে, আমরা `a` যে `Rc<List>` ধারণ করে আছে সেটিকে ক্লোন করব, যার ফলে রেফারেন্সের সংখ্যা এক থেকে দুইয়ে বাড়বে এবং `a` এবং `b`-কে সেই `Rc<List>`-এর ডেটার মালিকানা ভাগ করতে দেবে। এছাড়াও `c` তৈরি করার সময় আমরা `a`-কে ক্লোন করব, রেফারেন্সের সংখ্যা দুই থেকে তিনে বাড়বে। যতবার আমরা `Rc::clone` কল করব, ততবার `Rc<List>`-এর ভিতরের ডেটার রেফারেন্স গণনা বাড়বে এবং যতক্ষণ না এর শূন্য রেফারেন্স থাকে ততক্ষণ ডেটা পরিষ্কার করা হবে না।

<Listing number="15-18" file-name="src/main.rs" caption="`Rc<T>` ব্যবহার করে `List`-এর একটি সংজ্ঞা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-18/src/main.rs}}
```

</Listing>

`Rc<T>`-কে স্কোপে আনার জন্য আমাদের একটি `use` স্টেটমেন্ট যোগ করতে হবে কারণ এটি prelude-এ নেই। `main`-এ, আমরা 5 এবং 10 ধারণকারী তালিকা তৈরি করি এবং `a`-এ একটি নতুন `Rc<List>`-এ সংরক্ষণ করি। তারপর যখন আমরা `b` এবং `c` তৈরি করি, তখন আমরা `Rc::clone` ফাংশনটি কল করি এবং `a`-এর `Rc<List>`-এর একটি রেফারেন্স আর্গুমেন্ট হিসেবে পাস করি।

আমরা `Rc::clone(&a)`-এর পরিবর্তে `a.clone()` কল করতে পারতাম, কিন্তু Rust-এর প্রথা হল এই ক্ষেত্রে `Rc::clone` ব্যবহার করা। `Rc::clone`-এর বাস্তবায়ন বেশিরভাগ টাইপের `clone`-এর বাস্তবায়নের মতো সমস্ত ডেটার গভীর কপি তৈরি করে না। `Rc::clone`-এর কল শুধুমাত্র রেফারেন্স গণনা বাড়ায়, যা বেশি সময় নেয় না। ডেটার গভীর কপি করতে অনেক সময় লাগতে পারে। রেফারেন্স গণনার জন্য `Rc::clone` ব্যবহার করে, আমরা গভীর-কপি ধরনের ক্লোন এবং রেফারেন্স গণনা বৃদ্ধি করে এমন ক্লোনের মধ্যে দৃশ্যমানভাবে পার্থক্য করতে পারি। কোডে পারফরম্যান্সের সমস্যাগুলি সন্ধান করার সময়, আমাদের শুধুমাত্র গভীর-কপি ক্লোনগুলি বিবেচনা করতে হবে এবং `Rc::clone`-এ কলগুলিকে উপেক্ষা করতে পারি।

### `Rc<T>` ক্লোন করলে রেফারেন্স গণনা বাড়ে

আসুন Listing 15-18-এর আমাদের কাজের উদাহরণ পরিবর্তন করি যাতে আমরা `a`-এর `Rc<List>`-এর রেফারেন্স তৈরি এবং ড্রপ করার সাথে সাথে রেফারেন্স গণনা পরিবর্তন হতে দেখতে পারি।

Listing 15-19-এ, আমরা `main` পরিবর্তন করব যাতে তালিকা `c`-এর চারপাশে একটি ভিতরের স্কোপ থাকে; তারপর `c` স্কোপের বাইরে গেলে রেফারেন্স গণনা কীভাবে পরিবর্তিত হয় তা আমরা দেখতে পারি।

<Listing number="15-19" file-name="src/main.rs" caption="রেফারেন্স গণনা প্রিন্ট করা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-19/src/main.rs:here}}
```

</Listing>

প্রোগ্রামের প্রতিটি পয়েন্টে যেখানে রেফারেন্স গণনা পরিবর্তিত হয়, আমরা রেফারেন্স গণনা প্রিন্ট করি, যা আমরা `Rc::strong_count` ফাংশন কল করে পাই। এই ফাংশনটির নাম `count` না রেখে `strong_count` রাখার কারণ হল `Rc<T>` টাইপের একটি `weak_count`-ও রয়েছে; আমরা দেখব `weak_count` কীসের জন্য ব্যবহার করা হয় [“রেফারেন্স চক্র প্রতিরোধ করা: `Rc<T>`-কে `Weak<T>`-এ পরিণত করা”][preventing-ref-cycles]<!-- ignore --> বিভাগে।

এই কোডটি নিম্নলিখিত প্রিন্ট করে:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-19/output.txt}}
```

আমরা দেখতে পাচ্ছি যে `a`-এর `Rc<List>`-এর প্রাথমিক রেফারেন্স গণনা 1; তারপর যতবার আমরা `clone` কল করি, গণনা 1 করে বৃদ্ধি পায়। যখন `c` স্কোপের বাইরে চলে যায়, তখন গণনা 1 করে কমে যায়। রেফারেন্স গণনা কমানোর জন্য আমাদের কোনো ফাংশন কল করতে হয় না যেমনটি আমাদের রেফারেন্স গণনা বাড়ানোর জন্য `Rc::clone` কল করতে হয়: `Drop` trait-এর বাস্তবায়ন স্বয়ংক্রিয়ভাবে রেফারেন্স গণনা কমিয়ে দেয় যখন একটি `Rc<T>` ভ্যালু স্কোপের বাইরে চলে যায়।

এই উদাহরণে আমরা যা দেখতে পাচ্ছি না তা হল যখন `main`-এর শেষে `b` এবং তারপর `a` স্কোপের বাইরে চলে যায়, তখন গণনা 0 হয় এবং `Rc<List>` সম্পূর্ণরূপে পরিষ্কার হয়ে যায়। `Rc<T>` ব্যবহার করা একটি একক ভ্যালুকে একাধিক মালিক রাখতে দেয় এবং গণনা নিশ্চিত করে যে যতক্ষণ মালিকদের মধ্যে কেউ বিদ্যমান থাকে ততক্ষণ ভ্যালুটি বৈধ থাকে।

অপরিবর্তনযোগ্য রেফারেন্সের মাধ্যমে, `Rc<T>` আপনাকে শুধুমাত্র পড়ার জন্য আপনার প্রোগ্রামের একাধিক অংশের মধ্যে ডেটা শেয়ার করতে দেয়। যদি `Rc<T>` আপনাকে একাধিক পরিবর্তনযোগ্য রেফারেন্স রাখার অনুমতি দিত, তবে আপনি অধ্যায় 4-এ আলোচিত ধার করার নিয়মগুলির মধ্যে একটি লঙ্ঘন করতে পারতেন: একই জায়গায় একাধিক পরিবর্তনযোগ্য ধার ডেটা রেস এবং অসঙ্গতি সৃষ্টি করতে পারে। কিন্তু ডেটা পরিবর্তন করতে সক্ষম হওয়া খুবই প্রয়োজনীয়! পরবর্তী বিভাগে, আমরা অভ্যন্তরীণ পরিবর্তনশীলতা প্যাটার্ন এবং `RefCell<T>` টাইপ নিয়ে আলোচনা করব যা আপনি এই অপরিবর্তনীয়তার সীমাবদ্ধতার সাথে কাজ করার জন্য একটি `Rc<T>`-এর সাথে একত্রে ব্যবহার করতে পারেন।

[preventing-ref-cycles]: ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt
