## হ্যাশ ম্যাপে Associated মান সহ কী স্টোর করা

আমাদের সাধারণ collection গুলোর শেষটি হল _হ্যাশ ম্যাপ_। `HashMap<K, V>` টাইপটি একটি _হ্যাশিং ফাংশন_ ব্যবহার করে `K` টাইপের কীগুলিকে `V` টাইপের মানগুলির সাথে map করে স্টোর করে, যা নির্ধারণ করে যে এটি কীভাবে এই কী এবং মানগুলিকে মেমরিতে স্থাপন করে। অনেক প্রোগ্রামিং ভাষা এই ধরণের ডেটা স্ট্রাকচার সমর্থন করে, তবে তারা প্রায়শই একটি ভিন্ন নাম ব্যবহার করে, যেমন _hash_, _map_, _object_, _hash table_, _dictionary_, বা _associative array_, কয়েকটি নাম বলতে গেলে।

হ্যাশ ম্যাপগুলি কার্যকর যখন আপনি ডেটা lookup করতে চান কোনো ইনডেক্স ব্যবহার না করে, যেমন আপনি ভেক্টরের সাথে করতে পারেন, বরং একটি কী ব্যবহার করে যা যেকোনো প্রকারের হতে পারে। উদাহরণস্বরূপ, একটি গেমে, আপনি একটি হ্যাশ ম্যাপে প্রতিটি দলের স্কোর ট্র্যাক করতে পারেন যেখানে প্রতিটি কী হল একটি দলের নাম এবং মানগুলি হল প্রতিটি দলের স্কোর। একটি দলের নাম দেওয়া হলে, আপনি এর স্কোর পুনরুদ্ধার করতে পারেন।

আমরা এই বিভাগে হ্যাশ ম্যাপের মৌলিক API নিয়ে আলোচনা করব, তবে আরও অনেক সুবিধা standard library দ্বারা `HashMap<K, V>` এ সংজ্ঞায়িত ফাংশনগুলিতে লুকিয়ে আছে। সবসময়কার মতো, আরও তথ্যের জন্য standard library এর ডকুমেন্টেশন দেখুন।

### নতুন হ্যাশ ম্যাপ তৈরি করা

একটি খালি হ্যাশ ম্যাপ তৈরি করার একটি উপায় হল `new` ব্যবহার করা এবং `insert` দিয়ে উপাদান যোগ করা। Listing 8-20 এ, আমরা _Blue_ এবং _Yellow_ নামের দুটি দলের স্কোর ট্র্যাক রাখছি। Blue দলটি 10 পয়েন্ট দিয়ে শুরু করে এবং Yellow দলটি 50 দিয়ে শুরু করে।

<Listing number="8-20" caption="একটি নতুন হ্যাশ ম্যাপ তৈরি করা এবং কিছু কী এবং মান প্রবেশ করানো">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-20/src/main.rs:here}}
```

</Listing>

মনে রাখবেন যে standard library এর collections অংশ থেকে প্রথমে আমাদের `HashMap` ব্যবহার করতে হবে। আমাদের তিনটি সাধারণ collection এর মধ্যে, এটি সবচেয়ে কম ব্যবহৃত হয়, তাই এটি prelude-এ স্বয়ংক্রিয়ভাবে scope এ আনা বৈশিষ্ট্যগুলির মধ্যে অন্তর্ভুক্ত করা হয়নি। হ্যাশ ম্যাপগুলির standard library থেকে কম সমর্থন রয়েছে; উদাহরণস্বরূপ, এগুলি তৈরি করার জন্য কোনও অন্তর্নির্মিত macro নেই।

ভেক্টরের মতোই, হ্যাশ ম্যাপগুলি heap এ তাদের ডেটা স্টোর করে। এই `HashMap` এ `String` টাইপের কী এবং `i32` টাইপের মান রয়েছে। ভেক্টরের মতো, হ্যাশ ম্যাপগুলিও হোমোজেনিয়াস: সমস্ত কী এর একই প্রকার থাকতে হবে এবং সমস্ত মানের একই প্রকার থাকতে হবে।

### হ্যাশ ম্যাপে মান অ্যাক্সেস করা

আমরা `get` method এ তার কী প্রদান করে হ্যাশ ম্যাপ থেকে একটি মান পেতে পারি, যেমন Listing 8-21 এ দেখানো হয়েছে।

<Listing number="8-21" caption="হ্যাশ ম্যাপে স্টোর করা Blue দলের স্কোর অ্যাক্সেস করা">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-21/src/main.rs:here}}
```

</Listing>

এখানে, `score` এ Blue দলের সাথে যুক্ত মান থাকবে এবং ফলাফল হবে `10`। `get` method টি একটি `Option<&V>` ফেরত দেয়; যদি হ্যাশ ম্যাপে সেই কী এর জন্য কোনো মান না থাকে তবে `get` `None` ফেরত দেবে। এই প্রোগ্রামটি `Option<&i32>` এর পরিবর্তে একটি `Option<i32>` পেতে `copied` কল করে, এবং `scores` এ কী এর জন্য কোনো এন্ট্রি না থাকলে `score` কে শূন্য সেট করতে `unwrap_or` কল করে `Option` পরিচালনা করে।

আমরা ভেক্টরের মতো একটি `for` লুপ ব্যবহার করে হ্যাশ ম্যাপের প্রতিটি কী-মান জোড়ার উপর পুনরাবৃত্তি করতে পারি:

```rust
{{#rustdoc_include ../listings/ch08-common-collections/no-listing-03-iterate-over-hashmap/src/main.rs:here}}
```

এই কোডটি একটি নির্বিচারে ক্রমে প্রতিটি জোড়া প্রিন্ট করবে:

```text
Yellow: 50
Blue: 10
```

### হ্যাশ ম্যাপ এবং Ownership

যে প্রকারগুলি `Copy` trait প্রয়োগ করে, যেমন `i32`, সেই মানগুলি হ্যাশ ম্যাপে কপি করা হয়। `String` এর মতো owned মানগুলির জন্য, মানগুলি move করা হবে এবং হ্যাশ ম্যাপ সেই মানগুলির মালিক হবে, যেমন Listing 8-22 এ দেখানো হয়েছে।

<Listing number="8-22" caption="দেখান যে একবার প্রবেশ করানো হলে হ্যাশ ম্যাপটি কী এবং মানগুলির মালিক হয়">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-22/src/main.rs:here}}
```

</Listing>

`insert` এ কল করার মাধ্যমে হ্যাশ ম্যাপে move করার পরে আমরা `field_name` এবং `field_value` ভেরিয়েবলগুলি ব্যবহার করতে পারি না।

যদি আমরা হ্যাশ ম্যাপে মানগুলির reference প্রবেশ করাই, তাহলে মানগুলি হ্যাশ ম্যাপে move করা হবে না। রেফারেন্সগুলি যে মানগুলিকে নির্দেশ করে তা কমপক্ষে ততক্ষণ পর্যন্ত বৈধ থাকতে হবে যতক্ষণ না হ্যাশ ম্যাপটি বৈধ থাকে। আমরা Chapter 10 এর [“Validating References with Lifetimes”][validating-references-with-lifetimes]<!-- ignore --> বিভাগে এই সমস্যাগুলি নিয়ে আরও আলোচনা করব।

### হ্যাশ ম্যাপ আপডেট করা

যদিও কী এবং মান জোড়ার সংখ্যা বাড়ানো যায়, প্রতিটি অনন্য কী তে একবারে এটির সাথে যুক্ত একটি মান থাকতে পারে (তবে এর বিপরীতটি নয়: উদাহরণস্বরূপ, Blue দল এবং Yellow দল উভয়েরই `scores` হ্যাশ ম্যাপে `10` মান স্টোর করা থাকতে পারে)।

যখন আপনি হ্যাশ ম্যাপে ডেটা পরিবর্তন করতে চান, তখন আপনাকে সিদ্ধান্ত নিতে হবে যে একটি কী তে ইতিমধ্যে একটি মান নির্ধারিত থাকলে সেই ক্ষেত্রে কীভাবে পরিচালনা করবেন। আপনি পুরানো মানটিকে নতুন মান দিয়ে প্রতিস্থাপন করতে পারেন, পুরানো মানটিকে সম্পূর্ণরূপে উপেক্ষা করে। আপনি পুরানো মানটি রাখতে পারেন এবং নতুন মানটিকে উপেক্ষা করতে পারেন, নতুন মানটি তখনই যোগ করতে পারেন যদি কী এর ইতিমধ্যে কোনো মান _না থাকে_। অথবা আপনি পুরানো মান এবং নতুন মান একত্রিত করতে পারেন। আসুন দেখি কিভাবে এই প্রতিটি কাজ করতে হয়!

#### একটি মান ওভাররাইট করা

যদি আমরা একটি কী এবং একটি মান হ্যাশ ম্যাপে প্রবেশ করাই এবং তারপর অন্য মান দিয়ে সেই একই কী প্রবেশ করাই, তবে সেই কী এর সাথে যুক্ত মানটি প্রতিস্থাপিত হবে। যদিও Listing 8-23 এর কোডটি `insert` কে দুবার কল করে, হ্যাশ ম্যাপে শুধুমাত্র একটি কী-মান জোড়া থাকবে কারণ আমরা উভয়বারই Blue দলের কী এর জন্য মান প্রবেশ করাচ্ছি।

<Listing number="8-23" caption="একটি নির্দিষ্ট কী এর সাথে স্টোর করা একটি মান প্রতিস্থাপন করা">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-23/src/main.rs:here}}
```

</Listing>

এই কোডটি প্রিন্ট করবে `{"Blue": 25}`। `10` এর আসল মানটি ওভাররাইট করা হয়েছে।

<!-- Old headings. Do not remove or links may break. -->

<a id="only-inserting-a-value-if-the-key-has-no-value"></a>

#### একটি কী এবং মান যোগ করা শুধুমাত্র তখনই যদি কী এর কোনো মান না থাকে

এটি পরীক্ষা করা সাধারণ যে একটি হ্যাশ ম্যাপে একটি নির্দিষ্ট কী তে ইতিমধ্যেই একটি মান আছে কিনা এবং তারপর নিম্নলিখিত পদক্ষেপগুলি নেওয়া: যদি কী টি হ্যাশ ম্যাপে থাকে, তবে বিদ্যমান মানটি যেমন আছে তেমনই থাকা উচিত; যদি কী টি না থাকে তবে এটি এবং এর জন্য একটি মান প্রবেশ করান।

হ্যাশ ম্যাপে এর জন্য `entry` নামের একটি বিশেষ API আছে যা প্যারামিটার হিসাবে আপনি যে কী পরীক্ষা করতে চান তা নেয়। `entry` method এর return মান হল `Entry` নামের একটি enum যা এমন একটি মান উপস্থাপন করে যা থাকতেও পারে বা নাও থাকতে পারে। ধরুন আমরা পরীক্ষা করতে চাই যে Yellow দলের কী এর সাথে কোনো মান যুক্ত আছে কিনা। যদি না থাকে, তবে আমরা `50` মানটি প্রবেশ করতে চাই এবং Blue দলের জন্যও একই কাজ করতে চাই। `entry` API ব্যবহার করে, কোডটি Listing 8-24 এর মতো দেখায়।

<Listing number="8-24" caption="শুধুমাত্র তখনই প্রবেশ করাতে `entry` method ব্যবহার করা যদি কী তে ইতিমধ্যে কোনো মান না থাকে">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-24/src/main.rs:here}}
```

</Listing>

`Entry` এর `or_insert` method টি সংজ্ঞায়িত করা হয়েছে যাতে সেই কী বিদ্যমান থাকলে সংশ্লিষ্ট `Entry` কী এর মানের একটি mutable reference ফেরত দেয় এবং যদি না থাকে, তবে এটি প্যারামিটারটিকে এই কী এর জন্য নতুন মান হিসাবে প্রবেশ করায় এবং নতুন মানের একটি mutable reference ফেরত দেয়। এই কৌশলটি আমাদের নিজেদের যুক্তি লেখার চেয়ে অনেক বেশি পরিষ্কার এবং এর পাশাপাশি borrow checker এর সাথে আরও ভালোভাবে কাজ করে।

Listing 8-24 এর কোড রান করলে `{"Yellow": 50, "Blue": 10}` প্রিন্ট হবে। `entry` তে প্রথম কলটি Yellow দলের জন্য কী এবং `50` মান প্রবেশ করাবে কারণ Yellow দলের ইতিমধ্যে কোনো মান নেই। `entry` তে দ্বিতীয় কলটি হ্যাশ ম্যাপ পরিবর্তন করবে না কারণ Blue দলের মান ইতিমধ্যেই `10` রয়েছে।

#### পুরানো মানের উপর ভিত্তি করে একটি মান আপডেট করা

হ্যাশ ম্যাপের আরেকটি সাধারণ ব্যবহারের ক্ষেত্র হল একটি কী এর মান lookup করা এবং তারপর পুরানো মানের উপর ভিত্তি করে এটিকে আপডেট করা। উদাহরণস্বরূপ, Listing 8-25 এ এমন কোড দেখানো হয়েছে যা গণনা করে যে কিছু টেক্সটে প্রতিটি শব্দ কতবার এসেছে। আমরা কী হিসাবে শব্দগুলি সহ একটি হ্যাশ ম্যাপ ব্যবহার করি এবং সেই শব্দটি কতবার দেখেছি তা ট্র্যাক রাখতে মান বৃদ্ধি করি। যদি আমরা প্রথমবারের মতো কোনো শব্দ দেখি তবে আমরা প্রথমে `0` মানটি প্রবেশ করাব।

<Listing number="8-25" caption="শব্দ এবং গণনা স্টোর করে এমন একটি হ্যাশ ম্যাপ ব্যবহার করে শব্দের ঘটনা গণনা করা">

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-25/src/main.rs:here}}
```

</Listing>

এই কোডটি `{"world": 2, "hello": 1, "wonderful": 1}` প্রিন্ট করবে। আপনি একই কী-মান জোড়াগুলি একটি ভিন্ন ক্রমে প্রিন্ট করা দেখতে পারেন: [“Accessing Values in a Hash Map”][access]<!-- ignore --> বিভাগ থেকে মনে রাখবেন যে একটি হ্যাশ ম্যাপের উপর পুনরাবৃত্তি একটি নির্বিচারে ক্রমে ঘটে।

`split_whitespace` method `text` এ মানের হোয়াইটস্পেস দ্বারা পৃথক করা subslices এর উপর একটি iterator ফেরত দেয়। `or_insert` method নির্দিষ্ট কী এর মানের একটি mutable reference (`&mut V`) ফেরত দেয়। এখানে, আমরা সেই mutable reference টিকে `count` ভেরিয়েবলে স্টোর করি, তাই সেই মানটিকে অ্যাসাইন করতে, প্রথমে আমাদের তারকাচিহ্ন (`*`) ব্যবহার করে `count` টিকে dereference করতে হবে। mutable reference টি `for` লুপের শেষে scope এর বাইরে চলে যায়, তাই এই সমস্ত পরিবর্তন borrowing নিয়মের দ্বারা নিরাপদ এবং অনুমোদিত।

### হ্যাশিং ফাংশন

ডিফল্টরূপে, `HashMap` একটি হ্যাশিং ফাংশন ব্যবহার করে যার নাম _SipHash_ যা হ্যাশ টেবিল জড়িত ডিনায়াল-অফ-সার্ভিস (DoS) আক্রমণ প্রতিরোধ করতে পারে[^siphash]<!-- ignore -->। এটি উপলব্ধ দ্রুততম হ্যাশিং অ্যালগরিদম নয়, তবে কর্মক্ষমতা কমে যাওয়ার সাথে আরও ভাল সুরক্ষার জন্য trade-off করা মূল্যবান। যদি আপনি আপনার কোড প্রোফাইল করেন এবং দেখেন যে ডিফল্ট হ্যাশ ফাংশনটি আপনার উদ্দেশ্যে খুব ধীর, তবে আপনি অন্য হ্যাশার নির্দিষ্ট করে অন্য ফাংশনে স্যুইচ করতে পারেন। একটি _hasher_ হল এমন একটি প্রকার যা `BuildHasher` trait প্রয়োগ করে। আমরা [Chapter 10][traits]<!-- ignore --> এ traits এবং কিভাবে সেগুলি প্রয়োগ করতে হয় তা নিয়ে আলোচনা করব। আপনাকে স্ক্র্যাচ থেকে আপনার নিজস্ব hasher তৈরি করতে হবে না; [crates.io](https://crates.io/)<!-- ignore --> তে অন্যান্য Rust ব্যবহারকারীদের দ্বারা শেয়ার করা লাইব্রেরি রয়েছে যা অনেক সাধারণ হ্যাশিং অ্যালগরিদম প্রয়োগ করে এমন hasher প্রদান করে।

[^siphash]: [https://en.wikipedia.org/wiki/SipHash](https://en.wikipedia.org/wiki/SipHash)

## সারসংক্ষেপ

ভেক্টর, স্ট্রিং এবং হ্যাশ ম্যাপগুলি আপনার প্রোগ্রামগুলিতে প্রয়োজনীয় প্রচুর পরিমাণে কার্যকারিতা সরবরাহ করবে যখন আপনাকে ডেটা স্টোর, অ্যাক্সেস এবং পরিবর্তন করতে হবে। এখানে কিছু অনুশীলন রয়েছে যা সমাধান করতে এখন আপনি প্রস্তুত:

1. পূর্ণসংখ্যার একটি তালিকা দেওয়া হলে, একটি ভেক্টর ব্যবহার করুন এবং তালিকার মধ্যমা (সর্ট করার পরে, মাঝের অবস্থানে মান) এবং মোড (সবচেয়ে বেশিবার ঘটে এমন মান; এখানে একটি হ্যাশ ম্যাপ সহায়ক হবে) ফেরত দিন।
2. স্ট্রিংগুলিকে পিগ ল্যাটিনে রূপান্তর করুন। প্রতিটি শব্দের প্রথম ব্যঞ্জনবর্ণ শব্দটির শেষে move করা হয় এবং _ay_ যোগ করা হয়, তাই _first_ হয়ে যায় _irst-fay_। স্বরবর্ণ দিয়ে শুরু হওয়া শব্দগুলির শেষে _hay_ যোগ করা হয় (_apple_ হয়ে যায় _apple-hay_)। UTF-8 এনকোডিং সম্পর্কে বিস্তারিত মনে রাখবেন!
3. একটি হ্যাশ ম্যাপ এবং ভেক্টর ব্যবহার করে, একটি কোম্পানির একটি বিভাগে কর্মীদের নাম যোগ করার জন্য ব্যবহারকারীকে অনুমতি দিতে একটি টেক্সট ইন্টারফেস তৈরি করুন; উদাহরণস্বরূপ, "Add Sally to Engineering" বা "Add Amir to Sales।" তারপরে ব্যবহারকারীকে একটি বিভাগ বা কোম্পানির সমস্ত লোকজনের একটি তালিকা অক্ষর অনুসারে সাজিয়ে পুনরুদ্ধার করতে দিন।

standard library API ডকুমেন্টেশনে এমন methods বর্ণনা করা আছে যা ভেক্টর, স্ট্রিং এবং হ্যাশ ম্যাপগুলিতে রয়েছে যা এই অনুশীলনগুলির জন্য সহায়ক হবে!

আমরা আরও জটিল প্রোগ্রামের দিকে যাচ্ছি যেখানে অপারেশন ব্যর্থ হতে পারে, তাই ত্রুটি হ্যান্ডলিং নিয়ে আলোচনা করার জন্য এটি একটি উপযুক্ত সময়। আমরা এর পরেই তা করব!

[validating-references-with-lifetimes]: ch10-03-lifetime-syntax.html#validating-references-with-lifetimes
[access]: #accessing-values-in-a-hash-map
[traits]: ch10-02-traits.html
