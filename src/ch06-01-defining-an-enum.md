## একটি Enum সংজ্ঞায়িত করা

যেখানে structs আপনাকে সম্পর্কিত ফিল্ড এবং ডেটা একসাথে গ্রুপ করার একটি উপায় দেয়, যেমন একটি `Rectangle` এর `width` এবং `height`, enums আপনাকে একটি মান সম্ভাব্য মানগুলির একটি সেটের মধ্যে একটি বলার একটি উপায় দেয়। উদাহরণস্বরূপ, আমরা বলতে চাইতে পারি যে `Rectangle` হল সম্ভাব্য আকারের একটি সেটের মধ্যে একটি, যার মধ্যে `Circle` এবং `Triangle` অন্তর্ভুক্ত রয়েছে। এটি করার জন্য, Rust আমাদের এই সম্ভাবনাগুলিকে একটি enum হিসাবে এনকোড করার অনুমতি দেয়।

আসুন এমন একটি পরিস্থিতি দেখি যা আমরা কোডে প্রকাশ করতে চাইতে পারি এবং দেখি কেন এই ক্ষেত্রে enums কার্যকর এবং structs এর চেয়ে বেশি উপযুক্ত। ধরুন আমাদের IP ঠিকানা নিয়ে কাজ করতে হবে। বর্তমানে, IP ঠিকানার জন্য দুটি প্রধান মান ব্যবহার করা হয়: সংস্করণ চার এবং সংস্করণ ছয়। যেহেতু এইগুলিই IP ঠিকানার একমাত্র সম্ভাবনা যা আমাদের প্রোগ্রামটি সম্মুখীন হবে, তাই আমরা সমস্ত সম্ভাব্য variant গুলি _তালিকাভুক্ত_ করতে পারি, যেখান থেকে enumeration নামটি এসেছে।

যেকোনো IP ঠিকানা হয় সংস্করণ চার বা সংস্করণ ছয় ঠিকানা হতে পারে, কিন্তু একই সময়ে উভয়ই হতে পারে না। IP ঠিকানাগুলির সেই বৈশিষ্ট্যটি enum ডেটা স্ট্রাকচারকে উপযুক্ত করে তোলে কারণ একটি enum মান শুধুমাত্র এর variant গুলির মধ্যে একটি হতে পারে। সংস্করণ চার এবং সংস্করণ ছয় উভয় ঠিকানাই মূলত IP ঠিকানা, তাই কোড যখন যেকোনো ধরনের IP ঠিকানার ক্ষেত্রে প্রযোজ্য পরিস্থিতিগুলি পরিচালনা করছে তখন তাদের একই প্রকার হিসাবে বিবেচনা করা উচিত।

আমরা `IpAddrKind` enumeration সংজ্ঞায়িত করে এবং একটি IP ঠিকানা হতে পারে এমন সম্ভাব্য প্রকারগুলি তালিকাভুক্ত করে এই ধারণাটিকে কোডে প্রকাশ করতে পারি, `V4` এবং `V6`। এগুলি হল enum এর variant:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:def}}
```

`IpAddrKind` এখন একটি কাস্টম ডেটা টাইপ যা আমরা আমাদের কোডে অন্য কোথাও ব্যবহার করতে পারি।

### Enum মান

আমরা `IpAddrKind` এর দুটি variant এর প্রতিটিটির instance তৈরি করতে পারি এভাবে:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:instance}}
```

মনে রাখবেন যে enum এর variant গুলি তার শনাক্তকারীর অধীনে namespaced করা হয়েছে এবং আমরা দুটিকে আলাদা করতে একটি ডাবল কোলন ব্যবহার করি। এটি কার্যকর কারণ এখন `IpAddrKind::V4` এবং `IpAddrKind::V6` উভয় মান একই প্রকারের: `IpAddrKind`। তারপরে, উদাহরণস্বরূপ, আমরা এমন একটি ফাংশন সংজ্ঞায়িত করতে পারি যা যেকোনো `IpAddrKind` নেয়:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn}}
```

এবং আমরা এই ফাংশনটিকে যেকোনো variant দিয়ে কল করতে পারি:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-01-defining-enums/src/main.rs:fn_call}}
```

enums ব্যবহারের আরও বেশি সুবিধা রয়েছে। আমাদের IP ঠিকানা টাইপ নিয়ে আরও বেশি চিন্তা করলে, এই মুহূর্তে আমাদের কাছে আসল IP ঠিকানা _ডেটা_ স্টোর করার কোনো উপায় নেই; আমরা শুধুমাত্র জানি এটি কী _ধরনের_। যেহেতু আপনি Chapter 5 এ structs সম্পর্কে শিখেছেন, তাই আপনি Listing 6-1 এ দেখানো হিসাবে structs ব্যবহার করে এই সমস্যার সমাধান করতে প্রলুব্ধ হতে পারেন।

<Listing number="6-1" caption="একটি `struct` ব্যবহার করে একটি IP ঠিকানার ডেটা এবং `IpAddrKind` variant স্টোর করা">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-01/src/main.rs:here}}
```

</Listing>

এখানে, আমরা একটি struct `IpAddr` সংজ্ঞায়িত করেছি যার দুটি ফিল্ড রয়েছে: একটি `kind` ফিল্ড যা `IpAddrKind` (enum যা আমরা পূর্বে সংজ্ঞায়িত করেছি) প্রকারের এবং একটি `address` ফিল্ড `String` প্রকারের। এই struct এর আমাদের দুটি instance আছে। প্রথমটি হল `home` এবং এর `kind` হিসাবে `IpAddrKind::V4` মান রয়েছে যার সাথে `127.0.0.1` এর associated ঠিকানা ডেটা রয়েছে। দ্বিতীয় instance টি হল `loopback`। এর `kind` মান হিসাবে `IpAddrKind` এর অন্য variant, `V6` রয়েছে এবং এর সাথে ঠিকানা `::1` যুক্ত আছে। আমরা `kind` এবং `address` মানগুলিকে একসাথে বান্ডেল করতে একটি struct ব্যবহার করেছি, তাই এখন variant মানটির সাথে যুক্ত।

তবে, শুধু একটি enum ব্যবহার করে একই ধারণাটি প্রকাশ করা আরও সংক্ষিপ্ত: struct এর ভিতরে একটি enum এর পরিবর্তে, আমরা প্রতিটি enum variant এ সরাসরি ডেটা রাখতে পারি। `IpAddr` enum এর এই নতুন সংজ্ঞা বলে যে `V4` এবং `V6` উভয় variant এর সাথেই associated `String` মান থাকবে:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-02-enum-with-data/src/main.rs:here}}
```

আমরা সরাসরি enum এর প্রতিটি variant এ ডেটা যুক্ত করি, তাই অতিরিক্ত struct এর প্রয়োজন নেই। এখানে, enums কিভাবে কাজ করে তার আরেকটি বিবরণ দেখা সহজ: আমরা সংজ্ঞায়িত করা প্রতিটি enum variant এর নামও একটি ফাংশন হয়ে যায় যা enum এর একটি instance তৈরি করে। অর্থাৎ, `IpAddr::V4()` হল একটি ফাংশন কল যা একটি `String` আর্গুমেন্ট নেয় এবং `IpAddr` টাইপের একটি instance ফেরত দেয়। আমরা স্বয়ংক্রিয়ভাবে enum সংজ্ঞায়িত করার ফলস্বরূপ এই কনস্ট্রাক্টর ফাংশনটি সংজ্ঞায়িত পাই।

struct এর পরিবর্তে একটি enum ব্যবহারের আরেকটি সুবিধা আছে: প্রতিটি variant এর বিভিন্ন প্রকার এবং associated ডেটার পরিমাণ থাকতে পারে। সংস্করণ চার IP ঠিকানাগুলির সর্বদা চারটি সংখ্যাসূচক উপাদান থাকবে যার মান 0 এবং 255 এর মধ্যে থাকবে। যদি আমরা `V4` ঠিকানাগুলিকে চারটি `u8` মান হিসাবে স্টোর করতে চাই কিন্তু তবুও `V6` ঠিকানাগুলিকে একটি `String` মান হিসাবে প্রকাশ করতে চাই, তবে আমরা এটি একটি struct দিয়ে করতে পারব না। Enums এই ক্ষেত্রে সহজে কাজ করে:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-03-variants-with-different-data/src/main.rs:here}}
```

আমরা সংস্করণ চার এবং সংস্করণ ছয় IP ঠিকানাগুলি স্টোর করার জন্য ডেটা স্ট্রাকচার সংজ্ঞায়িত করার জন্য বিভিন্ন উপায় দেখিয়েছি। তবে, দেখা যাচ্ছে, IP ঠিকানাগুলি স্টোর করতে এবং সেগুলি কী ধরনের তা এনকোড করতে চাওয়া এত সাধারণ যে [standard library তে একটি সংজ্ঞা আছে যা আমরা ব্যবহার করতে পারি!][IpAddr]<!-- ignore --> আসুন দেখি standard library কিভাবে `IpAddr` সংজ্ঞায়িত করে: আমাদের সংজ্ঞায়িত এবং ব্যবহৃত enum এবং variant গুলি ঠিক তেমনই আছে, কিন্তু এটি দুটি ভিন্ন struct এর আকারে variant গুলির ভিতরে ঠিকানা ডেটা এমবেড করে, যা প্রতিটি variant এর জন্য ভিন্নভাবে সংজ্ঞায়িত করা হয়:

```rust
struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
```

এই কোডটি দেখায় যে আপনি একটি enum variant এর ভিতরে যেকোনো ধরনের ডেটা রাখতে পারেন: স্ট্রিং, সংখ্যাসূচক প্রকার বা struct, উদাহরণস্বরূপ। আপনি এমনকি অন্য enum ও অন্তর্ভুক্ত করতে পারেন! এছাড়াও, standard library এর প্রকারগুলি প্রায়শই আপনি যা তৈরি করতে পারেন তার চেয়ে বেশি জটিল হয় না।

মনে রাখবেন যে standard library তে `IpAddr` এর একটি সংজ্ঞা থাকা সত্ত্বেও, আমরা এখনও কোনো দ্বন্দ্ব ছাড়াই আমাদের নিজস্ব সংজ্ঞা তৈরি এবং ব্যবহার করতে পারি কারণ আমরা standard library এর সংজ্ঞাটিকে আমাদের scope এ আনিনি। আমরা Chapter 7 এ scope এ প্রকারগুলি আনা নিয়ে আরও আলোচনা করব।

আসুন Listing 6-2 এ enums এর আরও একটি উদাহরণ দেখি: এটিতে বিভিন্ন ধরনের প্রকার তার variant গুলিতে এমবেড করা আছে।

<Listing number="6-2" caption="একটি `Message` enum যার প্রত্যেকটি variant বিভিন্ন পরিমাণ এবং প্রকারের মান স্টোর করে">

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-02/src/main.rs:here}}
```

</Listing>

এই enum টির বিভিন্ন প্রকারের চারটি variant রয়েছে:

- `Quit` এর সাথে কোনো ডেটা যুক্ত নেই।
- `Move` এর নামযুক্ত ফিল্ড রয়েছে, যেমন একটি struct এর থাকে।
- `Write` এ একটি একক `String` অন্তর্ভুক্ত রয়েছে।
- `ChangeColor` এ তিনটি `i32` মান অন্তর্ভুক্ত রয়েছে।

Listing 6-2 এর মতো variant সহ একটি enum সংজ্ঞায়িত করা বিভিন্ন ধরণের struct সংজ্ঞা সংজ্ঞায়িত করার মতোই, শুধু enum `struct` কীওয়ার্ড ব্যবহার করে না এবং সমস্ত variant `Message` টাইপের অধীনে একসাথে গোষ্ঠীভুক্ত করা হয়েছে। নিম্নলিখিত structs পূর্ববর্তী enum variant গুলি ধারণ করে এমন একই ডেটা ধারণ করতে পারে:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-04-structs-similar-to-message-enum/src/main.rs:here}}
```

কিন্তু যদি আমরা বিভিন্ন structs ব্যবহার করি, যার প্রত্যেকটির নিজস্ব প্রকার আছে, তবে আমরা `Message` enum এর মতো এই ধরনের যেকোনো message নিতে একটি ফাংশন সংজ্ঞায়িত করতে পারতাম না, যা একটি একক প্রকার।

enums এবং structs এর মধ্যে আরও একটি মিল রয়েছে: ঠিক যেমন আমরা `impl` ব্যবহার করে structs এ methods সংজ্ঞায়িত করতে সক্ষম, তেমনি আমরা enums এও methods সংজ্ঞায়িত করতে সক্ষম। এখানে `call` নামের একটি method রয়েছে যা আমরা আমাদের `Message` enum এ সংজ্ঞায়িত করতে পারি:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-05-methods-on-enums/src/main.rs:here}}
```

method এর বডি `self` ব্যবহার করে সেই মানটি পাবে যার উপর আমরা method টি কল করেছি। এই উদাহরণে, আমরা একটি ভেরিয়েবল `m` তৈরি করেছি যার মান `Message::Write(String::from("hello"))`, এবং যখন `m.call()` রান হয় তখন `call` method এর বডিতে `self` সেটাই হবে।

আসুন standard library তে থাকা আরেকটি enum দেখি যা খুব সাধারণ এবং কার্যকর: `Option`।

### `Option` Enum এবং Null মানের চেয়ে এর সুবিধা

এই বিভাগে `Option` এর একটি কেস স্টাডি অন্বেষণ করা হয়েছে, যা standard library দ্বারা সংজ্ঞায়িত আরেকটি enum। `Option` টাইপটি সেই সাধারণ পরিস্থিতিটিকে এনকোড করে যেখানে একটি মান কিছু হতে পারে বা কিছুই না হতে পারে।

উদাহরণস্বরূপ, যদি আপনি একটি অ-খালি তালিকার প্রথম আইটেমটির জন্য অনুরোধ করেন, তবে আপনি একটি মান পাবেন। আপনি যদি একটি খালি তালিকার প্রথম আইটেমটির জন্য অনুরোধ করেন তবে আপনি কিছুই পাবেন না। টাইপ সিস্টেমের পরিপ্রেক্ষিতে এই ধারণাটি প্রকাশ করার অর্থ হল কম্পাইলার পরীক্ষা করতে পারে যে আপনি সমস্ত ক্ষেত্রে হ্যান্ডেল করেছেন কিনা যা আপনার পরিচালনা করা উচিত; এই কার্যকারিতা অন্যান্য প্রোগ্রামিং ভাষায় অত্যন্ত সাধারণ বাগগুলি প্রতিরোধ করতে পারে।

প্রোগ্রামিং ভাষার নকশাকে প্রায়শই সেই বৈশিষ্ট্যগুলির পরিপ্রেক্ষিতে চিন্তা করা হয় যা আপনি অন্তর্ভুক্ত করেন, তবে আপনি যে বৈশিষ্ট্যগুলি বাদ দেন সেগুলিও গুরুত্বপূর্ণ। Rust এ null বৈশিষ্ট্য নেই যা অন্যান্য অনেক ভাষায় আছে। _Null_ হল একটি মান যার মানে সেখানে কোনো মান নেই। null সহ ভাষাগুলিতে, ভেরিয়েবলগুলি সর্বদা দুটি অবস্থার মধ্যে একটিতে থাকতে পারে: null বা non-null।

তাঁর 2009 সালের উপস্থাপনা "Null References: The Billion Dollar Mistake"-এ null এর উদ্ভাবক টনি হোয়ারের বলার আছে:

> আমি এটাকে আমার বিলিয়ন ডলারের ভুল বলি। সেই সময়, আমি একটি অবজেক্ট-ওরিয়েন্টেড ভাষায় রেফারেন্সের জন্য প্রথম ব্যাপক টাইপ সিস্টেম ডিজাইন করছিলাম। আমার লক্ষ্য ছিল নিশ্চিত করা যে রেফারেন্সের সমস্ত ব্যবহার একেবারে নিরাপদ হওয়া উচিত, কম্পাইলার দ্বারা স্বয়ংক্রিয়ভাবে চেকিং করা হবে। কিন্তু আমি একটি null reference ঢোকানোর লোভ সামলাতে পারিনি, কারণ এটি প্রয়োগ করা এত সহজ ছিল। এর ফলে অসংখ্য ত্রুটি, দুর্বলতা এবং সিস্টেম ক্র্যাশ হয়েছে, যা সম্ভবত গত চল্লিশ বছরে বিলিয়ন ডলারের ক্ষতি করেছে।

Null মানের সমস্যা হল যদি আপনি একটি null মানকে not-null মান হিসাবে ব্যবহার করার চেষ্টা করেন তবে আপনি কোনো না কোনো ধরনের ত্রুটি পাবেন। যেহেতু এই null বা not-null বৈশিষ্ট্যটি সর্বত্র বিদ্যমান, তাই এই ধরনের ত্রুটি করা অত্যন্ত সহজ।

তবে, null যে ধারণাটি প্রকাশ করার চেষ্টা করছে তা এখনও একটি কার্যকর ধারণা: একটি null হল একটি মান যা বর্তমানে অবৈধ বা কোনো কারণে অনুপস্থিত।

সমস্যাটি আসলে ধারণার সাথে নয় বরং নির্দিষ্ট প্রয়োগের সাথে। যেমন, Rust এ nulls নেই, তবে এর একটি enum আছে যা একটি মানের উপস্থিতি বা অনুপস্থিতির ধারণাটিকে এনকোড করতে পারে। এই enum টি হল `Option<T>` এবং এটি [standard library দ্বারা সংজ্ঞায়িত][option]<!-- ignore --> করা হয়েছে এইভাবে:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T>` enum এতটাই কার্যকর যে এটি এমনকি prelude তেও অন্তর্ভুক্ত; আপনাকে এটিকে স্পষ্টভাবে scope এ আনার প্রয়োজন নেই। এর variant গুলিও prelude তে অন্তর্ভুক্ত করা হয়েছে: আপনি `Option::` উপসর্গ ছাড়াই `Some` এবং `None` সরাসরি ব্যবহার করতে পারেন। `Option<T>` enum এখনও একটি নিয়মিত enum, এবং `Some(T)` এবং `None` এখনও `Option<T>` টাইপের variant।

`<T>` সিনট্যাক্স Rust এর একটি বৈশিষ্ট্য যা নিয়ে আমরা এখনও কথা বলিনি। এটি একটি জেনেরিক টাইপ প্যারামিটার এবং আমরা Chapter 10 এ জেনেরিক নিয়ে আরও বিস্তারিত আলোচনা করব। আপাতত, আপনার যা জানা দরকার তা হল `<T>` এর মানে হল `Option` enum এর `Some` variant যেকোনো প্রকারের একটি ডেটা ধারণ করতে পারে এবং `T` এর জায়গায় ব্যবহৃত প্রতিটি নির্দিষ্ট প্রকার `Option<T>` প্রকারটিকে একটি ভিন্ন প্রকার করে তোলে। এখানে সংখ্যা প্রকার এবং char প্রকার ধারণ করার জন্য `Option` মানগুলি ব্যবহার করার কিছু উদাহরণ দেওয়া হল:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-06-option-examples/src/main.rs:here}}
```

`some_number` এর প্রকার হল `Option<i32>`। `some_char` এর প্রকার হল `Option<char>`, যা একটি ভিন্ন প্রকার। Rust এই প্রকারগুলি অনুমান করতে পারে কারণ আমরা `Some` variant এর ভিতরে একটি মান নির্দিষ্ট করেছি। `absent_number` এর জন্য, Rust এর সামগ্রিক `Option` প্রকারটি annotation করার জন্য আমাদের প্রয়োজন: কম্পাইলার শুধুমাত্র `None` মান দেখে সংশ্লিষ্ট `Some` variant টি কী ধারণ করবে তা অনুমান করতে পারে না। এখানে, আমরা Rust কে বলি যে আমরা `absent_number` কে `Option<i32>` প্রকারের হতে চাই।

যখন আমাদের কাছে একটি `Some` মান থাকে, তখন আমরা জানি যে একটি মান উপস্থিত আছে এবং মানটি `Some` এর মধ্যে ধারণ করা আছে। যখন আমাদের কাছে `None` মান থাকে, তখন কোনো অর্থে এর অর্থ null এর মতোই: আমাদের কাছে কোনো বৈধ মান নেই। তাহলে, `Option<T>` থাকা null থাকার চেয়ে ভাল কেন?

সংক্ষেপে, কারণ `Option<T>` এবং `T` (যেখানে `T` যেকোনো প্রকার হতে পারে) ভিন্ন প্রকার, কম্পাইলার আমাদের `Option<T>` মানটিকে এমনভাবে ব্যবহার করতে দেবে না যেন এটি অবশ্যই একটি বৈধ মান। উদাহরণস্বরূপ, এই কোডটি কম্পাইল হবে না, কারণ এটি একটি `i8` কে `Option<i8>` এর সাথে যোগ করার চেষ্টা করছে:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/src/main.rs:here}}
```

যদি আমরা এই কোডটি চালাই, তবে আমরা এইরকম একটি ত্রুটি বার্তা পাব:

```console
{{#include ../listings/ch06-enums-and-pattern-matching/no-listing-07-cant-use-option-directly/output.txt}}
```

গুরুতর! কার্যকরভাবে, এই ত্রুটি বার্তার অর্থ হল Rust একটি `i8` এবং একটি `Option<i8>` কিভাবে যোগ করতে হয় তা বুঝতে পারে না, কারণ সেগুলি ভিন্ন প্রকার। যখন Rust এ `i8` এর মতো কোনো প্রকারের মান থাকে, তখন কম্পাইলার নিশ্চিত করবে যে আমাদের কাছে সবসময় একটি বৈধ মান আছে। সেই মানটি ব্যবহার করার আগে null এর জন্য পরীক্ষা না করেই আমরা আত্মবিশ্বাসের সাথে কাজ করতে পারি। শুধুমাত্র যখন আমাদের একটি `Option<i8>` (বা আমরা যে ধরনের মান নিয়ে কাজ করছি) থাকে, তখনই আমাদের কোনো মান না থাকার বিষয়ে চিন্তা করতে হয় এবং কম্পাইলার নিশ্চিত করবে যে মানটি ব্যবহার করার আগে আমরা সেই ক্ষেত্রটি পরিচালনা করেছি।

অন্য কথায়, আপনি এর সাথে `T` অপারেশন করার আগে আপনাকে একটি `Option<T>` কে `T` তে রূপান্তর করতে হবে। সাধারণভাবে, এটি null এর সাথে সবচেয়ে সাধারণ সমস্যাগুলির মধ্যে একটি ধরতে সাহায্য করে: যখন এটি আসলে null হয় তখন এমন কিছু ধরে নেওয়া যা null নয়।

একটি not-null মান ভুলভাবে অনুমান করার ঝুঁকি দূর করা আপনাকে আপনার কোডে আরও আত্মবিশ্বাসী হতে সাহায্য করে। এমন একটি মান পেতে যা সম্ভবত null হতে পারে, আপনাকে সেই মানের প্রকারটিকে `Option<T>` করে স্পষ্টভাবে অপ্ট ইন করতে হবে। তারপরে, যখন আপনি সেই মানটি ব্যবহার করেন, তখন মানটি null হলে সেই ক্ষেত্রটিকে স্পষ্টভাবে পরিচালনা করতে বলা হয়। যেখানেই একটি মানের এমন প্রকার আছে যা `Option<T>` নয়, সেখানে আপনি নিরাপদে ধরে নিতে _পারেন_ যে মানটি null নয়। Rust এর জন্য এটি একটি ইচ্ছাকৃত নকশার সিদ্ধান্ত ছিল যাতে null এর ব্যাপকতা সীমিত করা যায় এবং Rust কোডের নিরাপত্তা বাড়ানো যায়।

তাহলে, যখন আপনার কাছে `Option<T>` টাইপের মান থাকে, তখন আপনি `Some` variant থেকে `T` মানটি কিভাবে পাবেন যাতে আপনি সেই মানটি ব্যবহার করতে পারেন? `Option<T>` enum এর অনেক পদ্ধতি আছে যা বিভিন্ন পরিস্থিতিতে কার্যকর; আপনি [এর ডকুমেন্টেশনে][docs]<!-- ignore --> সেগুলি দেখতে পারেন। `Option<T>` এর পদ্ধতিগুলির সাথে পরিচিত হওয়া Rust এর সাথে আপনার যাত্রায় অত্যন্ত কার্যকর হবে।

সাধারণভাবে, একটি `Option<T>` মান ব্যবহার করার জন্য, আপনি এমন কোড রাখতে চান যা প্রতিটি variant পরিচালনা করবে। আপনি এমন কিছু কোড চান যা শুধুমাত্র তখনই রান হবে যখন আপনার কাছে একটি `Some(T)` মান থাকে এবং এই কোডটিকে ভিতরের `T` ব্যবহার করার অনুমতি দেওয়া হয়। আপনি অন্য কিছু কোড চান যা শুধুমাত্র তখনই রান হবে যদি আপনার কাছে একটি `None` মান থাকে এবং সেই কোডে কোনো `T` মান উপলব্ধ না থাকে। `match` এক্সপ্রেশন হল একটি কন্ট্রোল ফ্লো কনস্ট্রাক্ট যা enums এর সাথে ব্যবহার করা হলে ঠিক এটিই করে: এটি enum এর কোন variant আছে তার উপর নির্ভর করে বিভিন্ন কোড চালাবে এবং সেই কোডটি matching মানের ভিতরের ডেটা ব্যবহার করতে পারে।

[IpAddr]: ../std/net/enum.IpAddr.html
[option]: ../std/option/enum.Option.html
[docs]: ../std/option/enum.Option.html
