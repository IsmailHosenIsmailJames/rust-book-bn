## ফাংশন

ফাংশন Rust কোডে প্রচলিত। আপনি ইতিমধ্যেই ভাষার সবচেয়ে গুরুত্বপূর্ণ ফাংশনগুলির একটি দেখেছেন: `main` ফাংশন, যা অনেক প্রোগ্রামের প্রবেশদ্বার। আপনি `fn` কীওয়ার্ডও দেখেছেন, যা আপনাকে নতুন ফাংশন ঘোষণা করতে দেয়।

Rust কোড ফাংশন এবং ভেরিয়েবলের নামের জন্য প্রচলিত শৈলী হিসাবে _স্নেক কেস_ ব্যবহার করে, যেখানে সমস্ত অক্ষর ছোট হাতের হয় এবং আন্ডারস্কোর শব্দগুলিকে আলাদা করে। এখানে একটি প্রোগ্রাম রয়েছে যাতে একটি উদাহরণ ফাংশন সংজ্ঞা রয়েছে:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-16-functions/src/main.rs}}
```

আমরা Rust-এ একটি ফাংশন সংজ্ঞায়িত করি `fn` লেখার মাধ্যমে, তারপরে একটি ফাংশনের নাম এবং প্যারেনথেসিসের একটি সেট লিখি। কার্লি বন্ধনী কম্পাইলারকে বলে যে ফাংশন বডি কোথায় শুরু এবং শেষ হয়।

আমরা প্যারেনথেসিসের একটি সেট অনুসরণ করে এর নাম প্রবেশ করে আমরা সংজ্ঞায়িত করা যেকোনো ফাংশনকে কল করতে পারি। যেহেতু `another_function` প্রোগ্রামে সংজ্ঞায়িত করা হয়েছে, তাই এটিকে `main` ফাংশনের ভিতর থেকে কল করা যেতে পারে। মনে রাখবেন যে আমরা সোর্স কোডে `main` ফাংশনের _পরে_ `another_function` সংজ্ঞায়িত করেছি; আমরা এটি আগে সংজ্ঞায়িত করতে পারতাম। Rust আপনার ফাংশনগুলি কোথায় সংজ্ঞায়িত করেন তা নিয়ে চিন্তা করে না, শুধুমাত্র সেগুলি এমন একটি স্কোপে সংজ্ঞায়িত করা হয়েছে কিনা যা কলার দ্বারা দেখা যায়।

আসুন ফাংশনগুলি আরও অন্বেষণ করতে _functions_ নামের একটি নতুন বাইনারি প্রকল্প শুরু করি। `another_function` উদাহরণটি _src/main.rs_-এ রাখুন এবং এটি চালান। আপনি নিম্নলিখিত আউটপুট দেখতে পাবেন:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-16-functions/output.txt}}
```

লাইনগুলি `main` ফাংশনে যেভাবে প্রদর্শিত হয় সেই ক্রমে এক্সিকিউট হয়। প্রথমে "Hello, world!" বার্তা প্রিন্ট হয় এবং তারপর `another_function` কল করা হয় এবং এর বার্তা প্রিন্ট করা হয়।

### প্যারামিটার

আমরা ফাংশনগুলিকে _প্যারামিটার_ রাখার জন্য সংজ্ঞায়িত করতে পারি, যা বিশেষ ভেরিয়েবল যা একটি ফাংশনের স্বাক্ষরের অংশ। যখন একটি ফাংশনে প্যারামিটার থাকে, তখন আপনি সেই প্যারামিটারগুলির জন্য এটিকে নির্দিষ্ট মান সরবরাহ করতে পারেন। কারিগরিভাবে, নির্দিষ্ট মানগুলিকে _আর্গুমেন্ট_ বলা হয়, তবে সাধারণ কথোপকথনে, লোকেরা একটি ফাংশনের সংজ্ঞায় ভেরিয়েবল বা যখন আপনি একটি ফাংশনকে কল করেন তখন পাস করা নির্দিষ্ট মানগুলির জন্য _প্যারামিটার_ এবং _আর্গুমেন্ট_ শব্দগুলি পরস্পর পরিবর্তনযোগ্যভাবে ব্যবহার করে।

`another_function` এর এই সংস্করণে আমরা একটি প্যারামিটার যোগ করি:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/src/main.rs}}
```

এই প্রোগ্রামটি চালানোর চেষ্টা করুন; আপনি নিম্নলিখিত আউটপুট পাবেন:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/output.txt}}
```

`another_function` এর ঘোষণায় `x` নামের একটি প্যারামিটার রয়েছে। `x` এর টাইপ `i32` হিসাবে নির্দিষ্ট করা হয়েছে। যখন আমরা `another_function`-এ `5` পাস করি, তখন `println!` ম্যাক্রোটি ফরম্যাট স্ট্রিং-এ `x` ধারণকারী কার্লি বন্ধনীর জোড়াটি যেখানে ছিল সেখানে `5` রাখে।

ফাংশন স্বাক্ষরে, আপনাকে _অবশ্যই_ প্রতিটি প্যারামিটারের প্রকার ঘোষণা করতে হবে। এটি Rust-এর ডিজাইনের একটি ইচ্ছাকৃত সিদ্ধান্ত: ফাংশন সংজ্ঞায় টাইপ টীকাগুলির প্রয়োজন হওয়ার অর্থ হল কম্পাইলারকে আপনি কোন প্রকারটি বোঝাতে চেয়েছেন তা বের করার জন্য কোডের অন্য কোথাও সেগুলি ব্যবহার করার প্রয়োজন প্রায় কখনও হয় না। কম্পাইলার আরও সহায়ক ত্রুটি বার্তা দিতে সক্ষম যদি এটি জানে যে ফাংশনটি কোন প্রকারগুলি আশা করে।

একাধিক প্যারামিটার সংজ্ঞায়িত করার সময়, প্যারামিটার ঘোষণাগুলিকে কমা দিয়ে আলাদা করুন, যেমন:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/src/main.rs}}
```

এই উদাহরণটি `print_labeled_measurement` নামের একটি ফাংশন তৈরি করে দুটি প্যারামিটার সহ। প্রথম প্যারামিটারটির নাম `value` এবং এটি একটি `i32`। দ্বিতীয়টির নাম `unit_label` এবং এটি `char` টাইপের। ফাংশনটি তখন `value` এবং `unit_label` উভয়ই ধারণকারী টেক্সট প্রিন্ট করে।

আসুন এই কোডটি চালানোর চেষ্টা করি। আপনার _functions_ প্রকল্পের _src/main.rs_ ফাইলে বর্তমানে থাকা প্রোগ্রামটিকে পূর্ববর্তী উদাহরণ দিয়ে প্রতিস্থাপন করুন এবং `cargo run` ব্যবহার করে এটি চালান:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/output.txt}}
```

যেহেতু আমরা ফাংশনটিকে `value` এর মান হিসাবে `5` এবং `unit_label` এর মান হিসাবে `'h'` দিয়ে কল করেছি, তাই প্রোগ্রাম আউটপুটে সেই মানগুলি রয়েছে।

### স্টেটমেন্ট এবং এক্সপ্রেশন

ফাংশন বডিগুলি ঐচ্ছিকভাবে একটি এক্সপ্রেশনে শেষ হওয়া স্টেটমেন্টগুলির একটি সিরিজ দিয়ে গঠিত। এখন পর্যন্ত, আমরা যে ফাংশনগুলি কভার করেছি তাতে কোনও শেষ এক্সপ্রেশন অন্তর্ভুক্ত নেই, তবে আপনি একটি স্টেটমেন্টের অংশ হিসাবে একটি এক্সপ্রেশন দেখেছেন। যেহেতু Rust একটি এক্সপ্রেশন-ভিত্তিক ভাষা, তাই এটি বোঝার জন্য একটি গুরুত্বপূর্ণ পার্থক্য। অন্যান্য ভাষার একই পার্থক্য নেই, তাই আসুন দেখি স্টেটমেন্ট এবং এক্সপ্রেশন কী এবং তাদের পার্থক্যগুলি কীভাবে ফাংশনের বডিগুলিকে প্রভাবিত করে।

- **স্টেটমেন্ট** হল নির্দেশাবলী যা কিছু কাজ করে এবং মান রিটার্ন করে না।
- **এক্সপ্রেশন** একটি ফলস্বরূপ মান মূল্যায়ন করে। আসুন কিছু উদাহরণ দেখি।

আমরা আসলে ইতিমধ্যেই স্টেটমেন্ট এবং এক্সপ্রেশন ব্যবহার করেছি। `let` কীওয়ার্ড দিয়ে একটি ভেরিয়েবল তৈরি করা এবং এটিকে একটি মান নির্ধারণ করা একটি স্টেটমেন্ট। Listing 3-1 এ, `let y = 6;` একটি স্টেটমেন্ট।

<Listing number="3-1" file-name="src/main.rs" caption="একটি স্টেটমেন্ট ধারণকারী একটি `main` ফাংশন ঘোষণা">

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-01/src/main.rs}}
```

</Listing>

ফাংশন সংজ্ঞাগুলিও স্টেটমেন্ট; পুরো পূর্ববর্তী উদাহরণটি নিজেই একটি স্টেটমেন্ট। (আমরা নীচে দেখব, একটি ফাংশনকে _কল_ করা কোনো স্টেটমেন্ট নয়।)

স্টেটমেন্টগুলি মান রিটার্ন করে না। অতএব, আপনি অন্য ভেরিয়েবলে একটি `let` স্টেটমেন্ট অ্যাসাইন করতে পারবেন না, যেমনটি নিম্নলিখিত কোডটি করার চেষ্টা করে; আপনি একটি ত্রুটি পাবেন:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/src/main.rs}}
```

আপনি যখন এই প্রোগ্রামটি চালাবেন, তখন আপনি যে ত্রুটি পাবেন তা এইরকম দেখাবে:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/output.txt}}
```

`let y = 6` স্টেটমেন্ট কোনো মান রিটার্ন করে না, তাই `x`-এর সাথে বাইন্ড করার মতো কিছুই নেই। এটি অন্যান্য ভাষা, যেমন C এবং Ruby-তে যা ঘটে তার থেকে আলাদা, যেখানে অ্যাসাইনমেন্ট অ্যাসাইনমেন্টের মান রিটার্ন করে। সেই ভাষাগুলিতে, আপনি `x = y = 6` লিখতে পারেন এবং `x` এবং `y` উভয়েরই মান `6` হবে; Rust-এ তা নয়।

এক্সপ্রেশনগুলি একটি মান মূল্যায়ন করে এবং Rust-এ আপনি যে কোড লিখবেন তার বেশিরভাগ অংশ তৈরি করে। একটি গাণিতিক অপারেশন বিবেচনা করুন, যেমন `5 + 6`, যা একটি এক্সপ্রেশন যা `11` মানটিকে মূল্যায়ন করে। এক্সপ্রেশনগুলি স্টেটমেন্টের অংশ হতে পারে: Listing 3-1 এ, `let y = 6;` স্টেটমেন্টে `6` হল একটি এক্সপ্রেশন যা `6` মানটিকে মূল্যায়ন করে। একটি ফাংশনকে কল করা একটি এক্সপ্রেশন। একটি ম্যাক্রো কল করা একটি এক্সপ্রেশন। কার্লি বন্ধনী দিয়ে তৈরি একটি নতুন স্কোপ ব্লক একটি এক্সপ্রেশন, উদাহরণস্বরূপ:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-20-blocks-are-expressions/src/main.rs}}
```

এই এক্সপ্রেশন:

```rust,ignore
{
    let x = 3;
    x + 1
}
```

একটি ব্লক যা, এই ক্ষেত্রে, `4` তে মূল্যায়ন করে। সেই মানটি `let` স্টেটমেন্টের অংশ হিসাবে `y` এর সাথে আবদ্ধ হয়। মনে রাখবেন যে `x + 1` লাইনের শেষে একটি সেমিকোলন নেই, যা আপনি এখন পর্যন্ত দেখেছেন এমন বেশিরভাগ লাইনের থেকে আলাদা। এক্সপ্রেশনগুলিতে শেষ সেমিকোলন অন্তর্ভুক্ত থাকে না। আপনি যদি একটি এক্সপ্রেশনের শেষে একটি সেমিকোলন যোগ করেন তবে আপনি এটিকে একটি স্টেটমেন্টে পরিণত করেন এবং এটি তখন কোনও মান রিটার্ন করবে না। আপনি যখন ফাংশনের রিটার্ন মান এবং এক্সপ্রেশনগুলি অন্বেষণ করেন তখন এটি মনে রাখবেন।

### রিটার্ন মান সহ ফাংশন

ফাংশনগুলি যে কোড তাদেরকে কল করে সেই কোডে মান রিটার্ন করতে পারে। আমরা রিটার্ন মানগুলির নাম দিই না, তবে আমাদের একটি তীর (`->`) এর পরে তাদের প্রকার ঘোষণা করতে হবে। Rust এ, ফাংশনের রিটার্ন মান একটি ফাংশনের বডির ব্লকের শেষ এক্সপ্রেশনের মানের সমার্থক। আপনি `return` কীওয়ার্ড ব্যবহার করে এবং একটি মান নির্দিষ্ট করে একটি ফাংশন থেকে তাড়াতাড়ি রিটার্ন করতে পারেন, তবে বেশিরভাগ ফাংশন শেষ এক্সপ্রেশনটি পরোক্ষভাবে রিটার্ন করে। এখানে একটি ফাংশনের উদাহরণ দেওয়া হল যা একটি মান রিটার্ন করে:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/src/main.rs}}
```

`five` ফাংশনে কোনো ফাংশন কল, ম্যাক্রো বা `let` স্টেটমেন্টও নেই—শুধু একা `5` সংখ্যাটি। এটি Rust-এ একটি নিখুঁত বৈধ ফাংশন। মনে রাখবেন যে ফাংশনের রিটার্ন টাইপটিও `-> i32` হিসাবে নির্দিষ্ট করা হয়েছে। এই কোডটি চালানোর চেষ্টা করুন; আউটপুটটি এইরকম হওয়া উচিত:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/output.txt}}
```

`five`-এ `5` হল ফাংশনের রিটার্ন মান, যে কারণে রিটার্ন টাইপ হল `i32`। আসুন এটি আরও বিস্তারিতভাবে পরীক্ষা করি। দুটি গুরুত্বপূর্ণ অংশ রয়েছে: প্রথমত, `let x = five();` লাইনটি দেখায় যে আমরা একটি ভেরিয়েবল শুরু করতে একটি ফাংশনের রিটার্ন মান ব্যবহার করছি। যেহেতু `five` ফাংশনটি `5` রিটার্ন করে, সেই লাইনটি নিম্নলিখিতটির মতোই:

```rust
let x = 5;
```

দ্বিতীয়ত, `five` ফাংশনে কোনো প্যারামিটার নেই এবং রিটার্ন মানের প্রকার সংজ্ঞায়িত করে, তবে ফাংশনের বডিটি একটি সেমিকোলন ছাড়া একটি নিঃসঙ্গ `5` কারণ এটি এমন একটি এক্সপ্রেশন যার মান আমরা রিটার্ন করতে চাই।

আসুন আরও একটি উদাহরণ দেখি:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-22-function-parameter-and-return/src/main.rs}}
```

এই কোডটি চালালে `The value of x is: 6` প্রিন্ট হবে। কিন্তু যদি আমরা `x + 1` ধারণকারী লাইনের শেষে একটি সেমিকোলন রাখি, এটিকে এক্সপ্রেশন থেকে স্টেটমেন্টে পরিবর্তন করি, তাহলে আমরা একটি ত্রুটি পাব:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/src/main.rs}}
```

এই কোডটি কম্পাইল করলে নিম্নলিখিত হিসাবে একটি ত্রুটি তৈরি হয়:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/output.txt}}
```

`mismatched types` মূল ত্রুটি বার্তাটি এই কোডের মূল সমস্যাটি প্রকাশ করে। `plus_one` ফাংশনের সংজ্ঞা বলে যে এটি একটি `i32` রিটার্ন করবে, কিন্তু স্টেটমেন্টগুলি একটি মান মূল্যায়ন করে না, যা `()` ইউনিট টাইপ দ্বারা প্রকাশ করা হয়। অতএব, কিছুই রিটার্ন হয় না, যা ফাংশনের সংজ্ঞার সাথে সাংঘর্ষিক এবং এর ফলে একটি ত্রুটি দেখা যায়। এই আউটপুটে, Rust সম্ভবত এই সমস্যাটি সংশোধন করতে সাহায্য করার জন্য একটি বার্তা প্রদান করে: এটি সেমিকোলন সরানোর পরামর্শ দেয়, যা ত্রুটিটি ঠিক করবে।
