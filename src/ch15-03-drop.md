## `Drop` Trait ব্যবহার করে ক্লিনআপের জন্য কোড চালানো

স্মার্ট পয়েন্টার প্যাটার্নের জন্য গুরুত্বপূর্ণ দ্বিতীয় trait হল `Drop`, যা আপনাকে একটি ভ্যালু যখন স্কোপের বাইরে যেতে চলেছে তখন কী ঘটবে তা কাস্টমাইজ করতে দেয়। আপনি যেকোনো টাইপের উপর `Drop` trait-এর জন্য একটি বাস্তবায়ন প্রদান করতে পারেন, এবং সেই কোড ফাইল বা নেটওয়ার্ক সংযোগের মতো রিসোর্স মুক্ত করতে ব্যবহার করা যেতে পারে।

স্মার্ট পয়েন্টারের প্রেক্ষাপটে আমরা `Drop` trait-এর পরিচয় দিচ্ছি কারণ `Drop` trait-এর কার্যকারিতা প্রায় সবসময়ই একটি স্মার্ট পয়েন্টার বাস্তবায়ন করার সময় ব্যবহার করা হয়। উদাহরণস্বরূপ, যখন একটি `Box<T>` ড্রপ করা হয়, তখন এটি হিপের সেই স্থানটিকে ডি-অ্যালোকেট করে দেয় যেখানে বক্সটি নির্দেশ করে।

কিছু ভাষায়, কিছু টাইপের জন্য, প্রোগ্রামারকে মেমরি বা রিসোর্স মুক্ত করার জন্য কোড কল করতে হয় প্রতিবার যখন তারা সেই টাইপগুলোর উদাহরণ ব্যবহার করা শেষ করে। উদাহরণগুলির মধ্যে রয়েছে ফাইল হ্যান্ডেল, সকেট বা লক। যদি তারা ভুলে যায়, তবে সিস্টেম ওভারলোড হয়ে ক্র্যাশ করতে পারে। Rust-এ, আপনি নির্দিষ্ট করতে পারেন যে একটি বিশেষ কোড বিট কখন রান হবে যখন একটি ভ্যালু স্কোপের বাইরে চলে যায় এবং কম্পাইলার স্বয়ংক্রিয়ভাবে এই কোডটি প্রবেশ করাবে। ফলস্বরূপ, একটি প্রোগ্রামে যেখানে একটি বিশেষ টাইপের উদাহরণ ব্যবহার করা শেষ হয়ে গেছে সেখানে সর্বত্র ক্লিনআপ কোড স্থাপন করার বিষয়ে আপনাকে সতর্ক হওয়ার দরকার নেই — আপনি এখনও রিসোর্স লিক করবেন না!

যখন একটি ভ্যালু স্কোপের বাইরে চলে যায় তখন কোড রান করার জন্য `Drop` trait প্রয়োগ করে নির্দিষ্ট করতে হয়। `Drop` trait-এর জন্য `drop` নামের একটি পদ্ধতি প্রয়োগ করতে হয় যা `self`-এর একটি পরিবর্তনযোগ্য রেফারেন্স নেয়। Rust কখন `drop` কল করে তা দেখতে, আসুন আমরা এখন `println!` স্টেটমেন্ট দিয়ে `drop` প্রয়োগ করি।

Listing 15-14 একটি `CustomSmartPointer` স্ট্রাক্ট দেখায় যার একমাত্র কাস্টম কার্যকারিতা হল যখন উদাহরণটি স্কোপের বাইরে চলে যায় তখন এটি `Dropping CustomSmartPointer!` প্রিন্ট করবে, যাতে দেখা যায় Rust কখন `drop` ফাংশন চালায়।

<Listing number="15-14" file-name="src/main.rs" caption="একটি `CustomSmartPointer` স্ট্রাক্ট যা `Drop` trait প্রয়োগ করে যেখানে আমরা আমাদের ক্লিনআপ কোড রাখব">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-14/src/main.rs}}
```

</Listing>

`Drop` trait prelude-এ অন্তর্ভুক্ত করা হয়েছে, তাই আমাদের এটিকে স্কোপে আনার প্রয়োজন নেই। আমরা `CustomSmartPointer`-এ `Drop` trait প্রয়োগ করি এবং `drop` পদ্ধতির জন্য একটি বাস্তবায়ন প্রদান করি যা `println!` কল করে। `drop` ফাংশনের বডি হল সেই জায়গা যেখানে আপনি আপনার টাইপের একটি উদাহরণ স্কোপের বাইরে গেলে আপনি যে কোনো লজিক চালাতে চান তা রাখবেন। Rust কখন `drop` কল করবে তা দৃশ্যমানভাবে দেখানোর জন্য আমরা এখানে কিছু টেক্সট প্রিন্ট করছি।

`main`-এ, আমরা `CustomSmartPointer`-এর দুটি উদাহরণ তৈরি করি এবং তারপর `CustomSmartPointers created` প্রিন্ট করি। `main`-এর শেষে, `CustomSmartPointer`-এর আমাদের উদাহরণগুলো স্কোপের বাইরে চলে যাবে, এবং Rust `drop` পদ্ধতিতে আমরা যে কোডটি রেখেছি তা কল করবে, আমাদের চূড়ান্ত বার্তাটি প্রিন্ট করবে। উল্লেখ্য যে আমাদের স্পষ্টভাবে `drop` পদ্ধতি কল করার প্রয়োজন ছিল না।

যখন আমরা এই প্রোগ্রামটি চালাব, তখন আমরা নিম্নলিখিত আউটপুট দেখতে পাব:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-14/output.txt}}
```

Rust স্বয়ংক্রিয়ভাবে আমাদের উদাহরণগুলো স্কোপের বাইরে চলে গেলে আমাদের জন্য `drop` কল করেছে এবং আমরা যে কোডটি নির্দিষ্ট করেছি তা কল করেছে। ভেরিয়েবলগুলি তাদের তৈরির বিপরীত ক্রমে ড্রপ করা হয়, তাই `c`-এর আগে `d` ড্রপ করা হয়েছিল। এই উদাহরণের উদ্দেশ্য হল আপনাকে `drop` পদ্ধতি কীভাবে কাজ করে তার একটি ভিজ্যুয়াল গাইড দেওয়া; সাধারণত আপনি একটি প্রিন্ট বার্তার পরিবর্তে আপনার টাইপের রান করার জন্য প্রয়োজনীয় ক্লিনআপ কোড নির্দিষ্ট করবেন।

### `std::mem::drop` দিয়ে একটি ভ্যালুকে আগে ড্রপ করা

দুর্ভাগ্যবশত, স্বয়ংক্রিয় `drop` কার্যকারিতা নিষ্ক্রিয় করা সহজ নয়। `drop` নিষ্ক্রিয় করা সাধারণত প্রয়োজনীয় নয়; `Drop` trait-এর মূল বিষয় হল এটি স্বয়ংক্রিয়ভাবে যত্ন নেওয়া হয়। মাঝে মাঝে, আপনি হয়ত আগে একটি ভ্যালু পরিষ্কার করতে চাইতে পারেন। একটি উদাহরণ হল যখন স্মার্ট পয়েন্টারগুলি ব্যবহার করে লক পরিচালনা করা হয়: আপনি হয়তো `drop` পদ্ধতি প্রয়োগ করতে চান যা লকটি ছেড়ে দেয় যাতে একই স্কোপের অন্যান্য কোড লকটি অর্জন করতে পারে। Rust আপনাকে `Drop` trait-এর `drop` পদ্ধতি ম্যানুয়ালি কল করতে দেয় না; পরিবর্তে আপনি যদি কোনো ভ্যালুকে তার স্কোপের শেষ হওয়ার আগে ড্রপ করতে চান তবে আপনাকে স্ট্যান্ডার্ড লাইব্রেরি দ্বারা প্রদত্ত `std::mem::drop` ফাংশন কল করতে হবে।

যদি আমরা Listing 15-14 থেকে `main` ফাংশন পরিবর্তন করে `Drop` trait-এর `drop` পদ্ধতি ম্যানুয়ালি কল করার চেষ্টা করি, যেমন Listing 15-15-এ দেখানো হয়েছে, তাহলে আমরা একটি কম্পাইলার এরর পাব:

<Listing number="15-15" file-name="src/main.rs" caption="আগে পরিষ্কার করার জন্য `Drop` trait থেকে `drop` পদ্ধতি ম্যানুয়ালি কল করার চেষ্টা করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-15/src/main.rs:here}}
```

</Listing>

যখন আমরা এই কোডটি কম্পাইল করার চেষ্টা করব, তখন আমরা এই এররটি পাব:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-15/output.txt}}
```

এই এরর মেসেজটি বলছে যে আমাদের স্পষ্টভাবে `drop` কল করার অনুমতি নেই। এরর মেসেজটি _ডিস্ট্রাক্টর_ শব্দটি ব্যবহার করে, যা একটি ফাংশনের জন্য সাধারণ প্রোগ্রামিং শব্দ যা একটি উদাহরণের পরিষ্কার করে। একটি _ডিস্ট্রাক্টর_ একটি _কনস্ট্রাকটরের_ অনুরূপ, যা একটি উদাহরণ তৈরি করে। Rust-এ `drop` ফাংশন হল একটি বিশেষ ডিস্ট্রাক্টর।

Rust আমাদের স্পষ্টভাবে `drop` কল করতে দেয় না কারণ `main`-এর শেষে Rust এখনও স্বয়ংক্রিয়ভাবে ভ্যালুটির উপর `drop` কল করবে। এটি একটি _ডাবল ফ্রি_ এরর সৃষ্টি করবে কারণ Rust একই ভ্যালুকে দুবার পরিষ্কার করার চেষ্টা করবে।

যখন একটি ভ্যালু স্কোপের বাইরে চলে যায় তখন `drop`-এর স্বয়ংক্রিয় প্রবেশ আমরা নিষ্ক্রিয় করতে পারি না, এবং আমরা স্পষ্টভাবে `drop` পদ্ধতি কল করতে পারি না। সুতরাং, যদি আমাদের কোনো ভ্যালুকে আগে পরিষ্কার করতে হয়, তাহলে আমরা `std::mem::drop` ফাংশন ব্যবহার করি।

`std::mem::drop` ফাংশনটি `Drop` trait-এর `drop` পদ্ধতি থেকে আলাদা। আমরা যে ভ্যালুটিকে ড্রপ করতে চাই তা আর্গুমেন্ট হিসেবে পাস করে আমরা এটিকে কল করি। ফাংশনটি prelude-এ আছে, তাই আমরা Listing 15-15-এ `main` পরিবর্তন করে `drop` ফাংশন কল করতে পারি, যেমনটি Listing 15-16-এ দেখানো হয়েছে:

<Listing number="15-16" file-name="src/main.rs" caption="স্কোপের বাইরে যাওয়ার আগে একটি ভ্যালুকে স্পষ্টভাবে ড্রপ করার জন্য `std::mem::drop` কল করা">

```rust
{{#rustdoc_include ../listings/ch15-smart-pointers/listing-15-16/src/main.rs:here}}
```

</Listing>

এই কোডটি চালালে নিম্নলিখিত প্রিন্ট হবে:

```console
{{#include ../listings/ch15-smart-pointers/listing-15-16/output.txt}}
```

`CustomSmartPointer` তৈরি করা হয়েছে। এবং `CustomSmartPointer` `some data` ডেটা সহ ড্রপ করা হচ্ছে! এই টেক্সটটি `CustomSmartPointer created.` এবং `CustomSmartPointer dropped before the end of main.` টেক্সটের মধ্যে প্রিন্ট করা হয়েছে, যা দেখায় যে `drop` পদ্ধতি কোড সেই সময়ে `c` ড্রপ করার জন্য কল করা হয়েছে।

আপনি অনেক উপায়ে সুবিধাজনক এবং নিরাপদ ক্লিনআপ করতে `Drop` trait বাস্তবায়নে নির্দিষ্ট করা কোড ব্যবহার করতে পারেন: উদাহরণস্বরূপ, আপনি নিজের মেমরি অ্যালোকেটর তৈরি করতে এটি ব্যবহার করতে পারেন! `Drop` trait এবং Rust-এর মালিকানা সিস্টেমের সাথে, আপনাকে পরিষ্কার করার কথা মনে রাখতে হবে না কারণ Rust স্বয়ংক্রিয়ভাবে এটি করে।

এছাড়াও আপনাকে এখনও ব্যবহার করা হচ্ছে এমন ভ্যালুগুলিকে ভুলবশত পরিষ্কার করার ফলে সৃষ্ট সমস্যাগুলি নিয়ে চিন্তা করতে হবে না: মালিকানা সিস্টেম যা নিশ্চিত করে যে রেফারেন্সগুলি সর্বদা বৈধ, এটিও নিশ্চিত করে যে যখন ভ্যালুটি আর ব্যবহার করা হচ্ছে না তখন `drop` শুধুমাত্র একবার কল করা হয়।

যেহেতু আমরা `Box<T>` এবং স্মার্ট পয়েন্টারের কিছু বৈশিষ্ট্য পরীক্ষা করেছি, তাই আসুন স্ট্যান্ডার্ড লাইব্রেরিতে সংজ্ঞায়িত আরও কয়েকটি স্মার্ট পয়েন্টার দেখি।
