## টেস্ট অর্গানাইজেশন

এই অধ্যায়ের শুরুতে যেমনটি উল্লেখ করা হয়েছে, টেস্টিং একটি জটিল বিষয় এবং বিভিন্ন মানুষ বিভিন্ন পরিভাষা ও সংগঠন ব্যবহার করে। Rust কমিউনিটি টেস্টগুলোকে প্রধানত দুটি ভাগে ভাগ করে: ইউনিট টেস্ট (unit tests) এবং ইন্টিগ্রেশন টেস্ট (integration tests)। _ইউনিট টেস্ট_ ছোট এবং বেশি ফোকাসড হয়, যা একবারে একটি মডিউলকে আলাদাভাবে পরীক্ষা করে এবং প্রাইভেট ইন্টারফেসও (private interfaces) পরীক্ষা করতে পারে। _ইন্টিগ্রেশন টেস্ট_ আপনার লাইব্রেরির সম্পূর্ণ বাইরে থাকে এবং আপনার কোডকে অন্য যেকোনো এক্সটার্নাল কোডের মতোই ব্যবহার করে, শুধুমাত্র পাবলিক ইন্টারফেস ব্যবহার করে এবং প্রতিটি টেস্টে একাধিক মডিউল পরীক্ষা করতে পারে।

আপনার লাইব্রেরির অংশগুলো আলাদাভাবে এবং একসঙ্গে প্রত্যাশা অনুযায়ী কাজ করছে কিনা তা নিশ্চিত করার জন্য উভয় প্রকারের টেস্ট লেখাই গুরুত্বপূর্ণ।

### ইউনিট টেস্ট

ইউনিট টেস্টের উদ্দেশ্য হলো কোডের প্রতিটি ইউনিটকে বাকি কোড থেকে বিচ্ছিন্নভাবে পরীক্ষা করা, যাতে কোডের কোথায় প্রত্যাশা অনুযায়ী কাজ করছে এবং কোথায় করছে না তা দ্রুত চিহ্নিত করা যায়। আপনি ইউনিট টেস্টগুলোকে _src_ ডিরেক্টরিতে প্রতিটি ফাইলের মধ্যে রাখবেন, যে কোডটি তারা পরীক্ষা করছে তার সাথে। প্রচলিত নিয়ম হলো, টেস্ট ফাংশনগুলো রাখার জন্য প্রতিটি ফাইলে `tests` নামে একটি মডিউল তৈরি করা এবং মডিউলটিকে `cfg(test)` দিয়ে অ্যানোটেট করা।

#### tests মডিউল এবং `#[cfg(test)]`

`tests` মডিউলের উপর `#[cfg(test)]` অ্যানোটেশনটি Rust-কে বলে যে শুধুমাত্র `cargo test` চালানোর সময় টেস্ট কোড কম্পাইল এবং রান করতে হবে, `cargo build` চালানোর সময় নয়। এটি কম্পাইলের সময় বাঁচায় যখন আপনি কেবল লাইব্রেরি তৈরি করতে চান এবং ফলে তৈরি হওয়া কম্পাইল্ড আর্টিফ্যাক্টে জায়গা বাঁচায় কারণ টেস্টগুলো অন্তর্ভুক্ত থাকে না। আপনি দেখবেন যে ইন্টিগ্রেশন টেস্টগুলো একটি ভিন্ন ডিরেক্টরিতে যাওয়ায় তাদের `#[cfg(test)]` অ্যানোটেশনের প্রয়োজন হয় না। তবে, যেহেতু ইউনিট টেস্টগুলো কোডের সাথে একই ফাইলে থাকে, তাই কম্পাইল্ড ফলাফলে সেগুলো অন্তর্ভুক্ত করা উচিত নয় তা নির্দিষ্ট করতে আপনি `#[cfg(test)]` ব্যবহার করবেন।

স্মরণ করুন, এই অধ্যায়ের প্রথম বিভাগে যখন আমরা নতুন `adder` প্রজেক্ট তৈরি করেছিলাম, Cargo আমাদের জন্য এই কোডটি তৈরি করেছিল:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

স্বয়ংক্রিয়ভাবে জেনারেট হওয়া `tests` মডিউলে, `cfg` অ্যাট্রিবিউটটি _configuration_ (কনফিগারেশন) বোঝায় এবং Rust-কে বলে যে নিম্নলিখিত আইটেমটি শুধুমাত্র একটি নির্দিষ্ট কনফিগারেশন অপশন দেওয়া থাকলেই অন্তর্ভুক্ত করা উচিত। এক্ষেত্রে, কনফিগারেশন অপশনটি হলো `test`, যা Rust দ্বারা টেস্ট কম্পাইল এবং চালানোর জন্য সরবরাহ করা হয়। `cfg` অ্যাট্রিবিউট ব্যবহার করে, Cargo আমাদের টেস্ট কোড শুধুমাত্র তখনই কম্পাইল করে যখন আমরা `cargo test` দিয়ে সক্রিয়ভাবে টেস্ট চালাই। এর মধ্যে `#[test]` দিয়ে অ্যানোটেট করা ফাংশনগুলো ছাড়াও এই মডিউলের মধ্যে থাকা যেকোনো সাহায্যকারী ফাংশন অন্তর্ভুক্ত থাকে।

#### প্রাইভেট ফাংশন টেস্ট করা

টেস্টিং কমিউনিটিতে প্রাইভেট ফাংশন সরাসরি পরীক্ষা করা উচিত কিনা তা নিয়ে বিতর্ক রয়েছে, এবং অন্যান্য ভাষা প্রাইভেট ফাংশন পরীক্ষা করা কঠিন বা অসম্ভব করে তোলে। আপনি যে টেস্টিং মতাদর্শই অনুসরণ করুন না কেন, Rust-এর প্রাইভেসি নিয়ম আপনাকে প্রাইভেট ফাংশন পরীক্ষা করার অনুমতি দেয়। তালিকা ১১-১২-এর কোডটি বিবেচনা করুন যেখানে `internal_adder` নামে একটি প্রাইভেট ফাংশন রয়েছে।

<Listing number="11-12" file-name="src/lib.rs" caption="একটি প্রাইভেট ফাংশন টেস্ট করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-12/src/lib.rs}}
```

</Listing>

লক্ষ্য করুন যে `internal_adder` ফাংশনটি `pub` হিসাবে চিহ্নিত নয়। টেস্টগুলো কেবল Rust কোড, এবং `tests` মডিউলটি কেবল আরেকটি মডিউল। যেমনটি আমরা ["Paths for Referring to an Item in the Module Tree"][paths]<!-- ignore -->-তে আলোচনা করেছি, চাইল্ড মডিউলের আইটেমগুলো তাদের পূর্বপুরুষ মডিউলের আইটেমগুলো ব্যবহার করতে পারে। এই টেস্টে, আমরা `use super::*` দিয়ে `tests` মডিউলের প্যারেন্টের সমস্ত আইটেমকে স্কোপে নিয়ে আসি এবং তারপর টেস্টটি `internal_adder` কল করতে পারে। আপনি যদি মনে করেন যে প্রাইভেট ফাংশন পরীক্ষা করা উচিত নয়, তবে Rust-এ এমন কিছুই নেই যা আপনাকে তা করতে বাধ্য করবে।

### ইন্টিগ্রেশন টেস্ট

Rust-এ, ইন্টিগ্রেশন টেস্টগুলো আপনার লাইব্রেরির সম্পূর্ণ বাইরে থাকে। তারা আপনার লাইব্রেরিটি অন্য যেকোনো কোডের মতোই ব্যবহার করে, যার মানে তারা কেবল সেই ফাংশনগুলোকেই কল করতে পারে যা আপনার লাইব্রেরির পাবলিক API-এর অংশ। তাদের উদ্দেশ্য হলো আপনার লাইব্রেরির অনেকগুলো অংশ একসাথে সঠিকভাবে কাজ করছে কিনা তা পরীক্ষা করা। যে কোডের ইউনিটগুলো একা একা সঠিকভাবে কাজ করে, সেগুলো ইন্টিগ্রেট করার সময় সমস্যা হতে পারে, তাই ইন্টিগ্রেটেড কোডের টেস্ট কভারেজও গুরুত্বপূর্ণ। ইন্টিগ্রেশন টেস্ট তৈরি করতে, আপনাকে প্রথমে একটি _tests_ ডিরেক্টরি তৈরি করতে হবে।

#### tests ডিরেক্টরি

আমরা আমাদের প্রজেক্ট ডিরেক্টরির টপ লেভেলে, _src_ এর পাশে একটি _tests_ ডিরেক্টরি তৈরি করি। Cargo জানে যে এই ডিরেক্টরিতে ইন্টিগ্রেশন টেস্ট ফাইল খুঁজতে হবে। আমরা তখন যত খুশি টেস্ট ফাইল তৈরি করতে পারি, এবং Cargo প্রতিটি ফাইলকে একটি স্বতন্ত্র ক্রেট (crate) হিসাবে কম্পাইল করবে।

চলুন একটি ইন্টিগ্রেশন টেস্ট তৈরি করি। তালিকা ১১-১২-এর কোডটি এখনও _src/lib.rs_ ফাইলে থাকা অবস্থায়, একটি _tests_ ডিরেক্টরি তৈরি করুন এবং _tests/integration_test.rs_ নামে একটি নতুন ফাইল তৈরি করুন। আপনার ডিরেক্টরি কাঠামোটি এমন হওয়া উচিত:

```text
adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
```

তালিকা ১১-১৩-এর কোডটি _tests/integration_test.rs_ ফাইলে প্রবেশ করান।

<Listing number="11-13" file-name="tests/integration_test.rs" caption="`adder` ক্রেটের একটি ফাংশনের ইন্টিগ্রেশন টেস্ট">

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-13/tests/integration_test.rs}}
```

</Listing>

_tests_ ডিরেক্টরির প্রতিটি ফাইল একটি পৃথক ক্রেট, তাই আমাদের প্রতিটি টেস্ট ক্রেটের স্কোপে আমাদের লাইব্রেরি আনতে হবে। এই কারণে আমরা কোডের শীর্ষে `use adder;` যোগ করি, যা ইউনিট টেস্টে আমাদের প্রয়োজন হয়নি।

আমাদের _tests/integration_test.rs_-এর কোনো কোডকে `#[cfg(test)]` দিয়ে অ্যানোটেট করার প্রয়োজন নেই। Cargo _tests_ ডিরেক্টরিকে বিশেষভাবে বিবেচনা করে এবং এই ডিরেক্টরির ফাইলগুলো শুধুমাত্র `cargo test` চালানোর সময় কম্পাইল করে। এখন `cargo test` চালান:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-13/output.txt}}
```

আউটপুটের তিনটি অংশে ইউনিট টেস্ট, ইন্টিগ্রেশন টেস্ট এবং ডক টেস্ট অন্তর্ভুক্ত রয়েছে। উল্লেখ্য, যদি কোনো একটি বিভাগের কোনো টেস্ট ফেইল করে, তাহলে পরবর্তী বিভাগগুলো চালানো হবে না। উদাহরণস্বরূপ, যদি একটি ইউনিট টেস্ট ফেইল করে, তাহলে ইন্টিগ্রেশন এবং ডক টেস্টের জন্য কোনো আউটপুট থাকবে না কারণ সেই টেস্টগুলো শুধুমাত্র তখনই চালানো হবে যদি সমস্ত ইউনিট টেস্ট পাস করে।

ইউনিট টেস্টের জন্য প্রথম বিভাগটি আমরা যা দেখে আসছি তার মতোই: প্রতিটি ইউনিট টেস্টের জন্য একটি লাইন (একটি `internal` নামের যা আমরা তালিকা ১১-১২-এ যোগ করেছি) এবং তারপর ইউনিট টেস্টের জন্য একটি সারাংশ লাইন।

ইন্টিগ্রেশন টেস্ট বিভাগটি `Running tests/integration_test.rs` লাইন দিয়ে শুরু হয়। এরপর, সেই ইন্টিগ্রেশন টেস্টের প্রতিটি টেস্ট ফাংশনের জন্য একটি লাইন এবং `Doc-tests adder` বিভাগ শুরু হওয়ার ঠিক আগে ইন্টিগ্রেশন টেস্টের ফলাফলের জন্য একটি সারাংশ লাইন রয়েছে।

প্রতিটি ইন্টিগ্রেশন টেস্ট ফাইলের নিজস্ব বিভাগ রয়েছে, তাই আমরা যদি _tests_ ডিরেক্টরিতে আরও ফাইল যোগ করি, তাহলে আরও ইন্টিগ্রেশন টেস্ট বিভাগ থাকবে।

আমরা এখনও `cargo test`-এর আর্গুমেন্ট হিসাবে টেস্ট ফাংশনের নাম উল্লেখ করে একটি নির্দিষ্ট ইন্টিগ্রেশন টেস্ট ফাংশন চালাতে পারি। একটি নির্দিষ্ট ইন্টিগ্রেশন টেস্ট ফাইলের সমস্ত টেস্ট চালানোর জন্য, `cargo test`-এর `--test` আর্গুমেন্ট এবং তারপরে ফাইলের নাম ব্যবহার করুন:

```console
{{#include ../listings/ch11-writing-automated-tests/output-only-05-single-integration/output.txt}}
```

এই কমান্ডটি শুধুমাত্র _tests/integration_test.rs_ ফাইলের টেস্টগুলো চালায়।

#### ইন্টিগ্রেশন টেস্টে সাবমডিউল

আপনি যখন আরও ইন্টিগ্রেশন টেস্ট যোগ করবেন, তখন সেগুলোকে সংগঠিত করতে সাহায্য করার জন্য আপনি _tests_ ডিরেক্টরিতে আরও ফাইল তৈরি করতে চাইতে পারেন; উদাহরণস্বরূপ, আপনি যে কার্যকারিতা পরীক্ষা করছেন তার উপর ভিত্তি করে টেস্ট ফাংশনগুলোকে গ্রুপ করতে পারেন। আগে যেমন উল্লেখ করা হয়েছে, _tests_ ডিরেক্টরির প্রতিটি ফাইল তার নিজস্ব পৃথক ক্রেট হিসাবে কম্পাইল করা হয়, যা পৃথক স্কোপ তৈরি করার জন্য দরকারী যাতে শেষ ব্যবহারকারীরা আপনার ক্রেট কীভাবে ব্যবহার করবে তার আরও কাছাকাছি অনুকরণ করা যায়। যাইহোক, এর মানে হল _tests_ ডিরেক্টরির ফাইলগুলো _src_-এর ফাইলগুলোর মতো একই আচরণ শেয়ার করে না, যেমনটি আপনি অধ্যায় ৭-এ শিখেছিলেন কিভাবে কোডকে মডিউল এবং ফাইলে বিভক্ত করতে হয়।

_tests_ ডিরেক্টরির ফাইলগুলোর ভিন্ন আচরণ সবচেয়ে বেশি লক্ষণীয় হয় যখন আপনার কাছে একাধিক ইন্টিগ্রেশন টেস্ট ফাইলে ব্যবহার করার জন্য একসেট সাহায্যকারী ফাংশন থাকে এবং আপনি সেগুলোকে একটি সাধারণ মডিউলে বের করে আনার জন্য অধ্যায় ৭-এর ["Separating Modules into Different Files"][separating-modules-into-files]<!-- ignore --> বিভাগের ধাপগুলো অনুসরণ করার চেষ্টা করেন। উদাহরণস্বরূপ, যদি আমরা _tests/common.rs_ তৈরি করি এবং এতে `setup` নামে একটি ফাংশন রাখি, আমরা `setup`-এ কিছু কোড যোগ করতে পারি যা আমরা একাধিক টেস্ট ফাইলের একাধিক টেস্ট ফাংশন থেকে কল করতে চাই:

<span class="filename">Filename: tests/common.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/tests/common.rs}}
```

যখন আমরা আবার টেস্টগুলো চালাই, আমরা টেস্ট আউটপুটে _common.rs_ ফাইলের জন্য একটি নতুন বিভাগ দেখতে পাব, যদিও এই ফাইলে কোনো টেস্ট ফাংশন নেই এবং আমরা `setup` ফাংশনটি কোথাও থেকে কলও করিনি:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-12-shared-test-code-problem/output.txt}}
```

টেস্ট ফলাফলে `common` এর জন্য `running 0 tests` প্রদর্শিত হওয়াটা আমরা চাইনি। আমরা কেবল অন্য ইন্টিগ্রেশন টেস্ট ফাইলগুলোর সাথে কিছু কোড শেয়ার করতে চেয়েছিলাম। টেস্ট আউটপুটে `common` আসা এড়াতে, _tests/common.rs_ তৈরি করার পরিবর্তে, আমরা _tests/common/mod.rs_ তৈরি করব। প্রজেক্ট ডিরেক্টরি এখন এমন দেখাচ্ছে:

```text
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
```

এটি পুরনো নামকরণের নিয়ম যা Rust বোঝে এবং যা আমরা অধ্যায় ৭-এর ["Alternate File Paths"][alt-paths]<!-- ignore -->-এ উল্লেখ করেছি। ফাইলটিকে এইভাবে নামকরণ করা Rust-কে বলে যে `common` মডিউলটিকে একটি ইন্টিগ্রেশন টেস্ট ফাইল হিসাবে বিবেচনা না করতে। যখন আমরা `setup` ফাংশনের কোডটি _tests/common/mod.rs_-এ নিয়ে যাই এবং _tests/common.rs_ ফাইলটি মুছে ফেলি, তখন টেস্ট আউটপুটের বিভাগটি আর প্রদর্শিত হবে না। _tests_ ডিরেক্টরির সাবডিরেক্টরির ফাইলগুলো পৃথক ক্রেট হিসাবে কম্পাইল হয় না বা টেস্ট আউটপুটে তাদের বিভাগ থাকে না।

আমরা _tests/common/mod.rs_ তৈরি করার পরে, আমরা এটিকে যেকোনো ইন্টিগ্রেশন টেস্ট ফাইল থেকে একটি মডিউল হিসাবে ব্যবহার করতে পারি। এখানে _tests/integration_test.rs_-এর `it_adds_two` টেস্ট থেকে `setup` ফাংশন কল করার একটি উদাহরণ দেওয়া হলো:

<span class="filename">Filename: tests/integration_test.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-13-fix-shared-test-code-problem/tests/integration_test.rs}}
```

লক্ষ্য করুন যে `mod common;` ডিক্লারেশনটি আমরা তালিকা ৭-২১-এ দেখানো মডিউল ডিক্লারেশনের মতোই। তারপর, টেস্ট ফাংশনে, আমরা `common::setup()` ফাংশন কল করতে পারি।

#### বাইনারি ক্রেটের জন্য ইন্টিগ্রেশন টেস্ট

যদি আমাদের প্রজেক্টটি একটি বাইনারি ক্রেট হয় যাতে শুধুমাত্র একটি _src/main.rs_ ফাইল থাকে এবং কোনো _src/lib.rs_ ফাইল না থাকে, আমরা _tests_ ডিরেক্টরিতে ইন্টিগ্রেশন টেস্ট তৈরি করতে এবং _src/main.rs_ ফাইলে সংজ্ঞায়িত ফাংশনগুলোকে একটি `use` স্টেটমেন্ট দিয়ে স্কোপে আনতে পারি না। শুধুমাত্র লাইব্রেরি ক্রেটগুলো ফাংশন এক্সপোজ করে যা অন্যান্য ক্রেট ব্যবহার করতে পারে; বাইনারি ক্রেটগুলো নিজে থেকে চালানোর জন্য তৈরি।

এটি একটি কারণ যে কারণে Rust প্রজেক্ট যেগুলো একটি বাইনারি সরবরাহ করে, সেগুলোতে একটি সহজবোধ্য _src/main.rs_ ফাইল থাকে যা _src/lib.rs_ ফাইলে থাকা লজিককে কল করে। সেই কাঠামো ব্যবহার করে, ইন্টিগ্রেশন টেস্টগুলো `use` দিয়ে লাইব্রেরি ক্রেট পরীক্ষা করতে পারে যাতে গুরুত্বপূর্ণ কার্যকারিতা উপলব্ধ করা যায়। যদি গুরুত্বপূর্ণ কার্যকারিতা কাজ করে, তাহলে _src/main.rs_ ফাইলের অল্প পরিমাণ কোডও কাজ করবে, এবং সেই অল্প পরিমাণ কোড পরীক্ষা করার প্রয়োজন নেই।

## সারসংক্ষেপ

Rust-এর টেস্টিং ফিচারগুলো কোড কীভাবে কাজ করা উচিত তা নির্দিষ্ট করার একটি উপায় সরবরাহ করে যাতে আপনি পরিবর্তন করার পরেও এটি আপনার প্রত্যাশা অনুযায়ী কাজ করে তা নিশ্চিত করা যায়। ইউনিট টেস্টগুলো একটি লাইব্রেরির বিভিন্ন অংশকে আলাদাভাবে পরীক্ষা করে এবং প্রাইভেট ইমপ্লিমেন্টেশন ডিটেইলস পরীক্ষা করতে পারে। ইন্টিগ্রেশন টেস্টগুলো পরীক্ষা করে যে লাইব্রেরির অনেকগুলো অংশ একসাথে সঠিকভাবে কাজ করছে কিনা, এবং তারা লাইব্রেরির পাবলিক API ব্যবহার করে কোডটি সেভাবেই পরীক্ষা করে যেভাবে এক্সটার্নাল কোড এটি ব্যবহার করবে। যদিও Rust-এর টাইপ সিস্টেম এবং ওনারশিপ নিয়ম কিছু ধরণের বাগ প্রতিরোধ করতে সাহায্য করে, আপনার কোড কীভাবে আচরণ করবে বলে আশা করা হচ্ছে সে সম্পর্কিত লজিক বাগ কমাতে টেস্টগুলো এখনও গুরুত্বপূর্ণ।

চলুন এই অধ্যায়ে এবং পূর্ববর্তী অধ্যায়গুলোতে শেখা জ্ঞান একত্রিত করে একটি প্রজেক্টে কাজ করা যাক