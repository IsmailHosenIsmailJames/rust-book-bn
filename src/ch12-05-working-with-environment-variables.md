## এনভায়রনমেন্ট ভেরিয়েবল নিয়ে কাজ করা

আমরা `minigrep`-এ একটি অতিরিক্ত বৈশিষ্ট্য যোগ করে এটিকে উন্নত করব: একটি কেস-ইনসেনসিটিভ অনুসন্ধানের অপশন যা ব্যবহারকারী একটি এনভায়রনমেন্ট ভেরিয়েবলের মাধ্যমে চালু করতে পারে। আমরা এই বৈশিষ্ট্যটিকে একটি কমান্ড লাইন অপশন তৈরি করতে পারতাম এবং ব্যবহারকারীদের প্রতিবার এটি প্রয়োগ করতে চাইলে এটি প্রবেশ করতে বলতে পারতাম, তবে পরিবর্তে এটিকে একটি এনভায়রনমেন্ট ভেরিয়েবল তৈরি করে, আমরা আমাদের ব্যবহারকারীদের একবার এনভায়রনমেন্ট ভেরিয়েবল সেট করার এবং সেই টার্মিনাল সেশনে তাদের সমস্ত অনুসন্ধান কেস ইনসেনসিটিভ করার অনুমতি দিই।

### কেস-ইনসেনসিটিভ `search` ফাংশনের জন্য একটি ব্যর্থ পরীক্ষা লেখা

আমরা প্রথমে একটি নতুন `search_case_insensitive` ফাংশন যোগ করব যা এনভায়রনমেন্ট ভেরিয়েবলের ভ্যালু থাকলে কল করা হবে। আমরা TDD প্রক্রিয়া অনুসরণ করা চালিয়ে যাব, তাই প্রথম ধাপটি হল আবার একটি ব্যর্থ পরীক্ষা লেখা। আমরা নতুন `search_case_insensitive` ফাংশনের জন্য একটি নতুন পরীক্ষা যোগ করব এবং আমাদের পুরানো পরীক্ষাটিকে `one_result` থেকে `case_sensitive`-এ পরিবর্তন করব যাতে দুটি পরীক্ষার মধ্যে পার্থক্য স্পষ্ট করা যায়, যেমন Listing 12-20-এ দেখানো হয়েছে।

<Listing number="12-20" file-name="src/lib.rs" caption="আমরা যে কেস-ইনসেনসিটিভ ফাংশনটি যোগ করতে যাচ্ছি তার জন্য একটি নতুন ব্যর্থ পরীক্ষা যোগ করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-20/src/lib.rs:here}}
```

</Listing>

মনে রাখবেন যে আমরা পুরানো পরীক্ষার `contents`-ও পরিবর্তন করেছি। আমরা `"Duct tape."` টেক্সট সহ একটি নতুন লাইন যোগ করেছি যেখানে একটি বড় হাতের _D_ ব্যবহার করা হয়েছে যা কেস-সেনসিটিভ পদ্ধতিতে অনুসন্ধান করার সময় `“duct”` কোয়েরির সাথে মিলবে না। পুরানো পরীক্ষাটিকে এইভাবে পরিবর্তন করা নিশ্চিত করতে সাহায্য করে যে আমরা ভুল করে সেই কেস-সেনসিটিভ অনুসন্ধান কার্যকারিতা ভেঙে না দিই যা আমরা ইতিমধ্যেই প্রয়োগ করেছি। এই পরীক্ষাটি এখন পাস করা উচিত এবং কেস-ইনসেনসিটিভ অনুসন্ধানের উপর কাজ করার সময় এটি পাস করা চালিয়ে যাওয়া উচিত।

কেস-_ইনসেনসিটিভ_ অনুসন্ধানের নতুন পরীক্ষাটি এর কোয়েরি হিসাবে `"rUsT"` ব্যবহার করে। আমরা যে `search_case_insensitive` ফাংশনটি যোগ করতে যাচ্ছি তাতে, `"rUsT"` কোয়েরিটি বড় হাতের _R_ সহ `"Rust:"` ধারণকারী লাইনটির সাথে এবং `"Trust me."` লাইনটির সাথেও মিলবে যদিও উভয়েরই কোয়েরি থেকে আলাদা কেসিং আছে। এটি আমাদের ব্যর্থ পরীক্ষা এবং এটি কম্পাইল হতে ব্যর্থ হবে কারণ আমরা এখনও `search_case_insensitive` ফাংশন সংজ্ঞায়িত করিনি। পরীক্ষাটি কম্পাইল এবং ব্যর্থ হয়েছে কিনা তা দেখতে Listing 12-16-এ `search` ফাংশনের মতো একটি কাঠামো বাস্তবায়ন যোগ করতে পারেন যা সর্বদা একটি খালি ভেক্টর রিটার্ন করে।

### `search_case_insensitive` ফাংশন বাস্তবায়ন

Listing 12-21-এ দেখানো `search_case_insensitive` ফাংশনটি প্রায় `search` ফাংশনের মতোই হবে। একমাত্র পার্থক্য হল আমরা `query` এবং প্রতিটি `line`-কে ছোট হাতের অক্ষরে পরিবর্তন করব যাতে ইনপুট আর্গুমেন্টগুলোর কেসিং যাই হোক না কেন, লাইনটিতে কোয়েরি আছে কিনা তা পরীক্ষা করার সময় তারা একই কেসিং এ থাকে।

<Listing number="12-21" file-name="src/lib.rs" caption="`search_case_insensitive` ফাংশনটিকে সংজ্ঞায়িত করা যাতে তুলনা করার আগে কোয়েরি এবং লাইনটিকে ছোট হাতের অক্ষরে পরিবর্তন করা যায়">

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-21/src/lib.rs:here}}
```

</Listing>

প্রথমে আমরা `query` স্ট্রিংটিকে ছোট হাতের অক্ষরে পরিবর্তন করে একটি নতুন ভেরিয়েবলে স্টোর করি যার নাম একই, যা মূলটিকে শ্যাডো করে। কোয়েরিতে `to_lowercase` কল করা প্রয়োজন যাতে ব্যবহারকারীর কোয়েরি `"rust"`, `"RUST"`,
`"Rust"`, বা `"rUsT"` যাই হোক না কেন, আমরা কোয়েরিটিকে যেন `"rust"` হিসাবে বিবেচনা করব এবং কেসিং-এর প্রতি সংবেদনশীলতা দেখাব না। যদিও `to_lowercase` মৌলিক ইউনিকোড পরিচালনা করবে, এটি 100% সঠিক হবে না। যদি আমরা একটি বাস্তব অ্যাপ্লিকেশন লিখতাম, তাহলে আমাদের এখানে আরও একটু বেশি কাজ করতে হত, তবে এই বিভাগটি এনভায়রনমেন্ট ভেরিয়েবল সম্পর্কে, ইউনিকোড সম্পর্কে নয়, তাই আমরা এটিকে এখানেই রেখে দেব।

মনে রাখবেন যে `query` এখন স্ট্রিং স্লাইসের পরিবর্তে একটি `String`, কারণ `to_lowercase` কল করা বিদ্যমান ডেটার রেফারেন্স দেওয়ার পরিবর্তে নতুন ডেটা তৈরি করে। উদাহরণস্বরূপ, ধরা যাক কোয়েরিটি হল `"rUsT"`: সেই স্ট্রিং স্লাইসে ব্যবহার করার জন্য ছোট হাতের `u` বা `t` নেই, তাই আমাদের `"rust"` ধারণকারী একটি নতুন `String` বরাদ্দ করতে হবে। আমরা যখন `contains` মেথডে আর্গুমেন্ট হিসাবে `query` পাস করি, তখন আমাদের একটি অ্যামপারস্যান্ড যোগ করতে হবে কারণ `contains`-এর সিগনেচারটি একটি স্ট্রিং স্লাইস নেওয়ার জন্য সংজ্ঞায়িত করা হয়েছে।

এরপর, আমরা সমস্ত ক্যারেক্টারকে ছোট হাতের অক্ষরে পরিবর্তন করতে প্রতিটি `line`-এ `to_lowercase`-এ একটি কল যোগ করি। এখন যেহেতু আমরা `line` এবং `query`-কে ছোট হাতের অক্ষরে রূপান্তর করেছি, তাই কোয়েরির কেসিং যাই হোক না কেন আমরা মিল খুঁজে পাব।

দেখা যাক এই বাস্তবায়ন পরীক্ষাগুলো পাস করে কিনা:

```console
{{#include ../listings/ch12-an-io-project/listing-12-21/output.txt}}
```

চমৎকার! সেগুলো পাস হয়েছে। এখন, আসুন `run` ফাংশন থেকে নতুন `search_case_insensitive` ফাংশন কল করি। প্রথমে আমরা কেস-সংবেদনশীল এবং কেস-ইনসেনসিটিভ অনুসন্ধানের মধ্যে পরিবর্তন করার জন্য `Config` struct-এ একটি কনফিগারেশন অপশন যোগ করব। এই ফিল্ডটি যোগ করলে কম্পাইলার এরর তৈরি করবে কারণ আমরা এখনও কোথাও এই ফিল্ডটি শুরু করিনি:

<span class="filename">Filename: src/lib.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:here}}
```

আমরা একটি বুলিয়ান ধারণকারী `ignore_case` ফিল্ড যোগ করেছি। এরপর, `run` ফাংশনকে `ignore_case` ফিল্ডের ভ্যালু পরীক্ষা করতে হবে এবং সেটি ব্যবহার করে `search` ফাংশন বা `search_case_insensitive` ফাংশন কল করার সিদ্ধান্ত নিতে হবে, যেমন Listing 12-22-এ দেখানো হয়েছে। এটি এখনও কম্পাইল হবে না।

<Listing number="12-22" file-name="src/lib.rs" caption="`config.ignore_case`-এর ভ্যালুর উপর ভিত্তি করে হয় `search` অথবা `search_case_insensitive` কল করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/lib.rs:there}}
```

</Listing>

অবশেষে, আমাদের এনভায়রনমেন্ট ভেরিয়েবলটি পরীক্ষা করতে হবে। এনভায়রনমেন্ট ভেরিয়েবলগুলোর সাথে কাজ করার ফাংশনগুলো স্ট্যান্ডার্ড লাইব্রেরির `env` মডিউলে রয়েছে, তাই আমরা _src/lib.rs_-এর উপরে সেই মডিউলটিকে স্কোপে আনি। তারপর আমরা `env` মডিউল থেকে `var` ফাংশনটি ব্যবহার করে দেখব যে `IGNORE_CASE` নামের এনভায়রনমেন্ট ভেরিয়েবলের জন্য কোনো ভ্যালু সেট করা হয়েছে কিনা, যেমন Listing 12-23-এ দেখানো হয়েছে।

<Listing number="12-23" file-name="src/lib.rs" caption="`IGNORE_CASE` নামের একটি এনভায়রনমেন্ট ভেরিয়েবলে যেকোনো ভ্যালু পরীক্ষা করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-23/src/lib.rs:here}}
```

</Listing>

এখানে, আমরা একটি নতুন ভেরিয়েবল `ignore_case` তৈরি করি। এর ভ্যালু সেট করতে, আমরা `env::var` ফাংশনটি কল করি এবং এটিকে `IGNORE_CASE` এনভায়রনমেন্ট ভেরিয়েবলের নামটি পাস করি। যদি এনভায়রনমেন্ট ভেরিয়েবলটি কোনো ভ্যালুতে সেট করা থাকে তবে `env::var` ফাংশনটি একটি `Result` রিটার্ন করে যা সফল `Ok` ভেরিয়েন্ট হবে এবং এতে এনভায়রনমেন্ট ভেরিয়েবলের ভ্যালু থাকবে। যদি এনভায়রনমেন্ট ভেরিয়েবল সেট করা না থাকে তবে এটি `Err` ভেরিয়েন্ট রিটার্ন করবে।

আমরা `Result`-এর `is_ok` মেথডটি ব্যবহার করছি এনভায়রনমেন্ট ভেরিয়েবল সেট করা আছে কিনা তা পরীক্ষা করার জন্য, যার মানে প্রোগ্রামটিকে একটি কেস-ইনসেনসিটিভ অনুসন্ধান করা উচিত। যদি `IGNORE_CASE` এনভায়রনমেন্ট ভেরিয়েবল কোনো কিছুতে সেট করা না থাকে, তবে `is_ok` `false` রিটার্ন করবে এবং প্রোগ্রামটি একটি কেস-সেনসিটিভ অনুসন্ধান করবে। আমরা এনভায়রনমেন্ট ভেরিয়েবলের _ভ্যালু_ নিয়ে চিন্তা করি না, শুধু এটি সেট করা আছে কিনা বা সেট করা নেই কিনা তা নিয়ে চিন্তা করি, তাই আমরা `unwrap`, `expect` বা `Result`-এ আমরা দেখেছি এমন অন্য কোনো মেথড ব্যবহার করার পরিবর্তে `is_ok` পরীক্ষা করছি।

আমরা `ignore_case` ভেরিয়েবলের ভ্যালুটি `Config` ইনস্ট্যান্সে পাস করি যাতে `run` ফাংশনটি সেই ভ্যালু পড়তে পারে এবং `search_case_insensitive` বা `search` কল করতে হবে কিনা তা নির্ধারণ করতে পারে, যেমনটি আমরা Listing 12-22-এ প্রয়োগ করেছি।

আসুন চেষ্টা করে দেখি! প্রথমে আমরা এনভায়রনমেন্ট ভেরিয়েবল সেট না করে এবং `to` কোয়েরি দিয়ে আমাদের প্রোগ্রামটি চালাব, যা ছোট হাতের অক্ষরে _to_ শব্দটি ধারণকারী যেকোনো লাইনের সাথে মিলবে:

```console
{{#include ../listings/ch12-an-io-project/listing-12-23/output.txt}}
```

দেখে মনে হচ্ছে এখনও কাজ করছে! এখন আসুন `IGNORE_CASE`-কে `1`-এ সেট করে প্রোগ্রামটি চালাই, কিন্তু একই কোয়েরি _to_ দিয়ে:

```console
$ IGNORE_CASE=1 cargo run -- to poem.txt
```

আপনি যদি পাওয়ারশেল ব্যবহার করেন, তবে আপনাকে এনভায়রনমেন্ট ভেরিয়েবল সেট করতে হবে এবং প্রোগ্রামটি আলাদা কমান্ড হিসাবে চালাতে হবে:

```console
PS> $Env:IGNORE_CASE=1; cargo run -- to poem.txt
```

এটি আপনার শেল সেশনের বাকি অংশের জন্য `IGNORE_CASE` টিকে রাখবে। এটি `Remove-Item` cmdlet দিয়ে আনসেট করা যেতে পারে:

```console
PS> Remove-Item Env:IGNORE_CASE
```

আমাদের সেই লাইনগুলো পাওয়া উচিত যেগুলোতে বড় হাতের অক্ষরসহ _to_ আছে:

<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->

```console
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```

চমৎকার, আমরা _To_ ধারণকারী লাইনগুলোও পেয়েছি! আমাদের `minigrep` প্রোগ্রামটি এখন একটি এনভায়রনমেন্ট ভেরিয়েবল দ্বারা নিয়ন্ত্রিত কেস-ইনসেনসিটিভ অনুসন্ধান করতে পারে। এখন আপনি জানেন কিভাবে কমান্ড লাইন আর্গুমেন্ট বা এনভায়রনমেন্ট ভেরিয়েবল ব্যবহার করে সেট করা অপশনগুলো পরিচালনা করতে হয়।

কিছু প্রোগ্রাম একই কনফিগারেশনের জন্য আর্গুমেন্ট _এবং_ এনভায়রনমেন্ট ভেরিয়েবল উভয়কেই অনুমতি দেয়। সেই ক্ষেত্রে, প্রোগ্রামগুলো সিদ্ধান্ত নেয় যে একটি বা অন্যটি অগ্রাধিকার নেবে। আপনার নিজের জন্য আরেকটি অনুশীলন হিসাবে, একটি কমান্ড লাইন আর্গুমেন্ট বা একটি এনভায়রনমেন্ট ভেরিয়েবলের মাধ্যমে কেস সংবেদনশীলতা নিয়ন্ত্রণ করার চেষ্টা করুন। প্রোগ্রামটি যদি একটি কেস সংবেদনশীল এবং একটি কেস উপেক্ষা করার জন্য সেট করে চালানো হয় তবে কমান্ড লাইন আর্গুমেন্ট বা এনভায়রনমেন্ট ভেরিয়েবলের মধ্যে কোনটি অগ্রাধিকার পাবে তা সিদ্ধান্ত নিন।

`std::env` মডিউলে এনভায়রনমেন্ট ভেরিয়েবলগুলোর সাথে কাজ করার জন্য আরও অনেক দরকারী বৈশিষ্ট্য রয়েছে: কী উপলব্ধ আছে তা দেখতে এর ডকুমেন্টেশনটি দেখুন।
