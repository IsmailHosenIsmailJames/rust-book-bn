## এনভায়রনমেন্ট ভেরিয়েবল (Environment Variables) নিয়ে কাজ করা

আমরা `minigrep` বাইনারিটিকে একটি অতিরিক্ত ফিচার যোগ করে উন্নত করব: case-insensitive (ছোট বা বড় হাতের অক্ষর নির্বিশেষে) সার্চিংয়ের একটি অপশন, যা ব্যবহারকারী একটি এনভায়রনমেন্ট ভেরিয়েবলের মাধ্যমে চালু করতে পারবেন। আমরা এই ফিচারটিকে একটি কমান্ড লাইন অপশন হিসেবে তৈরি করতে পারতাম এবং ব্যবহারকারীদের প্রতিবার এটি ব্যবহার করার জন্য টাইপ করতে বলতে পারতাম। কিন্তু এর পরিবর্তে এটিকে একটি এনভায়রনমেন্ট ভেরিয়েবল হিসেবে তৈরি করার মাধ্যমে আমরা আমাদের ব্যবহারকারীদের একবার এনভায়রনমেন্ট ভেরিয়েবল সেট করার সুযোগ দিচ্ছি, এবং সেই টার্মিনাল সেশনে তাদের সমস্ত সার্চ case-insensitive হবে।

### Case-Insensitive `search` ফাংশনের জন্য একটি ফেইলিং টেস্ট লেখা

প্রথমে আমরা `minigrep` লাইব্রেরিতে একটি নতুন `search_case_insensitive` ফাংশন যোগ করব যা এনভায়রনমেন্ট ভেরিয়েবলের ভ্যালু থাকলে কল করা হবে। আমরা TDD প্রক্রিয়া অনুসরণ করা চালিয়ে যাব, তাই প্রথম ধাপটি হলো আবার একটি ফেইলিং টেস্ট লেখা। আমরা নতুন `search_case_insensitive` ফাংশনের জন্য একটি নতুন টেস্ট যোগ করব এবং আমাদের পুরনো টেস্টের নাম `one_result` থেকে `case_sensitive`-এ পরিবর্তন করব যাতে দুটি টেস্টের মধ্যে পার্থক্য স্পষ্ট হয়, যেমনটি লিস্টিং ১২-২০-এ দেখানো হয়েছে।

<Listing number="12-20" file-name="src/lib.rs" caption="আমরা যে case-insensitive ফাংশনটি যোগ করতে চলেছি তার জন্য একটি নতুন ফেইলিং টেস্ট যোগ করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-20/src/lib.rs:here}}
```

</Listing>

লক্ষ্য করুন যে আমরা পুরনো টেস্টের `contents`-ও এডিট করেছি। আমরা একটি নতুন লাইন যোগ করেছি `"Duct tape."` টেক্সট সহ, যেখানে একটি বড় হাতের _D_ ব্যবহার করা হয়েছে, যা case-sensitive ভাবে সার্চ করার সময় `"duct"` কোয়েরির সাথে ম্যাচ করা উচিত নয়। পুরনো টেস্টটি এভাবে পরিবর্তন করা নিশ্চিত করতে সাহায্য করে যে আমরা ইতোমধ্যে প্রয়োগ করা case-sensitive সার্চ ফাংশনালিটি দুর্ঘটনাক্রমে নষ্ট করে ফেলছি না। এই টেস্টটি এখন পাস করা উচিত এবং case-insensitive সার্চ নিয়ে কাজ করার সময়ও পাস করা উচিত।

case-_insensitive_ সার্চের জন্য নতুন টেস্টটি তার কোয়েরি হিসেবে `"rUsT"` ব্যবহার করে। আমরা যে `search_case_insensitive` ফাংশনটি যোগ করতে চলেছি, সেখানে `"rUsT"` কোয়েরিটি বড় হাতের _R_ সহ `"Rust:"` লাইনটির সাথে ম্যাচ করা উচিত এবং `"Trust me."` লাইনটির সাথেও ম্যাচ করা উচিত, যদিও উভয়ের কেসিং কোয়েরি থেকে ভিন্ন। এটি আমাদের ফেইলিং টেস্ট, এবং এটি কম্পাইল করতে ব্যর্থ হবে কারণ আমরা এখনও `search_case_insensitive` ফাংশনটি ডিফাইন করিনি। আপনি নির্দ্বিধায় একটি স্কেলেটন ইমপ্লিমেন্টেশন যোগ করতে পারেন যা সর্বদা একটি খালি ভেক্টর রিটার্ন করে, যেমনটি আমরা লিস্টিং ১২-১৬-তে `search` ফাংশনের জন্য করেছিলাম, যাতে টেস্টটি কম্পাইল হয় এবং ফেইল করে।

### `search_case_insensitive` ফাংশন ইমপ্লিমেন্ট করা

`search_case_insensitive` ফাংশনটি, যা লিস্টিং ১২-২১-এ দেখানো হয়েছে, প্রায় `search` ফাংশনের মতোই হবে। একমাত্র পার্থক্য হলো আমরা `query` এবং প্রতিটি `line`-কে লোয়ারকেস (lowercase) করব, যাতে ইনপুট আর্গুমেন্টের কেস যাই হোক না কেন, লাইনটিতে কোয়েরি আছে কিনা তা পরীক্ষা করার সময় তারা একই কেস-এ থাকবে।

<Listing number="12-21" file-name="src/lib.rs" caption="কোয়েরি এবং লাইন তুলনা করার আগে সেগুলোকে লোয়ারকেস করার জন্য `search_case_insensitive` ফাংশন ডিফাইন করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-21/src/lib.rs:here}}
```

</Listing>

প্রথমে আমরা `query` স্ট্রিংকে লোয়ারকেস করি এবং এটিকে একই নামের একটি নতুন ভেরিয়েবলে সংরক্ষণ করি, যা মূল `query`-কে শ্যাডো (shadow) করে। কোয়েরির উপর `to_lowercase` কল করা প্রয়োজন যাতে ব্যবহারকারীর কোয়েরি `"rust"`, `"RUST"`, `"Rust"`, বা `"`rUsT`"` যাই হোক না কেন, আমরা কোয়েরিটিকে `"rust"` হিসেবে বিবেচনা করব এবং কেস-এর প্রতি সংবেদনশীল থাকব না। যদিও `to_lowercase` বেসিক ইউনিকোড (Unicode) হ্যান্ডেল করবে, এটি ১০০ শতাংশ সঠিক হবে না। যদি আমরা একটি বাস্তব অ্যাপ্লিকেশন লিখতাম, তবে আমাদের এখানে আরও কিছু কাজ করতে হতো, কিন্তু এই বিভাগটি এনভায়রনমেন্ট ভেরিয়েবল সম্পর্কে, ইউনিকোড সম্পর্কে নয়, তাই আমরা এখানেই এটি ছেড়ে দেব।

লক্ষ্য করুন যে `query` এখন একটি স্ট্রিং স্লাইসের পরিবর্তে একটি `String`, কারণ `to_lowercase` কল করা বিদ্যমান ডেটাকে রেফারেন্স করার পরিবর্তে নতুন ডেটা তৈরি করে। উদাহরণস্বরূপ, ধরুন কোয়েরিটি `"rUsT"`: সেই স্ট্রিং স্লাইসে আমাদের ব্যবহারের জন্য ছোট হাতের `u` বা `t` নেই, তাই আমাদের `"rust"` ধারণকারী একটি নতুন `String` অ্যালোকেট করতে হবে। যখন আমরা এখন `contains` মেথডের আর্গুমেন্ট হিসেবে `query` পাস করব, আমাদের একটি অ্যামপারস্যান্ড (&) যোগ করতে হবে কারণ `contains`-এর সিগনেচার একটি স্ট্রিং স্লাইস নেওয়ার জন্য ডিফাইন করা হয়েছে।

এরপরে, আমরা প্রতিটি `line`-এ `to_lowercase`-এ একটি কল যোগ করি সমস্ত ক্যারেক্টার লোয়ারকেস করতে। এখন যেহেতু আমরা `line` এবং `query` উভয়কেই লোয়ারকেসে রূপান্তর করেছি, কোয়েরির কেস যাই হোক না কেন আমরা ম্যাচ খুঁজে পাব।

দেখা যাক এই ইমপ্লিমেন্টেশনটি টেস্ট পাস করে কিনা:

```console
{{#include ../listings/ch12-an-io-project/listing-12-21/output.txt}}
```

চমৎকার! তারা পাস করেছে। এখন, আসুন `run` ফাংশন থেকে নতুন `search_case_insensitive` ফাংশনটি কল করি। প্রথমে আমরা `Config` স্ট্রাকটে case-sensitive এবং case-insensitive সার্চের মধ্যে সুইচ করার জন্য একটি কনফিগারেশন অপশন যোগ করব। এই ফিল্ডটি যোগ করলে কম্পাইলার এরর দেখা যাবে কারণ আমরা এখনও কোথাও এই ফিল্ডটি ইনিশিয়ালাইজ করছি না:

<span class="filename">ফাইলের নাম: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/main.rs:here}}
```

আমরা `ignore_case` ফিল্ডটি যোগ করেছি যা একটি বুলিয়ান (boolean) ধারণ করে। এরপরে, আমাদের `run` ফাংশনটিকে `ignore_case` ফিল্ডের ভ্যালু পরীক্ষা করতে হবে এবং `search` ফাংশন বা `search_case_insensitive` ফাংশন কল করার সিদ্ধান্ত নিতে হবে, যেমনটি লিস্টিং ১২-২২-এ দেখানো হয়েছে। এটি এখনও কম্পাইল হবে না।

<Listing number="12-22" file-name="src/main.rs" caption="`config.ignore_case`-এর ভ্যালুর উপর ভিত্তি করে `search` বা `search_case_insensitive` কল করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-22/src/main.rs:there}}
```

</Listing>

অবশেষে, আমাদের এনভায়রনমেন্ট ভেরিয়েবল পরীক্ষা করতে হবে। এনভায়রনমেন্ট ভেরিয়েবলের সাথে কাজ করার ফাংশনগুলো standard library-র `env` মডিউলে রয়েছে, যা ইতোমধ্যে _src/main.rs_-এর শীর্ষে স্কোপে রয়েছে। আমরা `env` মডিউলের `var` ফাংশনটি ব্যবহার করে দেখব `IGNORE_CASE` নামের কোনো এনভায়রনমেন্ট ভেরিয়েবলের জন্য কোনো ভ্যালু সেট করা হয়েছে কিনা, যেমনটি লিস্টিং ১২-২৩-এ দেখানো হয়েছে।

<Listing number="12-23" file-name="src/main.rs" caption="`IGNORE_CASE` নামের এনভায়রনমেন্ট ভেরিয়েবলে কোনো ভ্যালু আছে কিনা তা পরীক্ষা করা">

```rust,ignore,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-23/src/main.rs:here}}
```

</Listing>

এখানে, আমরা একটি নতুন ভেরিয়েবল `ignore_case` তৈরি করি। এর ভ্যালু সেট করতে, আমরা `env::var` ফাংশন কল করি এবং এতে `IGNORE_CASE` এনভায়রনমেন্ট ভেরিয়েবলের নাম পাস করি। `env::var` ফাংশনটি একটি `Result` রিটার্ন করে যা সফল `Ok` ভ্যারিয়েন্ট হবে এবং এনভায়রনমেন্ট ভেরিয়েবলের ভ্যালু ধারণ করবে যদি এনভায়রনমেন্ট ভেরিয়েবলটি কোনো ভ্যালুতে সেট করা থাকে। যদি এনভায়রনমেন্ট ভেরিয়েবলটি সেট না করা থাকে তবে এটি `Err` ভ্যারিয়েন্ট রিটার্ন করবে।

এনভায়রনমেন্ট ভেরিয়েবলটি সেট করা আছে কিনা তা পরীক্ষা করার জন্য আমরা `Result`-এর `is_ok` মেথড ব্যবহার করছি, যার মানে প্রোগ্রামটি একটি case-insensitive সার্চ করবে। যদি `IGNORE_CASE` এনভায়রনমেন্ট ভেরিয়েবলটি কিছুতেই সেট না করা থাকে, `is_ok` `false` রিটার্ন করবে এবং প্রোগ্রামটি একটি case-sensitive সার্চ করবে। আমরা এনভায়রনমেন্ট ভেরিয়েবলের _ভ্যালু_ নিয়ে চিন্তিত নই, শুধু এটি সেট করা আছে নাকি নেই তা নিয়েই ভাবছি, তাই আমরা `unwrap`, `expect`, বা `Result`-এ আমরা দেখেছি এমন অন্য কোনো মেথড ব্যবহার না করে `is_ok` পরীক্ষা করছি।

আমরা `ignore_case` ভেরিয়েবলের ভ্যালুটি `Config` ইনস্ট্যান্সে পাস করি যাতে `run` ফাংশনটি সেই ভ্যালুটি পড়তে পারে এবং `search_case_insensitive` বা `search` কল করার সিদ্ধান্ত নিতে পারে, যেমনটি আমরা লিস্টিং ১২-২২-এ ইমপ্লিমেন্ট করেছি।

চলুন চেষ্টা করে দেখা যাক! প্রথমে আমরা এনভায়রনমেন্ট ভেরিয়েবল সেট না করে এবং `to` কোয়েরি দিয়ে আমাদের প্রোগ্রামটি চালাব, যা সমস্ত ছোট হাতের অক্ষরে _to_ শব্দটি ধারণকারী যেকোনো লাইনের সাথে ম্যাচ করা উচিত:

```console
{{#include ../listings/ch12-an-io-project/listing-12-23/output.txt}}
```

মনে হচ্ছে এটি এখনও কাজ করছে! এখন আসুন `IGNORE_CASE`-কে `1` এ সেট করে এবং একই কোয়েরি _to_ দিয়ে প্রোগ্রামটি চালাই:

```console
$ IGNORE_CASE=1 cargo run -- to poem.txt
```

আপনি যদি PowerShell ব্যবহার করেন, তবে আপনাকে এনভায়রনমেন্ট ভেরিয়েবল সেট করতে হবে এবং প্রোগ্রামটি আলাদা কমান্ড হিসাবে চালাতে হবে:

```console
PS> $Env:IGNORE_CASE=1; cargo run -- to poem.txt
```

এটি আপনার শেল সেশনের বাকি অংশের জন্য `IGNORE_CASE`-কে স্থায়ী করবে। এটি `Remove-Item` cmdlet দিয়ে আনসেট করা যেতে পারে:

```console
PS> Remove-Item Env:IGNORE_CASE
```

আমাদের এমন লাইন পাওয়া উচিত যাতে _to_ শব্দটি রয়েছে এবং যার মধ্যে বড় হাতের অক্ষর থাকতে পারে:

<!-- manual-regeneration
cd listings/ch12-an-io-project/listing-12-23
IGNORE_CASE=1 cargo run -- to poem.txt
can't extract because of the environment variable
-->

```console
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
```

চমৎকার, আমরা _To_ ধারণকারী লাইনগুলোও পেয়েছি! আমাদের `minigrep` প্রোগ্রাম এখন একটি এনভায়রনমেন্ট ভেরিয়েবল দ্বারা নিয়ন্ত্রিত case-insensitive সার্চিং করতে পারে। এখন আপনি জানেন কীভাবে কমান্ড লাইন আর্গুমেন্ট বা এনভায়রনমেন্ট ভেরিয়েবল ব্যবহার করে সেট করা অপশনগুলো পরিচালনা করতে হয়।

কিছু প্রোগ্রাম একই কনফিগারেশনের জন্য আর্গুমেন্ট _এবং_ এনভায়রনমেন্ট ভেরিয়েবল উভয়ই অনুমোদন করে। সেই ক্ষেত্রে, প্রোগ্রামগুলো সিদ্ধান্ত নেয় যে একটির উপর আরেকটির অগ্রাধিকার থাকবে। আপনার নিজের জন্য আরেকটি অনুশীলনী হিসেবে, একটি কমান্ড লাইন আর্গুমেন্ট বা একটি এনভায়রনমেন্ট ভেরিয়েবলের মাধ্যমে case sensitivity নিয়ন্ত্রণ করার চেষ্টা করুন। প্রোগ্রামটি যদি একটি case sensitive এবং অন্যটি ignore case-এ সেট করে চালানো হয় তবে কমান্ড লাইন আর্গুমেন্ট বা এনভায়রনমেন্ট ভেরিয়েবলের মধ্যে কোনটি অগ্রাধিকার পাবে তা নির্ধারণ করুন।

`std::env` মডিউলে এনভায়রনমেন্ট ভেরিয়েবলের সাথে কাজ করার জন্য আরও অনেক দরকারী ফিচার রয়েছে: কী কী উপলব্ধ আছে তা দেখতে এর ডকুমেন্টেশন দেখুন।