## ভেরিয়েবল এবং পরিবর্তনশীলতা

[“ভেরিয়েবল দিয়ে মান সংরক্ষণ করা”][storing-values-with-variables]<!-- ignore --> বিভাগে যেমন উল্লেখ করা হয়েছে, ডিফল্টরূপে, ভেরিয়েবলগুলি অপরিবর্তনীয়। Rust আপনাকে নিরাপত্তা এবং সহজ কনকারেন্সি সুবিধা গ্রহণ করে এমনভাবে আপনার কোড লেখার জন্য উৎসাহিত করে। তবে, আপনার ভেরিয়েবলগুলিকে পরিবর্তনযোগ্য করার বিকল্পও রয়েছে। আসুন আমরা Rust কেন আপনাকে অপরিবর্তনীয়তাকে সমর্থন করতে উৎসাহিত করে এবং কেন মাঝে মাঝে আপনি এটি থেকে বেরিয়ে যেতে চাইতে পারেন তা নিয়ে আলোচনা করি।

যখন একটি ভেরিয়েবল অপরিবর্তনীয় হয়, একবার একটি মান একটি নামের সাথে আবদ্ধ হয়ে গেলে, আপনি সেই মান পরিবর্তন করতে পারবেন না। এটি চিত্রিত করার জন্য, `cargo new variables` ব্যবহার করে আপনার _projects_ ডিরেক্টরিতে _variables_ নামের একটি নতুন প্রকল্প তৈরি করুন।

তারপর, আপনার নতুন _variables_ ডিরেক্টরিতে, _src/main.rs_ খুলুন এবং এর কোডটিকে নিম্নলিখিত কোড দিয়ে প্রতিস্থাপন করুন, যা এখনই কম্পাইল হবে না:

<span class="filename">Filename: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/src/main.rs}}
```

সংরক্ষণ করুন এবং `cargo run` ব্যবহার করে প্রোগ্রামটি চালান। এই আউটপুটে দেখানো হিসাবে আপনি একটি অপরিবর্তনীয়তা ত্রুটি সম্পর্কিত একটি ত্রুটি বার্তা পাবেন:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-01-variables-are-immutable/output.txt}}
```

এই উদাহরণটি দেখায় যে কম্পাইলার কীভাবে আপনাকে আপনার প্রোগ্রামের ত্রুটি খুঁজে পেতে সহায়তা করে। কম্পাইলার ত্রুটিগুলি হতাশাজনক হতে পারে, তবে এর মানে হল আপনার প্রোগ্রামটি আপনি যা চান তা এখনও নিরাপদে করছে না; এর মানে _এই নয়_ যে আপনি একজন ভালো প্রোগ্রামার নন! অভিজ্ঞ Rustaceanরাও কম্পাইলার ত্রুটি পান।

আপনি `` cannot assign twice to immutable variable `x` `` ত্রুটি বার্তাটি পেয়েছেন কারণ আপনি অপরিবর্তনীয় `x` ভেরিয়েবলে দ্বিতীয় মান নির্ধারণ করার চেষ্টা করেছিলেন।

এটা গুরুত্বপূর্ণ যে যখন আমরা এমন একটি মান পরিবর্তন করার চেষ্টা করি যা অপরিবর্তনীয় হিসাবে চিহ্নিত করা হয়েছে তখন আমরা কম্পাইল-টাইম ত্রুটি পাই কারণ এই পরিস্থিতিটি বাগের দিকে নিয়ে যেতে পারে। যদি আমাদের কোডের একটি অংশ এই ধারণার উপর কাজ করে যে একটি মান কখনই পরিবর্তন হবে না এবং আমাদের কোডের অন্য অংশ সেই মানটি পরিবর্তন করে, তবে এটি সম্ভব যে কোডের প্রথম অংশটি যা করার জন্য ডিজাইন করা হয়েছিল তা করবে না। এই ধরনের বাগের কারণ খুঁজে বের করা কঠিন হতে পারে, বিশেষ করে যখন দ্বিতীয় অংশের কোডটি _মাঝে মাঝে_ মান পরিবর্তন করে। Rust কম্পাইলার গ্যারান্টি দেয় যে যখন আপনি বলেন যে একটি মান পরিবর্তন হবে না, তখন তা সত্যিই পরিবর্তন হবে না, তাই আপনাকে নিজে থেকে এটির ট্র্যাক রাখতে হবে না। আপনার কোড এইভাবে বুঝতে সহজ।

তবে পরিবর্তনশীলতা খুব দরকারী হতে পারে এবং কোড লেখা আরও সুবিধাজনক করতে পারে। যদিও ভেরিয়েবলগুলি ডিফল্টরূপে অপরিবর্তনীয়, আপনি [অধ্যায় 2][storing-values-with-variables]<!-- ignore --> এ যেমন করেছিলেন, ভেরিয়েবলের নামের সামনে `mut` যোগ করে সেগুলিকে পরিবর্তনযোগ্য করতে পারেন। `mut` যোগ করা কোডের ভবিষ্যৎ পাঠকদের কাছে এই ইঙ্গিতও বহন করে যে কোডের অন্যান্য অংশ এই ভেরিয়েবলের মান পরিবর্তন করবে।

উদাহরণস্বরূপ, আসুন _src/main.rs_ কে নিচের মত পরিবর্তন করি:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```

যখন আমরা এখন প্রোগ্রামটি চালাই, তখন আমরা এটি পাই:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

যখন `mut` ব্যবহার করা হয়, তখন `x` এর সাথে আবদ্ধ মান `5` থেকে `6` এ পরিবর্তন করার অনুমতি দেওয়া হয়। পরিশেষে, পরিবর্তনশীলতা ব্যবহার করবেন কিনা তা সিদ্ধান্ত নেওয়া আপনার উপর নির্ভর করে এবং এটি নির্ভর করে সেই বিশেষ পরিস্থিতিতে আপনি কী স্পষ্ট মনে করেন তার উপর।

### ধ্রুবক

অপরিবর্তনীয় ভেরিয়েবলের মতো, _ধ্রুবকগুলিও_ এমন মান যা একটি নামের সাথে আবদ্ধ থাকে এবং পরিবর্তন করার অনুমতি নেই, তবে ধ্রুবক এবং ভেরিয়েবলের মধ্যে কয়েকটি পার্থক্য রয়েছে।

প্রথমত, ধ্রুবকের সাথে `mut` ব্যবহার করার অনুমতি নেই। ধ্রুবকগুলি কেবল ডিফল্টরূপে অপরিবর্তনীয় নয়—এগুলি সর্বদা অপরিবর্তনীয়। আপনি `let` কীওয়ার্ডের পরিবর্তে `const` কীওয়ার্ড ব্যবহার করে ধ্রুবক ঘোষণা করেন এবং মানের টাইপটি _অবশ্যই_ টীকাযুক্ত হতে হবে। আমরা পরবর্তী বিভাগে, [“ডেটা টাইপ”][data-types]<!-- ignore --> এ টাইপ এবং টাইপ টীকাগুলি আলোচনা করব, তাই এখনই বিশদ নিয়ে চিন্তা করবেন না। শুধু জেনে রাখুন যে আপনাকে অবশ্যই সর্বদা টাইপ টীকা করতে হবে।

ধ্রুবকগুলি গ্লোবাল স্কোপ সহ যেকোনো স্কোপে ঘোষণা করা যেতে পারে, যা সেগুলিকে এমন মানগুলির জন্য উপযোগী করে তোলে যা কোডের অনেক অংশের জানা দরকার।

শেষ পার্থক্য হল যে ধ্রুবকগুলি শুধুমাত্র একটি ধ্রুবক এক্সপ্রেশনে সেট করা যেতে পারে, এমন মানের ফলাফলে নয় যা শুধুমাত্র রানটাইমে গণনা করা যেতে পারে।

এখানে একটি ধ্রুবক ঘোষণার উদাহরণ দেওয়া হল:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

ধ্রুবকের নাম হল `THREE_HOURS_IN_SECONDS` এবং এর মান 60 (এক মিনিটে সেকেন্ডের সংখ্যা) কে 60 (এক ঘন্টায় মিনিটের সংখ্যা) দ্বারা গুণ করে 3 (আমরা এই প্রোগ্রামে গণনা করতে চাই এমন ঘণ্টার সংখ্যা) গুণ করার ফলাফলের সাথে সেট করা হয়েছে। ধ্রুবকের জন্য Rust এর নামকরণের নিয়ম হল শব্দগুলির মধ্যে আন্ডারস্কোর সহ সমস্ত বড় হাতের অক্ষর ব্যবহার করা। কম্পাইলার কম্পাইল টাইমে সীমিত সংখ্যক অপারেশন মূল্যায়ন করতে সক্ষম, যা আমাদেরকে 10,800 মানটিতে এই ধ্রুবক সেট করার পরিবর্তে এই মানটি এমনভাবে লেখার অনুমতি দেয় যা বুঝতে এবং যাচাই করা সহজ। ধ্রুবক ঘোষণা করার সময় কোন অপারেশনগুলি ব্যবহার করা যেতে পারে সে সম্পর্কে আরও তথ্যের জন্য [ধ্রুবক মূল্যায়ন সম্পর্কিত Rust রেফারেন্সের বিভাগটি][const-eval] দেখুন।

ধ্রুবকগুলি একটি প্রোগ্রাম চলার পুরো সময়ের জন্য বৈধ, যে স্কোপে সেগুলি ঘোষণা করা হয়েছিল তার মধ্যে। এই বৈশিষ্ট্যটি আপনার অ্যাপ্লিকেশন ডোমেনে এমন মানগুলির জন্য ধ্রুবকগুলিকে উপযোগী করে তোলে যা প্রোগ্রামের একাধিক অংশের জানা দরকার হতে পারে, যেমন কোনও গেমের কোনও খেলোয়াড়কে কত পয়েন্ট অর্জন করার অনুমতি দেওয়া হয়েছে, বা আলোর গতি।

আপনার প্রোগ্রাম জুড়ে ব্যবহৃত হার্ডকোডেড মানগুলিকে ধ্রুবক হিসাবে নামকরণ করা কোডের ভবিষ্যতের রক্ষণাবেক্ষণকারীদের কাছে সেই মানের অর্থ বোঝাতে সহায়ক। ভবিষ্যতে যদি হার্ডকোডেড মান আপডেট করার প্রয়োজন হয় তবে আপনার কোডে শুধুমাত্র একটি স্থান পরিবর্তন করতে হবে।

### শ্যাডোইং

আপনি [অধ্যায় 2][comparing-the-guess-to-the-secret-number]<!-- ignore --> এর গেসিং গেম টিউটোরিয়ালে দেখেছেন, আপনি পূর্ববর্তী ভেরিয়েবলের মতো একই নামে একটি নতুন ভেরিয়েবল ঘোষণা করতে পারেন। Rustaceans বলে যে প্রথম ভেরিয়েবলটি দ্বিতীয়টি দ্বারা _শ্যাডো_ করা হয়েছে, যার মানে যখন আপনি ভেরিয়েবলের নাম ব্যবহার করেন তখন কম্পাইলার দ্বিতীয় ভেরিয়েবলটিকে দেখবে। ফলস্বরূপ, দ্বিতীয় ভেরিয়েবলটি প্রথমটিকে আড়াল করে, যতক্ষণ না এটি নিজে শ্যাডো করা হয় বা স্কোপ শেষ না হয় ততক্ষণ ভেরিয়েবলের নামের যেকোনো ব্যবহার নিজেকে নিয়ে নেয়। আমরা একই ভেরিয়েবলের নাম ব্যবহার করে এবং `let` কীওয়ার্ডের ব্যবহার পুনরাবৃত্তি করে একটি ভেরিয়েবলকে শ্যাডো করতে পারি, যেমন:

<span class="filename">Filename: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

এই প্রোগ্রামটি প্রথমে `x` কে `5` এর মানের সাথে বাইন্ড করে। তারপর এটি `let x =` পুনরাবৃত্তি করে একটি নতুন ভেরিয়েবল `x` তৈরি করে, মূল মানটি নিয়ে `1` যোগ করে যাতে `x` এর মান তখন `6` হয়। তারপর, কার্লি ব্র্যাকেট দিয়ে তৈরি একটি ভিতরের স্কোপের মধ্যে, তৃতীয় `let` স্টেটমেন্টটিও `x` কে শ্যাডো করে এবং একটি নতুন ভেরিয়েবল তৈরি করে, পূর্বের মানটিকে `2` দিয়ে গুণ করে `x` এর মান `12` করে। যখন সেই স্কোপটি শেষ হয়ে যায়, তখন ভিতরের শ্যাডোইং শেষ হয় এবং `x` আবার `6` এ ফিরে আসে। যখন আমরা এই প্রোগ্রামটি চালাই, তখন এটি নিম্নলিখিত আউটপুট দেবে:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

শ্যাডোইং একটি ভেরিয়েবলকে `mut` হিসাবে চিহ্নিত করার থেকে আলাদা কারণ আমরা যদি `let` কীওয়ার্ড ব্যবহার না করে এই ভেরিয়েবলে পুনরায় অ্যাসাইন করার চেষ্টা করি তবে আমরা একটি কম্পাইল-টাইম ত্রুটি পাব। `let` ব্যবহার করে, আমরা একটি মানের উপর কয়েকটি রূপান্তর করতে পারি তবে সেই রূপান্তরগুলি সম্পন্ন হওয়ার পরে ভেরিয়েবলটিকে অপরিবর্তনীয় রাখতে পারি।

`mut` এবং শ্যাডোইং এর মধ্যে আরেকটি পার্থক্য হল যে আমরা যখন আবার `let` কীওয়ার্ড ব্যবহার করি তখন কার্যকরভাবে একটি নতুন ভেরিয়েবল তৈরি করি, আমরা মানের টাইপ পরিবর্তন করতে পারি তবে একই নাম পুনরায় ব্যবহার করতে পারি। উদাহরণস্বরূপ, ধরুন আমাদের প্রোগ্রামটি একজন ব্যবহারকারীকে কিছু টেক্সটের মধ্যে তারা কতগুলি স্পেস চান তা স্পেস ক্যারেক্টার ইনপুট করে দেখাতে বলে এবং তারপরে আমরা সেই ইনপুটটিকে একটি সংখ্যা হিসাবে সংরক্ষণ করতে চাই:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

প্রথম `spaces` ভেরিয়েবলটি একটি স্ট্রিং টাইপ এবং দ্বিতীয় `spaces` ভেরিয়েবলটি একটি সংখ্যা টাইপ। এইভাবে শ্যাডোইং আমাদেরকে `spaces_str` এবং `spaces_num` এর মতো বিভিন্ন নাম তৈরি করা থেকে বাঁচায়; পরিবর্তে, আমরা আরও সহজ `spaces` নামটি পুনরায় ব্যবহার করতে পারি। তবে, আমরা যদি এর জন্য `mut` ব্যবহার করার চেষ্টা করি, যেমন এখানে দেখানো হয়েছে, তাহলে আমরা একটি কম্পাইল-টাইম ত্রুটি পাব:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

ত্রুটিটি বলছে যে আমাদের একটি ভেরিয়েবলের টাইপ পরিবর্তন করার অনুমতি নেই:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

এখন যেহেতু আমরা ভেরিয়েবলগুলি কীভাবে কাজ করে তা আলোচনা করেছি, আসুন আরও ডেটা টাইপগুলি দেখি যা তাদের থাকতে পারে।

[comparing-the-guess-to-the-secret-number]: ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number
[data-types]: ch03-02-data-types.html#data-types
[storing-values-with-variables]: ch02-00-guessing-game-tutorial.html#storing-values-with-variables
[const-eval]: ../reference/const_eval.html
