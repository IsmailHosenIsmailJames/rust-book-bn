## জেনেরিক ডেটা টাইপ

আমরা ফাংশন সিগনেচার বা struct-এর মতো আইটেমগুলোর জন্য সংজ্ঞা তৈরি করতে জেনেরিক ব্যবহার করি, যা আমরা তারপর বিভিন্ন কংক্রিট ডেটা টাইপের সাথে ব্যবহার করতে পারি। আসুন প্রথমে দেখি কিভাবে জেনেরিক ব্যবহার করে ফাংশন, struct, enum এবং মেথড সংজ্ঞায়িত করতে হয়। তারপর আমরা আলোচনা করব কিভাবে জেনেরিক কোড কর্মক্ষমতাকে প্রভাবিত করে।

### ফাংশন সংজ্ঞায়

যখন জেনেরিক ব্যবহার করে এমন একটি ফাংশন সংজ্ঞায়িত করা হয়, তখন আমরা ফাংশনের সিগনেচারে জেনেরিকগুলি রাখি যেখানে আমরা সাধারণত প্যারামিটার এবং রিটার্ন ভ্যালুর ডেটা টাইপ উল্লেখ করি। এটি করলে আমাদের কোড আরও নমনীয় হয় এবং কোড ডুপ্লিকেশন প্রতিরোধ করার সময় আমাদের ফাংশনের কলকারীদের আরও কার্যকারিতা প্রদান করে।

আমাদের `largest` ফাংশনটি চালিয়ে, Listing 10-4 দুটি ফাংশন দেখায় যা উভয়ই একটি স্লাইসে বৃহত্তম মান খুঁজে বের করে। তারপর আমরা এগুলিকে একটি একক ফাংশনে একত্রিত করব যা জেনেরিক ব্যবহার করে।

<Listing number="10-4" file-name="src/main.rs" caption="দুটি ফাংশন যা শুধুমাত্র তাদের নাম এবং তাদের সিগনেচারের প্রকারভেদে ভিন্ন">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-04/src/main.rs:here}}
```

</Listing>

`largest_i32` ফাংশনটি হল সেটি যা আমরা Listing 10-3-এ বের করেছিলাম যা একটি স্লাইসে বৃহত্তম `i32` খুঁজে বের করে। `largest_char` ফাংশনটি একটি স্লাইসে বৃহত্তম `char` খুঁজে বের করে। ফাংশনের বডিগুলোতে একই কোড আছে, তাই আসুন একটি একক ফাংশনে একটি জেনেরিক টাইপ প্যারামিটার প্রবর্তন করে প্রতিলিপিটি দূর করি।

একটি নতুন একক ফাংশনে টাইপগুলিকে প্যারামিটারাইজ করতে, আমাদের টাইপ প্যারামিটারের নামকরণ করতে হবে, ঠিক যেমন আমরা একটি ফাংশনের ভ্যালু প্যারামিটারগুলোর জন্য করি। আপনি টাইপ প্যারামিটার নাম হিসাবে যেকোনো শনাক্তকারী ব্যবহার করতে পারেন। তবে আমরা `T` ব্যবহার করব কারণ, প্রথা অনুসারে, রাস্টে টাইপ প্যারামিটারের নামগুলো ছোট হয়, প্রায়শই মাত্র একটি অক্ষর এবং রাস্টের টাইপ-নামকরণের প্রথা হল UpperCamelCase। _টাইপ_ এর সংক্ষিপ্ত রূপ, `T` হল বেশিরভাগ রাস্ট প্রোগ্রামারদের ডিফল্ট পছন্দ।

যখন আমরা ফাংশনের বডিতে একটি প্যারামিটার ব্যবহার করি, তখন আমাদের সিগনেচারে প্যারামিটারের নাম ঘোষণা করতে হয় যাতে কম্পাইলার জানতে পারে যে সেই নামের অর্থ কী। একইভাবে, যখন আমরা একটি ফাংশন সিগনেচারে একটি টাইপ প্যারামিটারের নাম ব্যবহার করি, তখন আমাদের এটি ব্যবহার করার আগে টাইপ প্যারামিটারের নাম ঘোষণা করতে হয়। জেনেরিক `largest` ফাংশন সংজ্ঞায়িত করতে, আমরা কোণের বন্ধনী, `<>`-এর ভিতরে টাইপ নামের ঘোষণাগুলো রাখি, ফাংশনের নাম এবং প্যারামিটার তালিকার মধ্যে, যেমন:

```rust,ignore
fn largest<T>(list: &[T]) -> &T {
```

আমরা এই সংজ্ঞাটিকে এভাবে পড়ি: `largest` ফাংশনটি `T` টাইপের উপর জেনেরিক। এই ফাংশনের `list` নামের একটি প্যারামিটার রয়েছে, যা `T` টাইপের ভ্যালুর একটি স্লাইস। `largest` ফাংশনটি একই টাইপ `T`-এর একটি ভ্যালুর রেফারেন্স রিটার্ন করবে।

Listing 10-5 সিগনেচারে জেনেরিক ডেটা টাইপ ব্যবহার করে সম্মিলিত `largest` ফাংশনের সংজ্ঞা দেখায়। তালিকাটি আরও দেখায় কিভাবে আমরা `i32` ভ্যালু বা `char` ভ্যালুর একটি স্লাইস দিয়ে ফাংশনটিকে কল করতে পারি। মনে রাখবেন এই কোডটি এখনও কম্পাইল হবে না, তবে আমরা এই অধ্যায়ে পরে এটি ঠিক করব।

<Listing number="10-5" file-name="src/main.rs" caption="জেনেরিক টাইপ প্যারামিটার ব্যবহার করে `largest` ফাংশন; এটি এখনও কম্পাইল হয় না">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/src/main.rs}}
```

</Listing>

যদি আমরা এখনই এই কোডটি কম্পাইল করি, তাহলে আমরা এই এররটি পাব:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-05/output.txt}}
```

সহায়তা পাঠ্যে `std::cmp::PartialOrd` উল্লেখ করা হয়েছে, যা একটি _ট্রেট_, এবং আমরা পরবর্তী বিভাগে ট্রেট নিয়ে কথা বলতে যাচ্ছি। আপাতত, জেনে রাখুন যে এই এররটি বলছে যে `largest`-এর বডি `T` হতে পারে এমন সমস্ত সম্ভাব্য টাইপের জন্য কাজ করবে না। যেহেতু আমরা বডিতে `T` টাইপের ভ্যালু তুলনা করতে চাই, তাই আমরা শুধুমাত্র সেই টাইপগুলো ব্যবহার করতে পারি যেগুলোর ভ্যালু অর্ডার করা যায়। তুলনা সক্ষম করতে, স্ট্যান্ডার্ড লাইব্রেরিতে `std::cmp::PartialOrd` ট্রেট রয়েছে যা আপনি টাইপের উপর প্রয়োগ করতে পারেন (এই ট্রেট সম্পর্কে আরও জানতে Appendix C দেখুন)। সহায়তার পাঠ্যের পরামর্শ অনুসরণ করে, আমরা `T`-এর জন্য বৈধ টাইপগুলিকে শুধুমাত্র সেইগুলির মধ্যে সীমাবদ্ধ করি যা `PartialOrd` প্রয়োগ করে এবং এই উদাহরণটি কম্পাইল হবে, কারণ স্ট্যান্ডার্ড লাইব্রেরি `i32` এবং `char` উভয়ের উপর `PartialOrd` প্রয়োগ করে।

### Struct সংজ্ঞায়

আমরা `<>` সিনট্যাক্স ব্যবহার করে এক বা একাধিক ফিল্ডে জেনেরিক টাইপ প্যারামিটার ব্যবহার করার জন্য struct-ও সংজ্ঞায়িত করতে পারি। Listing 10-6 যেকোনো টাইপের `x` এবং `y` স্থানাঙ্ক ভ্যালু ধারণ করার জন্য একটি `Point<T>` struct সংজ্ঞায়িত করে।

<Listing number="10-6" file-name="src/main.rs" caption="একটি `Point<T>` struct যা `T` টাইপের `x` এবং `y` ভ্যালু ধারণ করে">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-06/src/main.rs}}
```

</Listing>

struct সংজ্ঞায় জেনেরিক ব্যবহার করার সিনট্যাক্স ফাংশন সংজ্ঞায় ব্যবহৃত সিনট্যাক্সের মতোই। প্রথমে আমরা struct-এর নামের ঠিক পরে কোণের বন্ধনীর ভিতরে টাইপ প্যারামিটারের নামটি ঘোষণা করি। তারপর আমরা struct সংজ্ঞায় জেনেরিক টাইপ ব্যবহার করি যেখানে আমরা অন্যথায় কংক্রিট ডেটা টাইপ উল্লেখ করব।

মনে রাখবেন যে যেহেতু আমরা `Point<T>` সংজ্ঞায়িত করতে শুধুমাত্র একটি জেনেরিক টাইপ ব্যবহার করেছি, তাই এই সংজ্ঞাটি বলে যে `Point<T>` struct টি কিছু টাইপ `T` এর উপর জেনেরিক, এবং `x` এবং `y` ফিল্ড _উভয়ই_ সেই একই টাইপের, সেই টাইপ যাই হোক না কেন। যদি আমরা `Point<T>`-এর একটি উদাহরণ তৈরি করি যাতে বিভিন্ন প্রকারের ভ্যালু থাকে, যেমন Listing 10-7-এ, তাহলে আমাদের কোড কম্পাইল হবে না।

<Listing number="10-7" file-name="src/main.rs" caption="ফিল্ড `x` এবং `y` অবশ্যই একই টাইপের হতে হবে কারণ উভয়েরই একই জেনেরিক ডেটা টাইপ `T` আছে।">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/src/main.rs}}
```

</Listing>

এই উদাহরণে, যখন আমরা `x`-এ পূর্ণসংখ্যা ভ্যালু `5` নির্ধারণ করি, তখন আমরা কম্পাইলারকে জানিয়ে দিই যে জেনেরিক টাইপ `T` `Point<T>`-এর এই উদাহরণের জন্য একটি পূর্ণসংখ্যা হবে। তারপর যখন আমরা `y`-এর জন্য `4.0` উল্লেখ করি, যা আমরা `x`-এর মতো একই টাইপের হিসাবে সংজ্ঞায়িত করেছি, তখন আমরা এইরকম একটি টাইপ মিসম্যাচ এরর পাব:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-07/output.txt}}
```

একটি `Point` struct সংজ্ঞায়িত করতে যেখানে `x` এবং `y` উভয়ই জেনেরিক কিন্তু বিভিন্ন প্রকারের হতে পারে, আমরা একাধিক জেনেরিক টাইপ প্যারামিটার ব্যবহার করতে পারি। উদাহরণস্বরূপ, Listing 10-8-এ, আমরা `Point`-এর সংজ্ঞা পরিবর্তন করে `T` এবং `U` টাইপের উপর জেনেরিক করি যেখানে `x` হল `T` টাইপের এবং `y` হল `U` টাইপের।

<Listing number="10-8" file-name="src/main.rs" caption="একটি `Point<T, U>` দুটি টাইপের উপর জেনেরিক যাতে `x` এবং `y` বিভিন্ন টাইপের ভ্যালু হতে পারে">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-08/src/main.rs}}
```

</Listing>

এখন দেখানো `Point`-এর সমস্ত ইনস্ট্যান্স অনুমোদিত! আপনি একটি সংজ্ঞায় যত খুশি জেনেরিক টাইপ প্যারামিটার ব্যবহার করতে পারেন, তবে কয়েকটির বেশি ব্যবহার করলে আপনার কোড পড়া কঠিন হয়ে যায়। আপনি যদি দেখেন যে আপনার কোডে প্রচুর জেনেরিক টাইপের প্রয়োজন, তবে এটি নির্দেশ করতে পারে যে আপনার কোডটিকে ছোট ছোট অংশে পুনর্গঠিত করার প্রয়োজন।

### Enum সংজ্ঞায়

struct-এর মতো, আমরা enum-গুলিকে তাদের ভেরিয়েন্টে জেনেরিক ডেটা টাইপ ধারণ করার জন্য সংজ্ঞায়িত করতে পারি। আসুন `Option<T>` enum-এর দিকে আরও একবার নজর দিই যা স্ট্যান্ডার্ড লাইব্রেরি প্রদান করে, যা আমরা Chapter 6-এ ব্যবহার করেছি:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

এই সংজ্ঞাটি এখন আপনার কাছে আরও বোধগম্য হওয়া উচিত। আপনি দেখতে পাচ্ছেন, `Option<T>` enum টি `T` টাইপের উপর জেনেরিক এবং এর দুটি ভেরিয়েন্ট রয়েছে: `Some`, যা `T` টাইপের একটি ভ্যালু ধারণ করে এবং একটি `None` ভেরিয়েন্ট যা কোনো ভ্যালু ধারণ করে না। `Option<T>` enum ব্যবহার করে, আমরা একটি ঐচ্ছিক ভ্যালুর বিমূর্ত ধারণা প্রকাশ করতে পারি এবং যেহেতু `Option<T>` জেনেরিক, তাই ঐচ্ছিক ভ্যালুটির টাইপ যাই হোক না কেন আমরা এই বিমূর্ততা ব্যবহার করতে পারি।

enum গুলো একাধিক জেনেরিক টাইপও ব্যবহার করতে পারে। `Result` enum-এর সংজ্ঞা যা আমরা Chapter 9-এ ব্যবহার করেছি তার একটি উদাহরণ:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

`Result` enum টি দুটি টাইপ, `T` এবং `E`-এর উপর জেনেরিক এবং এর দুটি ভেরিয়েন্ট রয়েছে: `Ok`, যা `T` টাইপের একটি ভ্যালু ধারণ করে এবং `Err`, যা `E` টাইপের একটি ভ্যালু ধারণ করে। এই সংজ্ঞাটি `Result` enum ব্যবহার করা সুবিধাজনক করে তোলে যেখানে আমাদের এমন একটি অপারেশন আছে যা সফল হতে পারে (কিছু টাইপ `T`-এর একটি ভ্যালু রিটার্ন করে) বা ব্যর্থ হতে পারে (কিছু টাইপ `E`-এর একটি এরর রিটার্ন করে)। প্রকৃতপক্ষে, এই কারণেই আমরা Listing 9-3-এ একটি ফাইল খুলতে ব্যবহার করেছিলাম, যেখানে ফাইলটি সফলভাবে খোলা হলে `T` `std::fs::File` টাইপ দিয়ে এবং ফাইল খুলতে সমস্যা হলে `E` `std::io::Error` টাইপ দিয়ে পূরণ করা হয়েছিল।

আপনি যখন আপনার কোডে একাধিক struct বা enum সংজ্ঞার সাথে পরিস্থিতি চিনতে পারেন যা শুধুমাত্র তাদের ধারণ করা ভ্যালুগুলোর প্রকারভেদে ভিন্ন, তখন আপনি পরিবর্তে জেনেরিক টাইপ ব্যবহার করে ডুপ্লিকেশন এড়াতে পারেন।

### মেথড সংজ্ঞায়

আমরা struct এবং enum-এ মেথড প্রয়োগ করতে পারি (যেমন আমরা Chapter 5-এ করেছিলাম) এবং তাদের সংজ্ঞায় জেনেরিক টাইপও ব্যবহার করতে পারি। Listing 10-9 Listing 10-6-এ সংজ্ঞায়িত `Point<T>` struct-টি দেখায় যার উপর `x` নামের একটি মেথড প্রয়োগ করা হয়েছে।

<Listing number="10-9" file-name="src/main.rs" caption="`Point<T>` struct-এ `x` নামের একটি মেথড প্রয়োগ করা যা `T` টাইপের `x` ফিল্ডের একটি রেফারেন্স রিটার্ন করবে">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-09/src/main.rs}}
```

</Listing>

এখানে, আমরা `Point<T>`-এ `x` নামের একটি মেথড সংজ্ঞায়িত করেছি যা ফিল্ড `x`-এর ডেটার একটি রেফারেন্স রিটার্ন করে।

মনে রাখবেন যে `impl`-এর ঠিক পরেই আমাদের `T` ঘোষণা করতে হবে যাতে আমরা `T` ব্যবহার করে নির্দিষ্ট করতে পারি যে আমরা `Point<T>` টাইপের উপর মেথড প্রয়োগ করছি। `impl`-এর পরে `T`-কে একটি জেনেরিক টাইপ হিসাবে ঘোষণা করার মাধ্যমে, রাস্ট সনাক্ত করতে পারে যে `Point`-এর কোণের বন্ধনীর ভিতরের টাইপটি একটি কংক্রিট টাইপের পরিবর্তে একটি জেনেরিক টাইপ। আমরা struct সংজ্ঞায় ঘোষিত জেনেরিক প্যারামিটারের থেকে ভিন্ন একটি নাম এই জেনেরিক প্যারামিটারের জন্য বেছে নিতে পারতাম, তবে একই নাম ব্যবহার করা প্রচলিত। আপনি যদি একটি `impl`-এর মধ্যে একটি মেথড লেখেন যা একটি জেনেরিক টাইপ ঘোষণা করে, তবে সেই মেথডটি টাইপের যেকোনো উদাহরণের উপর সংজ্ঞায়িত করা হবে, সেই জেনেরিক টাইপের জন্য শেষ পর্যন্ত যে কংক্রিট টাইপ প্রতিস্থাপিত হোক না কেন।

আমরা টাইপের মেথড সংজ্ঞায়িত করার সময় জেনেরিক টাইপের উপর সীমাবদ্ধতাও উল্লেখ করতে পারি। উদাহরণস্বরূপ, আমরা যেকোনো জেনেরিক টাইপ সহ `Point<T>` ইনস্ট্যান্সের পরিবর্তে শুধুমাত্র `Point<f32>` ইনস্ট্যান্সের উপর মেথড প্রয়োগ করতে পারি। Listing 10-10-এ আমরা কংক্রিট টাইপ `f32` ব্যবহার করি, যার অর্থ `impl`-এর পরে আমরা কোনো টাইপ ঘোষণা করি না।

<Listing number="10-10" file-name="src/main.rs" caption="একটি `impl` ব্লক যা শুধুমাত্র জেনেরিক টাইপ প্যারামিটার `T`-এর জন্য একটি বিশেষ কংক্রিট টাইপ সহ struct-এর ক্ষেত্রে প্রযোজ্য">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-10/src/main.rs:here}}
```

</Listing>

এই কোডের মানে হল `Point<f32>` টাইপের `distance_from_origin` মেথড থাকবে; `Point<T>`-এর অন্যান্য ইনস্ট্যান্স যেখানে `T` `f32` টাইপের নয়, সেখানে এই মেথডটি সংজ্ঞায়িত থাকবে না। মেথডটি পরিমাপ করে যে আমাদের পয়েন্টটি স্থানাঙ্ক (0.0, 0.0)-এর পয়েন্ট থেকে কতটা দূরে এবং গাণিতিক ক্রিয়াকলাপ ব্যবহার করে যা শুধুমাত্র ফ্লোটিং-পয়েন্ট টাইপের জন্য উপলব্ধ।

একটি struct সংজ্ঞায় জেনেরিক টাইপ প্যারামিটারগুলি সর্বদা একই হয় না যা আপনি সেই একই struct-এর মেথড সিগনেচারে ব্যবহার করেন। Listing 10-11 উদাহরণটিকে আরও স্পষ্ট করার জন্য `Point` struct-এর জন্য জেনেরিক টাইপ `X1` এবং `Y1` এবং `mixup` মেথড সিগনেচারের জন্য `X2` `Y2` ব্যবহার করে। মেথডটি `self` `Point` (টাইপ `X1`-এর) থেকে `x` ভ্যালু এবং পাস করা `Point` (টাইপ `Y2`-এর) থেকে `y` ভ্যালু দিয়ে একটি নতুন `Point` ইনস্ট্যান্স তৈরি করে।

<Listing number="10-11" file-name="src/main.rs" caption="একটি মেথড যা তার struct-এর সংজ্ঞা থেকে ভিন্ন জেনেরিক টাইপ ব্যবহার করে">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-11/src/main.rs}}
```

</Listing>

`main`-এ, আমরা একটি `Point` সংজ্ঞায়িত করেছি যার `x`-এর জন্য একটি `i32` (ভ্যালু `5` সহ) এবং `y`-এর জন্য একটি `f64` (ভ্যালু `10.4` সহ) রয়েছে। `p2` ভেরিয়েবলটি একটি `Point` struct যাতে `x`-এর জন্য একটি স্ট্রিং স্লাইস (ভ্যালু `"Hello"` সহ) এবং `y`-এর জন্য একটি `char` (ভ্যালু `c` সহ) রয়েছে। `p2` আর্গুমেন্ট সহ `p1`-এ `mixup` কল করলে আমরা `p3` পাই, যার `x`-এর জন্য একটি `i32` থাকবে কারণ `x` এসেছে `p1` থেকে। `p3` ভেরিয়েবলের `y`-এর জন্য একটি `char` থাকবে কারণ `y` এসেছে `p2` থেকে। `println!` ম্যাক্রো কল `p3.x = 5, p3.y = c` প্রিন্ট করবে।

এই উদাহরণের উদ্দেশ্য হল এমন একটি পরিস্থিতি প্রদর্শন করা যেখানে কিছু জেনেরিক প্যারামিটার `impl` দিয়ে এবং কিছু মেথড সংজ্ঞার সাথে ঘোষণা করা হয়। এখানে, জেনেরিক প্যারামিটার `X1` এবং `Y1` `impl`-এর পরে ঘোষণা করা হয়েছে কারণ সেগুলি struct সংজ্ঞার সাথে যায়। জেনেরিক প্যারামিটার `X2` এবং `Y2` `fn mixup`-এর পরে ঘোষণা করা হয়েছে কারণ সেগুলি শুধুমাত্র মেথডের সাথে প্রাসঙ্গিক।

### জেনেরিক ব্যবহার করে কোডের কর্মক্ষমতা

আপনি হয়তো ভাবছেন যে জেনেরিক টাইপ প্যারামিটার ব্যবহার করার সময় কোনো রানটাইম খরচ আছে কিনা। ভালো খবর হল জেনেরিক টাইপ ব্যবহার করলে আপনার প্রোগ্রাম কংক্রিট টাইপের চেয়ে ধীর গতিতে চলবে না।

রাস্ট কম্পাইল করার সময় জেনেরিক ব্যবহার করে কোডের মনোমরফাইজেশন করে এটি সম্পন্ন করে। _মনোমরফাইজেশন_ হল কম্পাইল করার সময় ব্যবহৃত কংক্রিট টাইপগুলি পূরণ করে জেনেরিক কোডকে নির্দিষ্ট কোডে পরিণত করার প্রক্রিয়া। এই প্রক্রিয়ায়, কম্পাইলার Listing 10-5-এ জেনেরিক ফাংশন তৈরি করতে আমরা যে ধাপগুলো ব্যবহার করেছি তার বিপরীত কাজ করে: কম্পাইলার সেই সমস্ত জায়গা দেখে যেখানে জেনেরিক কোড কল করা হয়েছে এবং জেনেরিক কোডটি যে কংক্রিট টাইপগুলোর সাথে কল করা হয়েছে সেগুলোর জন্য কোড তৈরি করে।

আসুন দেখি এটি কিভাবে কাজ করে স্ট্যান্ডার্ড লাইব্রেরির জেনেরিক `Option<T>` enum ব্যবহার করে:

```rust
let integer = Some(5);
let float = Some(5.0);
```

যখন রাস্ট এই কোডটি কম্পাইল করে, তখন এটি মনোমরফাইজেশন করে। সেই প্রক্রিয়ার সময়, কম্পাইলার `Option<T>` ইনস্ট্যান্সে ব্যবহৃত ভ্যালুগুলো পড়ে এবং দুই ধরনের `Option<T>` সনাক্ত করে: একটি হল `i32` এবং অন্যটি হল `f64`। যেমন, এটি `Option<T>`-এর জেনেরিক সংজ্ঞাটিকে `i32` এবং `f64`-এর জন্য বিশেষায়িত দুটি সংজ্ঞায় প্রসারিত করে, যার ফলে জেনেরিক সংজ্ঞাটিকে নির্দিষ্ট সংজ্ঞা দিয়ে প্রতিস্থাপন করা হয়।

কোডের মনোমরফাইজড সংস্করণটি দেখতে নিচের মতো (কম্পাইলার এখানে উদাহরণের জন্য আমরা যা ব্যবহার করছি তার থেকে ভিন্ন নাম ব্যবহার করে):

<Listing file-name="src/main.rs">

```rust
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
```

</Listing>

জেনেরিক `Option<T>` কম্পাইলার দ্বারা তৈরি করা নির্দিষ্ট সংজ্ঞা দিয়ে প্রতিস্থাপিত হয়। যেহেতু রাস্ট জেনেরিক কোডকে এমন কোডে কম্পাইল করে যা প্রতিটি ইনস্ট্যান্সে টাইপ নির্দিষ্ট করে, তাই জেনেরিক ব্যবহার করার জন্য আমাদের কোনো রানটাইম খরচ দিতে হয় না। যখন কোডটি রান করে, তখন এটি ঠিক তেমনভাবেই পারফর্ম করে যেমনটি আমরা প্রতিটি সংজ্ঞা হাতে ডুপ্লিকেট করলে করত। মনোমরফাইজেশনের প্রক্রিয়া রানটাইমে রাস্টের জেনেরিককে অত্যন্ত দক্ষ করে তোলে।
