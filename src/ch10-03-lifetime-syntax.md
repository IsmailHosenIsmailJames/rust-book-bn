## লাইফটাইমের সাথে রেফারেন্স যাচাই করা

লাইফটাইম হল আরও এক ধরনের জেনেরিক যা আমরা ইতিমধ্যেই ব্যবহার করে আসছি। একটি টাইপের কাঙ্ক্ষিত আচরণ আছে কিনা তা নিশ্চিত করার পরিবর্তে, লাইফটাইম নিশ্চিত করে যে যতক্ষণ আমাদের প্রয়োজন ততক্ষণ রেফারেন্সগুলো বৈধ থাকে।

Chapter 4-এর [“রেফারেন্স এবং বরো করা”][references-and-borrowing]<!-- ignore --> বিভাগে আমরা যে একটি বিশদ বিবরণ নিয়ে আলোচনা করিনি তা হল রাস্টের প্রতিটি রেফারেন্সের একটি _লাইফটাইম_ থাকে, যা সেই স্কোপ যার জন্য সেই রেফারেন্সটি বৈধ। বেশিরভাগ সময়, লাইফটাইমগুলো অন্তর্নিহিত এবং অনুমান করা হয়, ঠিক যেমন বেশিরভাগ সময় টাইপগুলো অনুমান করা হয়। যখন একাধিক টাইপ সম্ভব হয় তখনই আমাদের টাইপগুলো টীকা করতে হয়। একইভাবে, যখন রেফারেন্সগুলোর লাইফটাইম কয়েকটি ভিন্ন উপায়ে সম্পর্কিত হতে পারে তখন আমাদের লাইফটাইমগুলো টীকা করতে হবে। রানটাইমে ব্যবহৃত প্রকৃত রেফারেন্সগুলো অবশ্যই বৈধ হবে তা নিশ্চিত করার জন্য রাস্ট আমাদের জেনেরিক লাইফটাইম প্যারামিটার ব্যবহার করে সম্পর্কগুলো টীকা করতে বাধ্য করে।

লাইফটাইম টীকা করা এমন একটি ধারণা যা অন্য প্রোগ্রামিং ভাষাগুলোতে নেই, তাই এটি অপরিচিত মনে হবে। যদিও আমরা এই অধ্যায়ে লাইফটাইমগুলো সম্পূর্ণরূপে আলোচনা করব না, আমরা সাধারণ উপায়গুলো নিয়ে আলোচনা করব যাতে আপনি লাইফটাইম সিনট্যাক্সের সম্মুখীন হতে পারেন যাতে আপনি ধারণাটির সাথে পরিচিত হতে পারেন।

### লাইফটাইমের সাথে ড্যাংলিং রেফারেন্স প্রতিরোধ করা

লাইফটাইমের প্রধান লক্ষ্য হল _ড্যাংলিং রেফারেন্স_ প্রতিরোধ করা, যা একটি প্রোগ্রামকে সেই ডেটা ছাড়া অন্য ডেটা রেফার করতে বাধ্য করে যা এটি রেফার করার উদ্দেশ্যে করা হয়েছে। Listing 10-16-এর প্রোগ্রামটি বিবেচনা করুন, যেখানে একটি বাইরের স্কোপ এবং একটি ভিতরের স্কোপ রয়েছে।

<Listing number="10-16" caption="একটি রেফারেন্স ব্যবহার করার চেষ্টা করা যার ভ্যালু স্কোপের বাইরে চলে গেছে">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/src/main.rs}}
```

</Listing>

> দ্রষ্টব্য: Listing 10-16, 10-17 এবং 10-23-এর উদাহরণগুলো ভেরিয়েবলগুলোকে কোনো প্রাথমিক ভ্যালু না দিয়েই ঘোষণা করে, তাই ভেরিয়েবলের নামটি বাইরের স্কোপে বিদ্যমান থাকে। প্রথম নজরে, এটি রাস্টের কোনো নাল ভ্যালু না থাকার সাথে বিরোধপূর্ণ মনে হতে পারে। যাইহোক, যদি আমরা কোনো ভেরিয়েবলকে ভ্যালু দেওয়ার আগে ব্যবহার করার চেষ্টা করি, তাহলে আমরা একটি কম্পাইল-টাইম এরর পাব, যা দেখায় যে রাস্ট সত্যিই নাল ভ্যালু ব্যবহারের অনুমতি দেয় না।

বাইরের স্কোপ `r` নামের একটি ভেরিয়েবল ঘোষণা করে যার কোনো প্রাথমিক ভ্যালু নেই এবং ভিতরের স্কোপ `x` নামের একটি ভেরিয়েবল ঘোষণা করে যার প্রাথমিক ভ্যালু হল `5`। ভিতরের স্কোপের ভিতরে, আমরা `x`-এর রেফারেন্স হিসাবে `r`-এর ভ্যালু সেট করার চেষ্টা করি। তারপর ভিতরের স্কোপ শেষ হয় এবং আমরা `r`-এর ভ্যালু প্রিন্ট করার চেষ্টা করি। এই কোডটি কম্পাইল হবে না কারণ `r` যে ভ্যালুকে রেফার করছে সেটি ব্যবহার করার চেষ্টা করার আগেই স্কোপের বাইরে চলে গেছে। এখানে এরর বার্তাটি দেওয়া হল:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-16/output.txt}}
```

এরর বার্তাটি বলছে যে ভেরিয়েবল `x` "যথেষ্ট দীর্ঘকাল বাঁচে না।" কারণ হল লাইন 7-এ ভিতরের স্কোপ শেষ হলে `x` স্কোপের বাইরে চলে যাবে। কিন্তু `r` এখনও বাইরের স্কোপের জন্য বৈধ; যেহেতু এর স্কোপ বড়, তাই আমরা বলি যে এটি "বেশি সময় ধরে বাঁচে"। যদি রাস্ট এই কোডটিকে কাজ করার অনুমতি দিত, তাহলে `r` এমন মেমরিকে রেফার করত যা `x` স্কোপের বাইরে চলে গেলে ডি-অ্যালোকেট করা হয়েছিল, এবং `r` দিয়ে আমরা যা করার চেষ্টা করতাম তা সঠিকভাবে কাজ করত না। তাহলে রাস্ট কিভাবে নির্ধারণ করে যে এই কোডটি অবৈধ? এটি একটি বরো চেকার ব্যবহার করে।

### বরো চেকার

রাস্ট কম্পাইলারে একটি _বরো চেকার_ রয়েছে যা সমস্ত বরো বৈধ কিনা তা নির্ধারণ করতে স্কোপগুলোর তুলনা করে। Listing 10-17 Listing 10-16 এর মতোই কোড দেখায় তবে ভেরিয়েবলের লাইফটাইম দেখিয়ে টীকা করা হয়েছে।

<Listing number="10-17" caption="`r` এবং `x`-এর লাইফটাইমের টীকা, যথাক্রমে `'a` এবং `'b` নামে">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-17/src/main.rs}}
```

</Listing>

এখানে, আমরা `r`-এর লাইফটাইম `'a` এবং `x`-এর লাইফটাইম `'b` দিয়ে টীকা করেছি। আপনি দেখতে পাচ্ছেন, ভিতরের `'b` ব্লকটি বাইরের `'a` লাইফটাইম ব্লকের চেয়ে অনেক ছোট। কম্পাইল করার সময়, রাস্ট দুটি লাইফটাইমের আকার তুলনা করে এবং দেখে যে `r`-এর লাইফটাইম `'a` কিন্তু এটি `'b` লাইফটাইমযুক্ত মেমরিকে নির্দেশ করে। প্রোগ্রামটি প্রত্যাখ্যান করা হয়েছে কারণ `'b` `'a`-এর চেয়ে ছোট: রেফারেন্সের বিষয় রেফারেন্সের মতো দীর্ঘ বাঁচে না।

Listing 10-18 কোডটিকে ঠিক করে যাতে এটির কোনো ড্যাংলিং রেফারেন্স না থাকে এবং এটি কোনো এরর ছাড়াই কম্পাইল হয়।

<Listing number="10-18" caption="একটি বৈধ রেফারেন্স কারণ ডেটার লাইফটাইম রেফারেন্সের চেয়ে বেশি">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-18/src/main.rs}}
```

</Listing>

এখানে, `x`-এর লাইফটাইম `'b`, যা এই ক্ষেত্রে `'a`-এর চেয়ে বড়। এর মানে হল `r` `x`-কে রেফার করতে পারে কারণ রাস্ট জানে যে `r`-এর রেফারেন্সটি সবসময় বৈধ থাকবে যখন `x` বৈধ থাকে।

এখন যেহেতু আপনি জানেন যে রেফারেন্সগুলোর লাইফটাইম কী এবং রাস্ট কীভাবে রেফারেন্সগুলো সবসময় বৈধ হবে তা নিশ্চিত করার জন্য লাইফটাইম বিশ্লেষণ করে, আসুন ফাংশনের প্রেক্ষাপটে প্যারামিটার এবং রিটার্ন ভ্যালুর জেনেরিক লাইফটাইমগুলো নিয়ে আলোচনা করি।

### ফাংশনে জেনেরিক লাইফটাইম

আমরা এমন একটি ফাংশন লিখব যা দুটি স্ট্রিং স্লাইসের মধ্যে দীর্ঘতরটি রিটার্ন করে। এই ফাংশনটি দুটি স্ট্রিং স্লাইস নেবে এবং একটি একক স্ট্রিং স্লাইস রিটার্ন করবে। `longest` ফাংশন প্রয়োগ করার পরে, Listing 10-19-এর কোডটি `The longest string is abcd` প্রিন্ট করা উচিত।

<Listing number="10-19" file-name="src/main.rs" caption="একটি `main` ফাংশন যা দুটি স্ট্রিং স্লাইসের মধ্যে দীর্ঘতরটি খুঁজে বের করার জন্য `longest` ফাংশন কল করে">

```rust,ignore
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-19/src/main.rs}}
```

</Listing>

মনে রাখবেন যে আমরা চাই ফাংশনটি স্ট্রিংয়ের পরিবর্তে স্ট্রিং স্লাইস গ্রহণ করুক, যা রেফারেন্স, কারণ আমরা চাই না যে `longest` ফাংশনটি এর প্যারামিটারগুলোর মালিকানা গ্রহণ করুক। কেন Listing 10-19-এ আমরা যে প্যারামিটারগুলো ব্যবহার করি সেগুলোই আমরা চাই সে সম্পর্কে আরও আলোচনার জন্য Chapter 4-এর [“প্যারামিটার হিসাবে স্ট্রিং স্লাইস”][string-slices-as-parameters]<!-- ignore --> বিভাগটি দেখুন।

যদি আমরা Listing 10-20-এ দেখানো হিসাবে `longest` ফাংশন প্রয়োগ করার চেষ্টা করি, তবে এটি কম্পাইল হবে না।

<Listing number="10-20" file-name="src/main.rs" caption="`longest` ফাংশনের একটি বাস্তবায়ন যা দুটি স্ট্রিং স্লাইসের মধ্যে দীর্ঘতরটি রিটার্ন করে তবে এখনও কম্পাইল হয় না">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/src/main.rs:here}}
```

</Listing>

পরিবর্তে, আমরা নিম্নলিখিত এররটি পাই যা লাইফটাইম সম্পর্কে কথা বলে:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-20/output.txt}}
```

সহায়তা পাঠ্যটি প্রকাশ করে যে রিটার্ন টাইপের উপর একটি জেনেরিক লাইফটাইম প্যারামিটারের প্রয়োজন কারণ রাস্ট বলতে পারে না যে রিটার্ন করা রেফারেন্সটি `x` বা `y`-কে নির্দেশ করে কিনা। আসলে, আমরাও জানি না, কারণ এই ফাংশনের বডির `if` ব্লক `x`-এর একটি রেফারেন্স রিটার্ন করে এবং `else` ব্লক `y`-এর একটি রেফারেন্স রিটার্ন করে!

যখন আমরা এই ফাংশনটি সংজ্ঞায়িত করছি, তখন আমরা জানি না যে এই ফাংশনে কোন কংক্রিট ভ্যালু পাস করা হবে, তাই আমরা জানি না যে `if` কেস বা `else` কেসটি কার্যকর হবে কিনা। আমরা যে রেফারেন্সগুলো পাস করা হবে সেগুলোর কংক্রিট লাইফটাইমও জানি না, তাই আমরা Listing 10-17 এবং 10-18-এর মতো স্কোপগুলো দেখতে পারি না যাতে আমরা যে রেফারেন্সটি রিটার্ন করি তা সবসময় বৈধ হবে কিনা তা নির্ধারণ করতে পারি। বরো চেকারও এটি নির্ধারণ করতে পারে না, কারণ এটি জানে না যে `x` এবং `y`-এর লাইফটাইমগুলো রিটার্ন ভ্যালুর লাইফটাইমের সাথে কীভাবে সম্পর্কিত। এই এররটি ঠিক করতে, আমরা জেনেরিক লাইফটাইম প্যারামিটার যোগ করব যা রেফারেন্সগুলোর মধ্যে সম্পর্ক সংজ্ঞায়িত করে যাতে বরো চেকার তার বিশ্লেষণ করতে পারে।

### লাইফটাইম টীকা সিনট্যাক্স

লাইফটাইম টীকাগুলো কোনো রেফারেন্স কতক্ষণ বাঁচে তা পরিবর্তন করে না। বরং, তারা লাইফটাইমগুলোকে প্রভাবিত না করে একাধিক রেফারেন্সের লাইফটাইমের একে অপরের সাথে সম্পর্ক বর্ণনা করে। ঠিক যেমন ফাংশনগুলো যখন সিগনেচার একটি জেনেরিক টাইপ প্যারামিটার নির্দিষ্ট করে তখন যেকোনো টাইপ গ্রহণ করতে পারে, তেমনি ফাংশনগুলো একটি জেনেরিক লাইফটাইম প্যারামিটার নির্দিষ্ট করে যেকোনো লাইফটাইমের সাথে রেফারেন্স গ্রহণ করতে পারে।

লাইফটাইম টীকাগুলোর একটি সামান্য অস্বাভাবিক সিনট্যাক্স রয়েছে: লাইফটাইম প্যারামিটারের নামগুলো অবশ্যই একটি অ্যাপোস্ট্রোফি (`'`) দিয়ে শুরু হতে হবে এবং সাধারণত জেনেরিক টাইপের মতো ছোট হাতের এবং খুব ছোট হয়। বেশিরভাগ লোক প্রথম লাইফটাইম টীকার জন্য `'a` নামটি ব্যবহার করে। আমরা একটি রেফারেন্সের `&`-এর পরে লাইফটাইম প্যারামিটার টীকা রাখি, রেফারেন্সের টাইপ থেকে টীকাটিকে আলাদা করতে একটি স্পেস ব্যবহার করে।

এখানে কিছু উদাহরণ দেওয়া হল: লাইফটাইম প্যারামিটার ছাড়া একটি `i32` এর রেফারেন্স, একটি `i32` এর রেফারেন্স যার `'a` নামের একটি লাইফটাইম প্যারামিটার রয়েছে এবং একটি `i32`-এর মিউটেবল রেফারেন্স যার লাইফটাইম `'a`-ও রয়েছে।

```rust,ignore
&i32        // একটি রেফারেন্স
&'a i32     // একটি সুস্পষ্ট লাইফটাইম সহ একটি রেফারেন্স
&'a mut i32 // একটি সুস্পষ্ট লাইফটাইম সহ একটি মিউটেবল রেফারেন্স
```

একাই একটি লাইফটাইম টীকার খুব বেশি অর্থ নেই কারণ টীকাগুলোর উদ্দেশ্য হল রাস্টকে বলা যে একাধিক রেফারেন্সের জেনেরিক লাইফটাইম প্যারামিটারগুলো একে অপরের সাথে কীভাবে সম্পর্কিত। আসুন `longest` ফাংশনের প্রেক্ষাপটে লাইফটাইম টীকাগুলো একে অপরের সাথে কীভাবে সম্পর্কিত তা পরীক্ষা করি।

### ফাংশন সিগনেচারে লাইফটাইম টীকা

ফাংশন সিগনেচারে লাইফটাইম টীকা ব্যবহার করার জন্য, ফাংশনের নাম এবং প্যারামিটার তালিকার মধ্যে কোণের বন্ধনীর ভিতরে জেনেরিক _লাইফটাইম_ প্যারামিটারগুলো ঘোষণা করতে হবে, ঠিক যেমন আমরা জেনেরিক _টাইপ_ প্যারামিটারগুলোর সাথে করেছিলাম।

আমরা চাই সিগনেচারটি নিম্নলিখিত সীমাবদ্ধতা প্রকাশ করুক: যতক্ষণ পর্যন্ত উভয় প্যারামিটার বৈধ থাকবে ততক্ষণ পর্যন্ত রিটার্ন করা রেফারেন্সটি বৈধ হবে। এটি প্যারামিটারের লাইফটাইম এবং রিটার্ন ভ্যালুর মধ্যে সম্পর্ক। আমরা লাইফটাইমটির নাম `'a` রাখব এবং তারপর Listing 10-21 এ দেখানো হিসাবে প্রতিটি রেফারেন্সে যোগ করব।

<Listing number="10-21" file-name="src/main.rs" caption="`longest` ফাংশনের সংজ্ঞা উল্লেখ করে যে সিগনেচারের সমস্ত রেফারেন্সের একই লাইফটাইম `'a` থাকতে হবে">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-21/src/main.rs:here}}
```

</Listing>

এই কোডটি কম্পাইল করা উচিত এবং যখন আমরা এটিকে Listing 10-19-এর `main` ফাংশনের সাথে ব্যবহার করি তখন আমাদের কাঙ্ক্ষিত ফলাফল তৈরি করা উচিত।

ফাংশন সিগনেচার এখন রাস্টকে বলে যে কিছু লাইফটাইম `'a`-এর জন্য, ফাংশনটি দুটি প্যারামিটার নেয়, উভয়ই স্ট্রিং স্লাইস যা অন্তত লাইফটাইম `'a` পর্যন্ত বাঁচে। ফাংশন সিগনেচার রাস্টকে আরও বলে যে ফাংশন থেকে রিটার্ন করা স্ট্রিং স্লাইসটি অন্তত লাইফটাইম `'a` পর্যন্ত বাঁচবে। বাস্তবে, এর মানে হল `longest` ফাংশন দ্বারা রিটার্ন করা রেফারেন্সের লাইফটাইম ফাংশনের আর্গুমেন্ট দ্বারা রেফার করা ভ্যালুগুলোর লাইফটাইমের মধ্যে ছোটটির সমান। এই সম্পর্কগুলোই আমরা চাই যে রাস্ট এই কোডটি বিশ্লেষণ করার সময় ব্যবহার করুক।

মনে রাখবেন, যখন আমরা এই ফাংশন সিগনেচারে লাইফটাইম প্যারামিটারগুলো উল্লেখ করি, তখন আমরা পাস করা বা রিটার্ন করা কোনো ভ্যালুর লাইফটাইম পরিবর্তন করছি না। বরং, আমরা নির্দিষ্ট করছি যে বরো চেকার সেই ভ্যালুগুলোকে প্রত্যাখ্যান করবে যা এই সীমাবদ্ধতাগুলো মেনে চলে না। মনে রাখবেন যে `longest` ফাংশনকে ঠিক কতক্ষণ `x` এবং `y` বাঁচবে তা জানার প্রয়োজন নেই, শুধুমাত্র `'a`-এর জন্য এমন একটি স্কোপ প্রতিস্থাপিত করা যেতে পারে যা এই সিগনেচার পূরণ করবে।

ফাংশনে লাইফটাইম টীকা করার সময়, টীকাগুলো ফাংশন বডিতে নয়, ফাংশন সিগনেচারে যায়। লাইফটাইম টীকাগুলো ফাংশনের চুক্তির অংশ হয়ে যায়, অনেকটা সিগনেচারের টাইপগুলোর মতো। ফাংশন সিগনেচারে লাইফটাইম চুক্তি থাকলে রাস্ট কম্পাইলার যে বিশ্লেষণ করে তা সহজ হতে পারে। যদি কোনো ফাংশনকে টীকা করার বা এটি কল করার পদ্ধতিতে কোনো সমস্যা থাকে, তাহলে কম্পাইলার আমাদের কোডের অংশ এবং সীমাবদ্ধতাগুলোর দিকে আরও স্পষ্টভাবে নির্দেশ করতে পারে। যদি, পরিবর্তে, রাস্ট কম্পাইলার লাইফটাইমগুলোর সম্পর্কগুলো কী হওয়া উচিত সে সম্পর্কে আরও বেশি অনুমান করত, তাহলে কম্পাইলার সমস্যার কারণ থেকে অনেক দূরে আমাদের কোডের একটি ব্যবহারের দিকে নির্দেশ করতে পারত।

যখন আমরা `longest`-এ কংক্রিট রেফারেন্স পাস করি, তখন `'a`-এর জন্য প্রতিস্থাপিত কংক্রিট লাইফটাইম হল `x`-এর স্কোপের সেই অংশ যা `y`-এর স্কোপের সাথে ওভারল্যাপ করে। অন্য কথায়, জেনেরিক লাইফটাইম `'a` সেই কংক্রিট লাইফটাইম পাবে যা `x` এবং `y`-এর লাইফটাইমের মধ্যে ছোটটির সমান। যেহেতু আমরা একই লাইফটাইম প্যারামিটার `'a` দিয়ে রিটার্ন করা রেফারেন্সটিকে টীকা করেছি, তাই রিটার্ন করা রেফারেন্সটিও `x` এবং `y`-এর লাইফটাইমের মধ্যে ছোটটির দৈর্ঘ্যের জন্য বৈধ হবে।

আসুন দেখি কিভাবে লাইফটাইম টীকাগুলো `longest` ফাংশনকে সীমাবদ্ধ করে বিভিন্ন কংক্রিট লাইফটাইমযুক্ত রেফারেন্স পাস করার মাধ্যমে। Listing 10-22 একটি সরল উদাহরণ।

<Listing number="10-22" file-name="src/main.rs" caption="`String` ভ্যালুর রেফারেন্স সহ `longest` ফাংশন ব্যবহার করা যার বিভিন্ন কংক্রিট লাইফটাইম রয়েছে">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-22/src/main.rs:here}}
```

</Listing>

এই উদাহরণে, `string1` বাইরের স্কোপের শেষ পর্যন্ত বৈধ, `string2` ভিতরের স্কোপের শেষ পর্যন্ত বৈধ এবং `result` এমন কিছুকে রেফার করে যা ভিতরের স্কোপের শেষ পর্যন্ত বৈধ। এই কোডটি চালান এবং আপনি দেখতে পাবেন যে বরো চেকার এটিকে অনুমোদন করে; এটি কম্পাইল হবে এবং প্রিন্ট করবে `The longest string
is long string is long`।

এর পরে, আসুন এমন একটি উদাহরণ চেষ্টা করি যা দেখায় যে `result`-এর রেফারেন্সের লাইফটাইম দুটি আর্গুমেন্টের ছোট লাইফটাইম হতে হবে। আমরা `result` ভেরিয়েবলের ঘোষণাটিকে ভিতরের স্কোপের বাইরে নিয়ে যাব কিন্তু `string2` সহ স্কোপের ভিতরে `result` ভেরিয়েবলে ভ্যালু নির্ধারণ করা রেখে দেব। তারপর আমরা `result` ব্যবহার করে `println!` কে ভিতরের স্কোপের বাইরে, ভিতরের স্কোপ শেষ হওয়ার পরে নিয়ে যাব। Listing 10-23-এর কোডটি কম্পাইল হবে না।

<Listing number="10-23" file-name="src/main.rs" caption="`string2` স্কোপের বাইরে চলে যাওয়ার পরে `result` ব্যবহার করার চেষ্টা করা">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/src/main.rs:here}}
```

</Listing>

যখন আমরা এই কোডটি কম্পাইল করার চেষ্টা করি, তখন আমরা এই এররটি পাই:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-23/output.txt}}
```

এররটি দেখায় যে `println!` স্টেটমেন্টের জন্য `result`-কে বৈধ হওয়ার জন্য `string2`-কে বাইরের স্কোপের শেষ পর্যন্ত বৈধ হতে হবে। রাস্ট এটি জানে কারণ আমরা একই লাইফটাইম প্যারামিটার `'a` ব্যবহার করে ফাংশন প্যারামিটার এবং রিটার্ন ভ্যালুর লাইফটাইম টীকা করেছি।

মানুষ হিসাবে, আমরা এই কোডটি দেখে বুঝতে পারি যে `string1` `string2`-এর চেয়ে দীর্ঘ, এবং সেইজন্য, `result`-এ `string1`-এর একটি রেফারেন্স থাকবে। যেহেতু `string1` এখনও স্কোপের বাইরে যায়নি, তাই `string1`-এর একটি রেফারেন্স `println!` স্টেটমেন্টের জন্য এখনও বৈধ থাকবে। যাইহোক, কম্পাইলার এই ক্ষেত্রে রেফারেন্সটি বৈধ কিনা তা দেখতে পায় না। আমরা রাস্টকে বলেছি যে `longest` ফাংশন দ্বারা রিটার্ন করা রেফারেন্সের লাইফটাইম পাস করা রেফারেন্সগুলোর লাইফটাইমের মধ্যে ছোটটির সমান। অতএব, বরো চেকার Listing 10-23-এর কোডটিকে সম্ভবত একটি অবৈধ রেফারেন্স হিসাবে বাতিল করে।

`longest` ফাংশনে পাস করা রেফারেন্সগুলোর ভ্যালু এবং লাইফটাইম এবং রিটার্ন করা রেফারেন্স কীভাবে ব্যবহার করা হয় তা পরিবর্তন করে আরও পরীক্ষা ডিজাইন করার চেষ্টা করুন। আপনি কম্পাইল করার আগে আপনার পরীক্ষাগুলো বরো চেকার পাস করবে কিনা সে সম্পর্কে অনুমান করুন; তারপর আপনি সঠিক কিনা তা পরীক্ষা করে দেখুন!

### লাইফটাইমের পরিপ্রেক্ষিতে চিন্তা করা

আপনাকে লাইফটাইম প্যারামিটারগুলো কীভাবে নির্দিষ্ট করতে হবে তা আপনার ফাংশন কী করছে তার উপর নির্ভর করে। উদাহরণস্বরূপ, যদি আমরা `longest` ফাংশনের বাস্তবায়ন পরিবর্তন করে দীর্ঘতম স্ট্রিং স্লাইসের পরিবর্তে সর্বদা প্রথম প্যারামিটারটি রিটার্ন করি, তবে আমাদের `y` প্যারামিটারে লাইফটাইম নির্দিষ্ট করার প্রয়োজন হবে না। নিম্নলিখিত কোডটি কম্পাইল হবে:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-08-only-one-reference-with-lifetime/src/main.rs:here}}
```

</Listing>

আমরা প্যারামিটার `x` এবং রিটার্ন টাইপের জন্য একটি লাইফটাইম প্যারামিটার `'a` নির্দিষ্ট করেছি, তবে প্যারামিটার `y`-এর জন্য নয়, কারণ `y`-এর লাইফটাইমের সাথে `x` বা রিটার্ন ভ্যালুর লাইফটাইমের কোনো সম্পর্ক নেই।

একটি ফাংশন থেকে একটি রেফারেন্স রিটার্ন করার সময়, রিটার্ন টাইপের লাইফটাইম প্যারামিটারটিকে প্যারামিটারগুলোর একটির লাইফটাইম প্যারামিটারের সাথে মিলতে হবে। যদি রিটার্ন করা রেফারেন্সটি প্যারামিটারগুলোর একটিকে নির্দেশ _না_ করে, তবে এটিকে এই ফাংশনের ভিতরে তৈরি করা একটি ভ্যালুকে নির্দেশ করতে হবে। যাইহোক, এটি একটি ড্যাংলিং রেফারেন্স হবে কারণ ফাংশন শেষে ভ্যালুটি স্কোপের বাইরে চলে যাবে। `longest` ফাংশনের এই চেষ্টা করা বাস্তবায়নটি বিবেচনা করুন যা কম্পাইল হবে না:

<Listing file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/src/main.rs:here}}
```

</Listing>

এখানে, যদিও আমরা রিটার্ন টাইপের জন্য একটি লাইফটাইম প্যারামিটার `'a` নির্দিষ্ট করেছি, এই বাস্তবায়নটি কম্পাইল করতে ব্যর্থ হবে কারণ রিটার্ন ভ্যালুর লাইফটাইম প্যারামিটারগুলোর লাইফটাইমের সাথে মোটেও সম্পর্কিত নয়। এখানে আমরা যে এরর বার্তাটি পাই তা দেওয়া হল:

```console
{{#include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-09-unrelated-lifetime/output.txt}}
```

সমস্যা হল `result` স্কোপের বাইরে চলে যায় এবং `longest` ফাংশনের শেষে পরিষ্কার হয়ে যায়। আমরা ফাংশন থেকে `result`-এর একটি রেফারেন্স রিটার্ন করারও চেষ্টা করছি। এমন কোনো উপায় নেই যা আমরা লাইফটাইম প্যারামিটার নির্দিষ্ট করতে পারি যা ড্যাংলিং রেফারেন্স পরিবর্তন করবে, এবং রাস্ট আমাদের ড্যাংলিং রেফারেন্স তৈরি করতে দেবে না। এই ক্ষেত্রে, সেরা সমাধান হল রেফারেন্সের পরিবর্তে একটি ওনড ডেটা টাইপ রিটার্ন করা যাতে কলিং ফাংশন তখন ভ্যালু পরিষ্কার করার জন্য দায়ী থাকে।

অবশেষে, লাইফটাইম সিনট্যাক্স হল ফাংশনের বিভিন্ন প্যারামিটার এবং রিটার্ন ভ্যালুগুলোর লাইফটাইমকে সংযুক্ত করা। একবার সেগুলো সংযুক্ত হয়ে গেলে, রাস্টের কাছে মেমরি-সুরক্ষিত ক্রিয়াকলাপগুলোর অনুমতি দিতে এবং এমন ক্রিয়াকলাপগুলো নিষিদ্ধ করার জন্য পর্যাপ্ত তথ্য থাকে যা ড্যাংলিং পয়েন্টার তৈরি করবে বা অন্যথায় মেমরি সুরক্ষা লঙ্ঘন করবে।

### Struct সংজ্ঞায় লাইফটাইম টীকা

এখন পর্যন্ত, আমরা যে struct গুলো সংজ্ঞায়িত করেছি সেগুলো সবই ওনড টাইপ ধারণ করে। আমরা রেফারেন্স ধারণ করার জন্য struct সংজ্ঞায়িত করতে পারি, তবে সেই ক্ষেত্রে আমাদের struct-এর সংজ্ঞায় প্রতিটি রেফারেন্সে একটি লাইফটাইম টীকা যোগ করতে হবে। Listing 10-24-এ `ImportantExcerpt` নামের একটি struct রয়েছে যা একটি স্ট্রিং স্লাইস ধারণ করে।

<Listing number="10-24" file-name="src/main.rs" caption="একটি struct যা একটি রেফারেন্স ধারণ করে, যার জন্য একটি লাইফটাইম টীকা প্রয়োজন">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-24/src/main.rs}}
```

</Listing>

এই struct-টিতে একটি একক ফিল্ড `part` আছে যা একটি স্ট্রিং স্লাইস ধারণ করে, যা একটি রেফারেন্স। জেনেরিক ডেটা টাইপের মতো, struct-এর নামের পরে কোণের বন্ধনীর ভিতরে জেনেরিক লাইফটাইম প্যারামিটারের নামটি ঘোষণা করি যাতে আমরা struct সংজ্ঞার বডিতে লাইফটাইম প্যারামিটারটি ব্যবহার করতে পারি। এই টীকার মানে হল `ImportantExcerpt`-এর একটি উদাহরণ এর `part` ফিল্ডে থাকা রেফারেন্সের চেয়ে বেশি বাঁচতে পারবে না।

এখানে `main` ফাংশনটি `ImportantExcerpt` struct-এর একটি উদাহরণ তৈরি করে যা `novel` ভেরিয়েবল দ্বারা ওন করা `String`-এর প্রথম বাক্যের একটি রেফারেন্স ধারণ করে। `ImportantExcerpt` উদাহরণ তৈরি হওয়ার আগে `novel`-এর ডেটা বিদ্যমান। এছাড়াও, `ImportantExcerpt` স্কোপের বাইরে যাওয়ার পরেই `novel` স্কোপের বাইরে চলে যায়, তাই `ImportantExcerpt` উদাহরণের রেফারেন্সটি বৈধ।

### লাইফটাইম বিলুপ্তি

আপনি শিখেছেন যে প্রতিটি রেফারেন্সের একটি লাইফটাইম থাকে এবং রেফারেন্স ব্যবহার করে এমন ফাংশন বা struct-এর জন্য আপনাকে লাইফটাইম প্যারামিটার নির্দিষ্ট করতে হবে। যাইহোক, আমাদের Listing 4-9-এ একটি ফাংশন ছিল, যা Listing 10-25-এ আবার দেখানো হয়েছে, যা লাইফটাইম টীকা ছাড়াই কম্পাইল হয়েছে।

<Listing number="10-25" file-name="src/lib.rs" caption="Listing 4-9-এ সংজ্ঞায়িত একটি ফাংশন যা লাইফটাইম টীকা ছাড়াই কম্পাইল হয়েছে, যদিও প্যারামিটার এবং রিটার্ন টাইপ রেফারেন্স">

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/listing-10-25/src/main.rs:here}}
```

</Listing>

এই ফাংশনটি লাইফটাইম টীকা ছাড়াই কম্পাইল হওয়ার কারণ হল ঐতিহাসিক: রাস্টের আগের সংস্করণগুলোতে (1.0 এর আগে), এই কোডটি কম্পাইল হত না কারণ প্রতিটি রেফারেন্সের একটি সুস্পষ্ট লাইফটাইমের প্রয়োজন ছিল। সেই সময়ে, ফাংশনের সিগনেচারটি এইরকম লেখা হত:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

প্রচুর রাস্ট কোড লেখার পরে, রাস্ট টিম দেখেছে যে রাস্ট প্রোগ্রামাররা নির্দিষ্ট পরিস্থিতিতে বারবার একই লাইফটাইম টীকা প্রবেশ করাচ্ছে। এই পরিস্থিতিগুলো অনুমানযোগ্য ছিল এবং কয়েকটি নির্ধারক প্যাটার্ন অনুসরণ করত। ডেভেলপাররা এই প্যাটার্নগুলো কম্পাইলারের কোডে প্রোগ্রাম করেছে যাতে বরো চেকার এই পরিস্থিতিতে লাইফটাইমগুলো অনুমান করতে পারে এবং সুস্পষ্ট টীকাগুলোর প্রয়োজন হবে না।

রাস্ট ইতিহাসের এই অংশটি প্রাসঙ্গিক কারণ এটি সম্ভব যে আরও নির্ধারক প্যাটার্ন আবির্ভূত হবে এবং কম্পাইলারে যোগ করা হবে। ভবিষ্যতে, আরও কম লাইফটাইম টীকার প্রয়োজন হতে পারে।

রেফারেন্সগুলোর রাস্টের বিশ্লেষণের জন্য প্রোগ্রাম করা প্যাটার্নগুলোকে _লাইফটাইম বিলুপ্তি নিয়ম_ বলা হয়। এগুলো প্রোগ্রামারদের অনুসরণ করার নিয়ম নয়; এগুলো হল নির্দিষ্ট কিছু কেসের একটি সেট যা কম্পাইলার বিবেচনা করবে, এবং যদি আপনার কোড এই কেসগুলোর সাথে ফিট করে, তাহলে আপনাকে স্পষ্টভাবে লাইফটাইম লিখতে হবে না।

বিলুপ্তির নিয়মগুলো সম্পূর্ণ অনুমান প্রদান করে না। রাস্ট নিয়মগুলো প্রয়োগ করার পরেও রেফারেন্সগুলোর লাইফটাইম কী হবে তা নিয়ে যদি এখনও অস্পষ্টতা থাকে, তবে কম্পাইলার অবশিষ্ট রেফারেন্সগুলোর লাইফটাইম কী হওয়া উচিত তা অনুমান করবে না। অনুমান করার পরিবর্তে, কম্পাইলার আপনাকে একটি এরর দেবে যা আপনি লাইফটাইম টীকা যোগ করে সমাধান করতে পারেন।

ফাংশন বা মেথড প্যারামিটারের লাইফটাইমগুলোকে _ইনপুট লাইফটাইম_ বলা হয় এবং রিটার্ন ভ্যালুর লাইফটাইমগুলোকে _আউটপুট লাইফটাইম_ বলা হয়।

কম্পাইলার যখন সুস্পষ্ট টীকা থাকে না তখন রেফারেন্সগুলোর লাইফটাইম বের করার জন্য তিনটি নিয়ম ব্যবহার করে। প্রথম নিয়মটি ইনপুট লাইফটাইমের জন্য প্রযোজ্য এবং দ্বিতীয় ও তৃতীয় নিয়মটি আউটপুট লাইফটাইমের জন্য প্রযোজ্য। যদি কম্পাইলার তিনটি নিয়মের শেষে পৌঁছে যায় এবং এখনও এমন রেফারেন্স থাকে যার জন্য এটি লাইফটাইম বের করতে পারে না, তবে কম্পাইলার একটি এরর দিয়ে বন্ধ হয়ে যাবে। এই নিয়মগুলো `fn` সংজ্ঞা এবং `impl` ব্লকের ক্ষেত্রেও প্রযোজ্য।

প্রথম নিয়মটি হল কম্পাইলার প্রতিটি প্যারামিটারকে একটি লাইফটাইম প্যারামিটার নির্ধারণ করে যা একটি রেফারেন্স। অন্য কথায়, একটি প্যারামিটারযুক্ত একটি ফাংশন একটি লাইফটাইম প্যারামিটার পায়: `fn foo<'a>(x: &'a i32)`; দুটি প্যারামিটারযুক্ত একটি ফাংশন দুটি পৃথক লাইফটাইম প্যারামিটার পায়: `fn foo<'a, 'b>(x: &'a i32,
y: &'b i32)`; ইত্যাদি।

দ্বিতীয় নিয়মটি হল, যদি ঠিক একটি ইনপুট লাইফটাইম প্যারামিটার থাকে, তবে সেই লাইফটাইমটি সমস্ত আউটপুট লাইফটাইম প্যারামিটারে নির্ধারণ করা হয়: `fn foo<'a>(x: &'a i32)
-> &'a i32`।

তৃতীয় নিয়মটি হল, যদি একাধিক ইনপুট লাইফটাইম প্যারামিটার থাকে, তবে তাদের মধ্যে একটি যদি `&self` বা `&mut self` হয় কারণ এটি একটি মেথড, তবে `self`-এর লাইফটাইমটি সমস্ত আউটপুট লাইফটাইম প্যারামিটারে নির্ধারণ করা হয়। এই তৃতীয় নিয়মটি মেথডগুলোকে পড়তে এবং লিখতে অনেক সহজ করে তোলে কারণ খুব কম প্রতীকের প্রয়োজন হয়।

ধরা যাক আমরা কম্পাইলার। Listing 10-25-এ `first_word` ফাংশনের সিগনেচারে রেফারেন্সগুলোর লাইফটাইম বের করার জন্য আমরা এই নিয়মগুলো প্রয়োগ করব। সিগনেচারটি রেফারেন্সগুলোর সাথে যুক্ত কোনো লাইফটাইম ছাড়াই শুরু হয়:

```rust,ignore
fn first_word(s: &str) -> &str {
```

তারপর কম্পাইলার প্রথম নিয়মটি প্রয়োগ করে, যা নির্দিষ্ট করে যে প্রতিটি প্যারামিটার তার নিজস্ব লাইফটাইম পায়। আমরা এটিকে সাধারণত `'a` বলব, তাই এখন সিগনেচারটি এইরকম:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &str {
```

দ্বিতীয় নিয়মটি প্রযোজ্য কারণ এখানে ঠিক একটি ইনপুট লাইফটাইম রয়েছে। দ্বিতীয় নিয়মটি নির্দিষ্ট করে যে একটি ইনপুট প্যারামিটারের লাইফটাইম আউটপুট লাইফটাইমে নির্ধারিত হয়, তাই সিগনেচারটি এখন এইরকম:

```rust,ignore
fn first_word<'a>(s: &'a str) -> &'a str {
```

এখন এই ফাংশন সিগনেচারের সমস্ত রেফারেন্সের লাইফটাইম রয়েছে এবং কম্পাইলার এই ফাংশন সিগনেচারে লাইফটাইমগুলো টীকা করার জন্য প্রোগ্রামারের প্রয়োজন ছাড়াই তার বিশ্লেষণ চালিয়ে যেতে পারে।

আসুন অন্য একটি উদাহরণ দেখি, এবার `longest` ফাংশন ব্যবহার করে যার সাথে কাজ শুরু করার সময় Listing 10-20-এ কোনো লাইফটাইম প্যারামিটার ছিল না:

```rust,ignore
fn longest(x: &str, y: &str) -> &str {
```

আসুন প্রথম নিয়ম প্রয়োগ করি: প্রতিটি প্যারামিটার তার নিজস্ব লাইফটাইম পায়। এবার আমাদের একটির পরিবর্তে দুটি প্যারামিটার আছে, তাই আমাদের দুটি লাইফটাইম আছে:

```rust,ignore
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

আপনি দেখতে পাচ্ছেন যে দ্বিতীয় নিয়মটি প্রযোজ্য নয় কারণ এখানে একাধিক ইনপুট লাইফটাইম রয়েছে। তৃতীয় নিয়মটিও প্রযোজ্য নয়, কারণ `longest` একটি মেথডের পরিবর্তে একটি ফাংশন, তাই কোনো প্যারামিটারই `self` নয়। তিনটি নিয়ম শেষ করার পরেও আমরা এখনও রিটার্ন টাইপের লাইফটাইম বের করতে পারিনি। এই কারণেই Listing 10-20-এ কোডটি কম্পাইল করার চেষ্টা করার সময় আমরা একটি এরর পেয়েছিলাম: কম্পাইলার লাইফটাইম বিলুপ্তির নিয়মগুলো দিয়ে কাজ করেছে কিন্তু এখনও সিগনেচারের সমস্ত রেফারেন্সের লাইফটাইম বের করতে পারেনি।

যেহেতু তৃতীয় নিয়মটি সত্যিই শুধুমাত্র মেথড সিগনেচারে প্রযোজ্য, তাই আমরা পরবর্তীতে সেই প্রেক্ষাপটে লাইফটাইমগুলো দেখব কেন তৃতীয় নিয়মের মানে হল মেথড সিগনেচারে আমাদের খুব কমই লাইফটাইম টীকা করতে হয়।

### মেথড সংজ্ঞায় লাইফটাইম টীকা

যখন আমরা লাইফটাইম সহ একটি struct-এ মেথড প্রয়োগ করি, তখন আমরা Listing 10-11-এ দেখানো জেনেরিক টাইপ প্যারামিটারের মতোই সিনট্যাক্স ব্যবহার করি। আমরা কোথায় লাইফটাইম প্যারামিটারগুলো ঘোষণা করব এবং ব্যবহার করব তা নির্ভর করে তারা struct ফিল্ড বা মেথড প্যারামিটার এবং রিটার্ন ভ্যালুর সাথে সম্পর্কিত কিনা তার উপর।

struct ফিল্ডের জন্য লাইফটাইম নামগুলো সবসময় `impl` কিওয়ার্ডের পরে এবং তারপর struct-এর নামের পরে ব্যবহার করতে হয় কারণ সেই লাইফটাইমগুলো struct-এর টাইপের অংশ।

`impl` ব্লকের ভিতরের মেথড সিগনেচারে, রেফারেন্সগুলো struct-এর ফিল্ডের রেফারেন্সের লাইফটাইমের সাথে আবদ্ধ হতে পারে, অথবা তারা স্বাধীন হতে পারে। এছাড়াও, লাইফটাইম বিলুপ্তির নিয়মগুলো প্রায়শই এমনভাবে কাজ করে যে মেথড সিগনেচারে লাইফটাইম টীকাগুলোর প্রয়োজন হয় না। Listing 10-24-এ আমরা সংজ্ঞায়িত করা `ImportantExcerpt` নামের struct ব্যবহার করে কিছু উদাহরণ দেখা যাক।

প্রথমে আমরা `level` নামের একটি মেথড ব্যবহার করব যার একমাত্র প্যারামিটার হল `self`-এর রেফারেন্স এবং যার রিটার্ন ভ্যালু হল একটি `i32`, যা কোনো কিছুর রেফারেন্স নয়:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:1st}}
```

`impl`-এর পরে লাইফটাইম প্যারামিটার ঘোষণা এবং টাইপ নামের পরে এর ব্যবহার প্রয়োজন, তবে প্রথম বিলুপ্তি নিয়মের কারণে `self`-এর রেফারেন্সের লাইফটাইম টীকা করা আমাদের জন্য আবশ্যক নয়।

এখানে এমন একটি উদাহরণ দেওয়া হল যেখানে তৃতীয় লাইফটাইম বিলুপ্তি নিয়ম প্রযোজ্য:

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-10-lifetimes-on-methods/src/main.rs:3rd}}
```

এখানে দুটি ইনপুট লাইফটাইম রয়েছে, তাই রাস্ট প্রথম লাইফটাইম বিলুপ্তি নিয়ম প্রয়োগ করে এবং `&self` এবং `announcement` উভয়কেই তাদের নিজস্ব লাইফটাইম দেয়। তারপর, যেহেতু প্যারামিটারগুলোর মধ্যে একটি `&self`, তাই রিটার্ন টাইপ `&self`-এর লাইফটাইম পায় এবং সমস্ত লাইফটাইম হিসাব করা হয়েছে।

### স্ট্যাটিক লাইফটাইম

আমাদের আলোচনা করতে হবে এমন একটি বিশেষ লাইফটাইম হল `'static`, যা নির্দেশ করে যে প্রভাবিত রেফারেন্সটি প্রোগ্রামের পুরো সময়কালের জন্য বাঁচতে _পারে_। সমস্ত স্ট্রিং লিটারেলের `'static` লাইফটাইম রয়েছে, যা আমরা নিম্নরূপ টীকা করতে পারি:

```rust
let s: &'static str = "I have a static lifetime.";
```

এই স্ট্রিংটির টেক্সট সরাসরি প্রোগ্রামের বাইনারিতে স্টোর করা থাকে, যা সবসময় উপলব্ধ থাকে। অতএব, সমস্ত স্ট্রিং লিটারেলের লাইফটাইম হল `'static`।

আপনি এরর বার্তায় `'static` লাইফটাইম ব্যবহার করার পরামর্শ দেখতে পারেন। তবে কোনো রেফারেন্সের জন্য `'static` লাইফটাইম নির্দিষ্ট করার আগে, আপনার কাছে থাকা রেফারেন্সটি আসলে আপনার প্রোগ্রামের পুরো লাইফটাইম পর্যন্ত বেঁচে থাকে কিনা এবং আপনি তা চান কিনা তা নিয়ে ভাবুন। বেশিরভাগ সময়, `'static` লাইফটাইমের পরামর্শ দেওয়া একটি এরর বার্তা ড্যাংলিং রেফারেন্স তৈরি করার চেষ্টা করা বা উপলব্ধ লাইফটাইমগুলোর অমিল থেকে আসে। এই ধরনের ক্ষেত্রে, সমাধান হল সেই সমস্যাগুলো ঠিক করা, `'static` লাইফটাইম নির্দিষ্ট করা নয়।

## জেনেরিক টাইপ প্যারামিটার, ট্রেট বাউন্ড এবং লাইফটাইম একসাথে

আসুন সংক্ষেপে একটি ফাংশনে জেনেরিক টাইপ প্যারামিটার, ট্রেট বাউন্ড এবং লাইফটাইম সব একসাথে নির্দিষ্ট করার সিনট্যাক্সটি দেখি!

```rust
{{#rustdoc_include ../listings/ch10-generic-types-traits-and-lifetimes/no-listing-11-generics-traits-and-lifetimes/src/main.rs:here}}
```

এটি হল Listing 10-21-এর `longest` ফাংশন যা দুটি স্ট্রিং স্লাইসের মধ্যে দীর্ঘতরটি রিটার্ন করে। তবে এখন এটির `T` জেনেরিক টাইপের `ann` নামের একটি অতিরিক্ত প্যারামিটার রয়েছে, যা `where` ক্লজ দ্বারা নির্দিষ্ট করা `Display` ট্রেট প্রয়োগ করে এমন যেকোনো টাইপ দ্বারা পূরণ করা যেতে পারে। এই অতিরিক্ত প্যারামিটারটি `{}` ব্যবহার করে প্রিন্ট করা হবে, যে কারণে `Display` ট্রেট বাউন্ড প্রয়োজনীয়। যেহেতু লাইফটাইম একটি প্রকারের জেনেরিক, তাই লাইফটাইম প্যারামিটার `'a` এবং জেনেরিক টাইপ প্যারামিটার `T`-এর ঘোষণা ফাংশনের নামের পরে কোণের বন্ধনীর ভিতরের একই তালিকায় যায়।

## সারসংক্ষেপ

আমরা এই অধ্যায়ে অনেক কিছু আলোচনা করেছি! এখন যেহেতু আপনি জেনেরিক টাইপ প্যারামিটার, ট্রেট এবং ট্রেট বাউন্ড এবং জেনেরিক লাইফটাইম প্যারামিটার সম্পর্কে জেনেছেন, তাই আপনি পুনরাবৃত্তি ছাড়াই বিভিন্ন পরিস্থিতিতে কাজ করে এমন কোড লিখতে প্রস্তুত। জেনেরিক টাইপ প্যারামিটারগুলো আপনাকে বিভিন্ন টাইপে কোড প্রয়োগ করতে দেয়। ট্রেট এবং ট্রেট বাউন্ড নিশ্চিত করে যে টাইপগুলো জেনেরিক হলেও, কোডের প্রয়োজনীয় আচরণ তাদের থাকবে। আপনি শিখেছেন কিভাবে লাইফটাইম টীকা ব্যবহার করে নিশ্চিত করতে হয় যে এই নমনীয় কোডে কোনো ড্যাংলিং রেফারেন্স থাকবে না। এবং এই সমস্ত বিশ্লেষণ কম্পাইল করার সময় ঘটে, যা রানটাইম কর্মক্ষমতাকে প্রভাবিত করে না!

বিশ্বাস করুন বা না করুন, এই অধ্যায়ে আমরা যে বিষয়গুলো নিয়ে আলোচনা করেছি সেগুলোর উপর আরও অনেক কিছু শেখার আছে: Chapter 18 ট্রেট অবজেক্ট নিয়ে আলোচনা করে, যা ট্রেট ব্যবহারের আরেকটি উপায়। লাইফটাইম টীকা জড়িত আরও জটিল পরিস্থিতি রয়েছে যা আপনার শুধুমাত্র খুব উন্নত পরিস্থিতিতেই প্রয়োজন হবে; সেগুলোর জন্য, আপনার [রাস্ট রেফারেন্স][reference] পড়া উচিত। কিন্তু এর পরে, আপনি রাস্টে পরীক্ষা লিখতে শিখবেন যাতে আপনি নিশ্চিত করতে পারেন যে আপনার কোডটি যেভাবে কাজ করা উচিত সেভাবেই কাজ করছে।

[references-and-borrowing]: ch04-02-references-and-borrowing.html#references-and-borrowing
[string-slices-as-parameters]: ch04-03-slices.html#string-slices-as-parameters
[reference]: ../reference/index.html
