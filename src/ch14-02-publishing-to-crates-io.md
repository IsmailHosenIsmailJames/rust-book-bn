## Crates.io-এ একটি Crate প্রকাশ করা

আমরা [crates.io](https://crates.io/)<!-- ignore --> থেকে প্যাকেজগুলি আমাদের প্রকল্পের নির্ভরতা হিসাবে ব্যবহার করেছি, তবে আপনি নিজের প্যাকেজগুলি প্রকাশ করে অন্য লোকেদের সাথে আপনার কোডও শেয়ার করতে পারেন। [crates.io](https://crates.io/)<!-- ignore -->-এর crate রেজিস্ট্রি আপনার প্যাকেজগুলির সোর্স কোড বিতরণ করে, তাই এটি মূলত ওপেন সোর্স কোড হোস্ট করে।

Rust এবং Cargo-এর এমন কিছু বৈশিষ্ট্য রয়েছে যা আপনার প্রকাশিত প্যাকেজটি খুঁজে পাওয়া এবং ব্যবহার করা লোকেদের জন্য সহজ করে তোলে। আমরা এরপরে এই বৈশিষ্ট্যগুলির কয়েকটি নিয়ে আলোচনা করব এবং তারপরে একটি প্যাকেজ কীভাবে প্রকাশ করতে হয় তা ব্যাখ্যা করব।

### দরকারী ডকুমেন্টেশন কমেন্ট তৈরি করা

আপনার প্যাকেজগুলিকে সঠিকভাবে ডকুমেন্ট করলে অন্যান্য ব্যবহারকারীদের সেগুলি কখন এবং কীভাবে ব্যবহার করতে হয় তা জানতে সাহায্য করবে, তাই ডকুমেন্টেশন লিখতে সময় দেওয়া মূল্যবান। অধ্যায় 3-এ, আমরা দুটি স্ল্যাশ, `//` ব্যবহার করে Rust কোডকে কীভাবে কমেন্ট করতে হয় সে সম্পর্কে আলোচনা করেছি। Rust-এর ডকুমেন্টেশনের জন্য একটি বিশেষ ধরনের কমেন্টও রয়েছে, যা সুবিধাজনকভাবে _ডকুমেন্টেশন কমেন্ট_ নামে পরিচিত, যা HTML ডকুমেন্টেশন তৈরি করবে। HTML public API আইটেমগুলির জন্য ডকুমেন্টেশন কমেন্টের বিষয়বস্তু প্রদর্শন করে, যা প্রোগ্রামারদের জন্য আপনার crate-কে কীভাবে _ব্যবহার_ করতে হয় তা জানার জন্য তৈরি করা হয়েছে, আপনার crate-টি কীভাবে _বাস্তবায়িত_ করা হয়েছে তা জানার জন্য নয়।

ডকুমেন্টেশন কমেন্ট দুটি স্ল্যাশের পরিবর্তে তিনটি স্ল্যাশ, `///` ব্যবহার করে এবং টেক্সট ফরম্যাট করার জন্য Markdown নোটেশন সমর্থন করে। ডকুমেন্টেশন কমেন্টগুলি ঠিক সেই আইটেমের আগে রাখুন যেটিকে তারা ডকুমেন্ট করছে। Listing 14-1-এ `my_crate` নামের একটি crate-এ `add_one` ফাংশনের জন্য ডকুমেন্টেশন কমেন্ট দেখানো হয়েছে।

<Listing number="14-1" file-name="src/lib.rs" caption="একটি ফাংশনের জন্য ডকুমেন্টেশন কমেন্ট">

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-01/src/lib.rs}}
```

</Listing>

এখানে, আমরা `add_one` ফাংশন কী করে তার একটি বিবরণ দিই, `Examples` শিরোনাম দিয়ে একটি বিভাগ শুরু করি এবং তারপরে `add_one` ফাংশনটি কীভাবে ব্যবহার করতে হয় তা দেখিয়ে কোড প্রদান করি। আমরা `cargo doc` চালিয়ে এই ডকুমেন্টেশন কমেন্ট থেকে HTML ডকুমেন্টেশন তৈরি করতে পারি। এই কমান্ডটি Rust এর সাথে বিতরণ করা `rustdoc` টুল চালায় এবং জেনারেট করা HTML ডকুমেন্টেশন _target/doc_ ডিরেক্টরিতে রাখে।

সুবিধার জন্য, `cargo doc --open` চালালে আপনার বর্তমান crate-এর ডকুমেন্টেশনের জন্য HTML (পাশাপাশি আপনার crate-এর সমস্ত নির্ভরতার ডকুমেন্টেশন) তৈরি হবে এবং ওয়েব ব্রাউজারে ফলাফল খুলবে। `add_one` ফাংশনে নেভিগেট করুন এবং আপনি দেখতে পাবেন যে ডকুমেন্টেশন কমেন্টের টেক্সটটি কীভাবে রেন্ডার করা হয়েছে, যেমনটি চিত্র 14-1-এ দেখানো হয়েছে:

<img alt="`my_crate` এর `add_one` ফাংশনের জন্য রেন্ডার করা HTML ডকুমেন্টেশন" src="img/trpl14-01.png" class="center" />

<span class="caption">চিত্র 14-1: `add_one` ফাংশনের জন্য HTML ডকুমেন্টেশন</span>

#### সাধারণত ব্যবহৃত বিভাগ

আমরা Listing 14-1-এ `# Examples` Markdown শিরোনাম ব্যবহার করে HTML-এ "Examples" শিরোনামের একটি বিভাগ তৈরি করেছি। এখানে আরও কিছু বিভাগ রয়েছে যা crate লেখকরা সাধারণত তাদের ডকুমেন্টেশনে ব্যবহার করেন:

-   **Panics**: সেই পরিস্থিতিগুলি যেখানে ডকুমেন্ট করা ফাংশনটি panic করতে পারে। ফাংশনের কলার যারা চান না তাদের প্রোগ্রাম panic করুক, তাদের নিশ্চিত করা উচিত যে তারা এই পরিস্থিতিতে ফাংশন কল না করে।
-   **Errors**: যদি ফাংশনটি একটি `Result` ফেরত দেয়, তাহলে কী ধরনের error ঘটতে পারে এবং কী শর্তের কারণে সেই errorগুলি ফেরত আসতে পারে তা বর্ণনা করা কলারদের জন্য সহায়ক হতে পারে যাতে তারা বিভিন্ন ধরনের error-কে বিভিন্ন উপায়ে হ্যান্ডেল করার জন্য কোড লিখতে পারে।
-   **Safety**: যদি ফাংশনটি কল করা `unsafe` হয় (আমরা অধ্যায় 20 এ unsafety নিয়ে আলোচনা করব), তাহলে একটি বিভাগ থাকা উচিত যেখানে কেন ফাংশনটি unsafe এবং ফাংশনটি কলারদের রক্ষা করার জন্য প্রত্যাশিত invariant গুলি ব্যাখ্যা করা উচিত।

বেশিরভাগ ডকুমেন্টেশন কমেন্টের এই সমস্ত বিভাগের প্রয়োজন হয় না, তবে এটি আপনার কোডের সেই দিকগুলি মনে রাখার জন্য একটি ভাল চেকলিস্ট যা ব্যবহারকারীরা জানতে আগ্রহী হবেন।

#### ডকুমেন্টেশন কমেন্ট Test হিসাবে

আপনার ডকুমেন্টেশন কমেন্টে উদাহরণ কোড ব্লক যোগ করলে আপনার লাইব্রেরি কীভাবে ব্যবহার করতে হয় তা দেখাতে সাহায্য করতে পারে এবং এটি করার একটি অতিরিক্ত সুবিধা রয়েছে: `cargo test` চালালে আপনার ডকুমেন্টেশনের কোড উদাহরণ test হিসাবে চলবে! উদাহরণের চেয়ে ভালো ডকুমেন্টেশন আর কিছুই হতে পারে না। কিন্তু উদাহরণগুলি কাজ না করলে তার চেয়ে খারাপ আর কিছুই হতে পারে না কারণ ডকুমেন্টেশন লেখার পর থেকে কোড পরিবর্তন হয়েছে। যদি আমরা Listing 14-1 থেকে `add_one` ফাংশনের ডকুমেন্টেশন সহ `cargo test` চালাই, তাহলে আমরা test ফলাফলে এইরকম একটি বিভাগ দেখতে পাব:

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo test
copy just the doc-tests section below
-->

```text
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s
```

এখন যদি আমরা ফাংশন বা উদাহরণ পরিবর্তন করি যাতে উদাহরণের `assert_eq!` panic করে এবং আবার `cargo test` চালাই, তাহলে আমরা দেখতে পাব যে doc test ধরে ফেলেছে যে উদাহরণ এবং কোড একে অপরের সাথে সিঙ্ক করা নেই!

#### Contained আইটেম কমেন্ট করা

doc কমেন্টের স্টাইল `//!` কমেন্টের পরে থাকা আইটেমগুলিতে না যোগ করে সেই আইটেমে ডকুমেন্টেশন যোগ করে যেখানে কমেন্টগুলি রয়েছে। আমরা সাধারণত এই doc কমেন্টগুলি crate রুট ফাইলে (_src/lib.rs_ convention অনুসারে) অথবা একটি মডিউলের ভিতরে crate বা মডিউলকে সামগ্রিকভাবে ডকুমেন্ট করতে ব্যবহার করি।

উদাহরণস্বরূপ, `add_one` ফাংশন ধারণকারী `my_crate` crate-এর উদ্দেশ্য বর্ণনা করে এমন ডকুমেন্টেশন যোগ করতে, আমরা _src/lib.rs_ ফাইলের শুরুতে `//!`-দিয়ে শুরু হওয়া ডকুমেন্টেশন কমেন্ট যোগ করি, যেমন Listing 14-2-এ দেখানো হয়েছে:

<Listing number="14-2" file-name="src/lib.rs" caption="পুরো `my_crate` crate এর জন্য ডকুমেন্টেশন">

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-02/src/lib.rs:here}}
```

</Listing>

লক্ষ্য করুন `//!` দিয়ে শুরু হওয়া শেষ লাইনের পরে আর কোনো কোড নেই। কারণ আমরা `///`-এর পরিবর্তে `//!` দিয়ে কমেন্ট শুরু করেছি, তাই আমরা সেই আইটেমটিকে ডকুমেন্ট করছি যেখানে এই কমেন্টটি রয়েছে, এই কমেন্টের পরে থাকা কোনো আইটেমকে নয়। এই ক্ষেত্রে, সেই আইটেমটি হল _src/lib.rs_ ফাইল, যা crate রুট। এই কমেন্টগুলি পুরো crate বর্ণনা করে।

যখন আমরা `cargo doc --open` চালাই, তখন এই কমেন্টগুলি crate-এর public আইটেমগুলির তালিকার উপরে `my_crate` এর ডকুমেন্টেশনের প্রথম পৃষ্ঠায় প্রদর্শিত হবে, যেমনটি চিত্র 14-2-এ দেখানো হয়েছে:

<img alt="পুরো crate-এর জন্য একটি কমেন্ট সহ রেন্ডার করা HTML ডকুমেন্টেশন" src="img/trpl14-02.png" class="center" />

<span class="caption">চিত্র 14-2: পুরো crate-এর বর্ণনা সহ কমেন্ট সহ `my_crate`-এর জন্য রেন্ডার করা ডকুমেন্টেশন</span>

আইটেমগুলির ভিতরের ডকুমেন্টেশন কমেন্ট বিশেষ করে crate এবং মডিউলগুলি বর্ণনা করার জন্য উপযোগী। আপনার ব্যবহারকারীদের crate-এর গঠন বুঝতে সাহায্য করার জন্য কন্টেইনারের সামগ্রিক উদ্দেশ্য ব্যাখ্যা করতে সেগুলি ব্যবহার করুন।

### `pub use` দিয়ে একটি সুবিধাজনক Public API এক্সপোর্ট করা

একটি crate প্রকাশ করার সময় আপনার public API এর গঠন একটি প্রধান বিবেচ্য বিষয়। যারা আপনার crate ব্যবহার করেন তারা আপনার চেয়ে কাঠামোর সাথে কম পরিচিত এবং আপনার crate-এর একটি বড় মডিউল hierarchy থাকলে তারা যে অংশগুলি ব্যবহার করতে চান সেগুলি খুঁজে পেতে তাদের অসুবিধা হতে পারে।

অধ্যায় 7-এ, আমরা `pub` কীওয়ার্ড ব্যবহার করে কীভাবে আইটেমগুলিকে public করতে হয় এবং `use` কীওয়ার্ড দিয়ে কীভাবে আইটেমগুলিকে একটি scope-এ আনতে হয় তা নিয়ে আলোচনা করেছি। যাইহোক, একটি crate develop করার সময় আপনার কাছে যে কাঠামোটি বোধগম্য হয় তা আপনার ব্যবহারকারীদের জন্য খুব সুবিধাজনক নাও হতে পারে। আপনি একাধিক স্তরযুক্ত একটি hierarchy-তে আপনার struct গুলিকে সাজাতে চাইতে পারেন, কিন্তু তারপর যে লোকেরা hierarchy-এর গভীরে সংজ্ঞায়িত একটি টাইপ ব্যবহার করতে চান তাদের সেই টাইপের অস্তিত্ব খুঁজে বের করতে সমস্যা হতে পারে। তারা `use` `my_crate::some_module::another_module::UsefulType;` এর পরিবর্তে `use` `my_crate::UsefulType;` লিখতে বিরক্ত হতে পারে।

ভাল খবর হল যে কাঠামোটি যদি অন্য লাইব্রেরি থেকে ব্যবহার করার জন্য সুবিধাজনক না হয়, তবে আপনাকে আপনার অভ্যন্তরীণ কাঠামো পুনর্বিন্যাস করতে হবে না: পরিবর্তে, আপনি `pub use` ব্যবহার করে আপনার ব্যক্তিগত কাঠামোর থেকে আলাদা একটি public কাঠামো তৈরি করতে আইটেমগুলি পুনরায় এক্সপোর্ট করতে পারেন। পুনরায় এক্সপোর্ট করা একটি public আইটেমকে এক জায়গা থেকে নিয়ে অন্য জায়গায় public করে, যেন এটি অন্য জায়গায় সংজ্ঞায়িত করা হয়েছে।

উদাহরণস্বরূপ, ধরুন আমরা শৈল্পিক ধারণাগুলির মডেলিংয়ের জন্য `art` নামের একটি লাইব্রেরি তৈরি করেছি। এই লাইব্রেরির মধ্যে দুটি মডিউল রয়েছে: `kinds` মডিউলটিতে `PrimaryColor` এবং `SecondaryColor` নামের দুটি enum এবং `utils` মডিউলে `mix` নামের একটি ফাংশন রয়েছে, যেমন Listing 14-3 এ দেখানো হয়েছে:

<Listing number="14-3" file-name="src/lib.rs" caption="`kinds` এবং `utils` মডিউলে সাজানো আইটেম সহ একটি `art` লাইব্রেরি">

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-03/src/lib.rs:here}}
```

</Listing>

চিত্র 14-3 দেখায় `cargo doc` দ্বারা তৈরি এই crate-এর ডকুমেন্টেশনের প্রথম পৃষ্ঠাটি দেখতে কেমন হবে:

<img alt="`art` crate-এর জন্য রেন্ডার করা ডকুমেন্টেশন যা `kinds` এবং `utils` মডিউলগুলি তালিকাভুক্ত করে" src="img/trpl14-03.png" class="center" />

<span class="caption">চিত্র 14-3: `art`-এর ডকুমেন্টেশনের প্রথম পৃষ্ঠা যা `kinds` এবং `utils` মডিউলগুলি তালিকাভুক্ত করে</span>

লক্ষ্য করুন যে `PrimaryColor` এবং `SecondaryColor` টাইপগুলি প্রথম পৃষ্ঠায় তালিকাভুক্ত করা হয়নি, বা `mix` ফাংশনও নয়। সেগুলি দেখতে হলে আমাদের `kinds` এবং `utils` এ ক্লিক করতে হবে।

এই লাইব্রেরির উপর নির্ভরশীল অন্য একটি crate-এর `art` থেকে আইটেমগুলিকে scope-এ আনতে `use` স্টেটমেন্টের প্রয়োজন হবে, যা বর্তমানে সংজ্ঞায়িত মডিউল কাঠামো নির্দিষ্ট করে। Listing 14-4 `art` crate থেকে `PrimaryColor` এবং `mix` আইটেম ব্যবহার করে এমন একটি crate-এর উদাহরণ দেখায়:

<Listing number="14-4" file-name="src/main.rs" caption="একটি crate `art` crate-এর অভ্যন্তরীণ কাঠামো ব্যবহার করে এর আইটেম ব্যবহার করে">

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-04/src/main.rs}}
```

</Listing>

Listing 14-4-এর কোডের লেখক, যিনি `art` crate ব্যবহার করেন, তাকে খুঁজে বের করতে হয়েছে যে `PrimaryColor` `kinds` মডিউলে এবং `mix` `utils` মডিউলে আছে। `art` crate-এর মডিউল কাঠামো `art` crate-এ কাজ করা ডেভেলপারদের জন্য এর ব্যবহারকারীদের চেয়ে বেশি প্রাসঙ্গিক। অভ্যন্তরীণ কাঠামো `art` crate কীভাবে ব্যবহার করতে হয় তা বোঝার চেষ্টা করা কারো জন্য কোনো দরকারী তথ্য ধারণ করে না, বরং বিভ্রান্তির সৃষ্টি করে কারণ যারা এটি ব্যবহার করেন তাদের কোথায় খুঁজতে হবে তা খুঁজে বের করতে হয় এবং `use` স্টেটমেন্টে মডিউলের নাম উল্লেখ করতে হয়।

public API থেকে অভ্যন্তরীণ কাঠামো সরাতে, আমরা Listing 14-3-এ `art` crate কোড পরিবর্তন করে শীর্ষ স্তরে আইটেমগুলি পুনরায় এক্সপোর্ট করতে `pub use` স্টেটমেন্ট যোগ করতে পারি, যেমন Listing 14-5-এ দেখানো হয়েছে:

<Listing number="14-5" file-name="src/lib.rs" caption="আইটেমগুলি পুনরায় এক্সপোর্ট করতে `pub use` স্টেটমেন্ট যোগ করা">

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-05/src/lib.rs:here}}
```

</Listing>

`cargo doc` এই crate-এর জন্য যে API ডকুমেন্টেশন তৈরি করে তা এখন প্রথম পৃষ্ঠায় পুনরায় এক্সপোর্টগুলিকে তালিকাভুক্ত করবে এবং লিঙ্ক করবে, যেমনটি চিত্র 14-4-এ দেখানো হয়েছে, `PrimaryColor` এবং `SecondaryColor` টাইপ এবং `mix` ফাংশন খুঁজে পাওয়া সহজ করে তুলেছে।

<img alt="প্রথম পৃষ্ঠায় পুনরায় এক্সপোর্ট সহ `art` crate-এর জন্য রেন্ডার করা ডকুমেন্টেশন" src="img/trpl14-04.png" class="center" />

<span class="caption">চিত্র 14-4: `art`-এর ডকুমেন্টেশনের প্রথম পৃষ্ঠা যা পুনরায় এক্সপোর্টগুলি তালিকাভুক্ত করে</span>

`art` crate-এর ব্যবহারকারীরা এখনও Listing 14-3 থেকে অভ্যন্তরীণ কাঠামো দেখতে এবং ব্যবহার করতে পারে যেমনটি Listing 14-4-এ দেখানো হয়েছে, অথবা তারা Listing 14-5-এ আরও সুবিধাজনক কাঠামো ব্যবহার করতে পারে, যেমন Listing 14-6 এ দেখানো হয়েছে:

<Listing number="14-6" file-name="src/main.rs" caption="`art` crate থেকে পুনরায় এক্সপোর্ট করা আইটেমগুলি ব্যবহার করে একটি প্রোগ্রাম">

```rust,ignore
{{#rustdoc_include ../listings/ch14-more-about-cargo/listing-14-06/src/main.rs:here}}
```

</Listing>

যেখানে অনেক নেস্টেড মডিউল রয়েছে, সেখানে `pub use` দিয়ে শীর্ষ স্তরে টাইপগুলি পুনরায় এক্সপোর্ট করলে সেই crate ব্যবহার করা লোকেদের অভিজ্ঞতায় একটি উল্লেখযোগ্য পার্থক্য আসতে পারে। `pub use`-এর আরেকটি সাধারণ ব্যবহার হল বর্তমান crate-এ একটি নির্ভরতার সংজ্ঞা পুনরায় এক্সপোর্ট করা যাতে সেই crate-এর সংজ্ঞাগুলি আপনার crate-এর public API-এর অংশ হয়ে যায়।

একটি দরকারী public API কাঠামো তৈরি করা বিজ্ঞানের চেয়ে বেশি একটি শিল্প, এবং আপনি আপনার ব্যবহারকারীদের জন্য সবচেয়ে ভাল কাজ করে এমন API খুঁজে পেতে পুনরাবৃত্তি করতে পারেন। `pub use` নির্বাচন করা আপনাকে আপনার crate অভ্যন্তরীণভাবে কীভাবে গঠন করবেন তার নমনীয়তা দেয় এবং সেই অভ্যন্তরীণ কাঠামোকে আপনি আপনার ব্যবহারকারীদের কাছে যা উপস্থাপন করেন তার থেকে আলাদা করে। আপনি যে crate-গুলি ইনস্টল করেছেন সেগুলির কিছু কোড দেখুন যে তাদের অভ্যন্তরীণ কাঠামো তাদের public API থেকে আলাদা কিনা।

### Crates.io অ্যাকাউন্ট সেট আপ করা

আপনি কোনো crate প্রকাশ করার আগে, আপনাকে [crates.io](https://crates.io/)<!-- ignore -->-এ একটি অ্যাকাউন্ট তৈরি করতে হবে এবং একটি API টোকেন পেতে হবে। এটি করার জন্য, [crates.io](https://crates.io/)<!-- ignore -->-এর হোম পেজে যান এবং একটি GitHub অ্যাকাউন্টের মাধ্যমে লগ ইন করুন। (বর্তমানে GitHub অ্যাকাউন্ট একটি প্রয়োজনীয়তা, তবে সাইটটি ভবিষ্যতে অ্যাকাউন্ট তৈরি করার অন্যান্য উপায় সমর্থন করতে পারে।) একবার আপনি লগ ইন করার পরে, [https://crates.io/me/](https://crates.io/me/)<!-- ignore -->-এ আপনার অ্যাকাউন্ট সেটিংসে যান এবং আপনার API কী পুনরুদ্ধার করুন। তারপরে `cargo login` কমান্ডটি চালান এবং প্রম্পট করার সময় আপনার API কী পেস্ট করুন, এইরকম:

```console
$ cargo login
abcdefghijklmnopqrstuvwxyz012345
```

এই কমান্ডটি Cargo-কে আপনার API টোকেন সম্পর্কে জানাবে এবং এটিকে লোকালি _~/.cargo/credentials_-এ সংরক্ষণ করবে। মনে রাখবেন এই টোকেনটি একটি _গোপন_: এটি অন্য কারো সাথে শেয়ার করবেন না। যদি আপনি কোনো কারণে কারো সাথে শেয়ার করেন, তাহলে আপনার এটি বাতিল করা উচিত এবং [crates.io](https://crates.io/)<!-- ignore -->-এ একটি নতুন টোকেন তৈরি করা উচিত।

### একটি নতুন Crate এ মেটাডাটা যোগ করা

ধরুন আপনার কাছে একটি crate আছে যা আপনি প্রকাশ করতে চান। প্রকাশ করার আগে, আপনাকে crate-এর _Cargo.toml_ ফাইলের `[package]` বিভাগে কিছু মেটাডাটা যোগ করতে হবে।

আপনার crate-এর একটি অনন্য নাম প্রয়োজন হবে। আপনি যখন স্থানীয়ভাবে একটি crate-এ কাজ করছেন, তখন আপনি crate-এর নাম যা খুশি রাখতে পারেন। যাইহোক, [crates.io](https://crates.io/)<!-- ignore -->-এর crate-এর নামগুলি first-come, first-served ভিত্তিতে বরাদ্দ করা হয়। একবার একটি crate-এর নাম নেওয়া হয়ে গেলে, অন্য কেউ সেই নামে একটি crate প্রকাশ করতে পারবে না। একটি crate প্রকাশ করার চেষ্টা করার আগে, আপনি যে নামটি ব্যবহার করতে চান সেটি অনুসন্ধান করুন। যদি নামটি ব্যবহার করা হয়ে থাকে, তাহলে আপনাকে অন্য একটি নাম খুঁজে বের করতে হবে এবং প্রকাশ করার জন্য নতুন নামটি ব্যবহার করতে `[package]` বিভাগের অধীনে _Cargo.toml_ ফাইলে `name` ফিল্ডটি সম্পাদনা করতে হবে, যেমন:

<span class="filename">Filename: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
```

এমনকি যদি আপনি একটি অনন্য নামও বেছে নিয়ে থাকেন, এই সময়ে crate প্রকাশ করার জন্য যখন আপনি `cargo publish` চালাবেন, তখন আপনি একটি warning এবং তারপরে একটি error পাবেন:

<!-- manual-regeneration
cd listings/ch14-more-about-cargo/listing-14-01/
cargo publish
copy just the relevant lines below
-->

```console
$ cargo publish
    Updating crates.io index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
--snip--
error: failed to publish to registry at https://crates.io

Caused by:
  the remote server responded with an error (status 400 Bad Request): missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for more information on configuring these field
```

এই errorগুলি আসে কারণ আপনার কিছু গুরুত্বপূর্ণ তথ্য missing: একটি বর্ণনা এবং লাইসেন্স প্রয়োজন যাতে লোকেরা জানতে পারে আপনার crate কী করে এবং কোন শর্তে তারা এটি ব্যবহার করতে পারবে। _Cargo.toml_-এ, একটি বর্ণনা যোগ করুন যা শুধুমাত্র এক বা দুটি বাক্য, কারণ এটি আপনার crate-এর সাথে অনুসন্ধানের ফলাফলে প্রদর্শিত হবে। `license` ফিল্ডের জন্য, আপনাকে একটি _লাইসেন্স আইডেন্টিফায়ার মান_ দিতে হবে। [Linux Foundation’s Software Package Data Exchange (SPDX)][spdx] এই মানের জন্য আপনি যে আইডেন্টিফায়ারগুলি ব্যবহার করতে পারেন তার তালিকা করে। উদাহরণস্বরূপ, আপনি যদি MIT লাইসেন্স ব্যবহার করে আপনার crate-এর লাইসেন্স দিয়েছেন তা নির্দিষ্ট করতে, `MIT` আইডেন্টিফায়ার যোগ করুন:

<span class="filename">Filename: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
license = "MIT"
```

আপনি যদি এমন একটি লাইসেন্স ব্যবহার করতে চান যা SPDX-এ প্রদর্শিত হয় না, তাহলে আপনাকে সেই লাইসেন্সের টেক্সট একটি ফাইলে রাখতে হবে, ফাইলটি আপনার প্রজেক্টে অন্তর্ভুক্ত করতে হবে এবং তারপরে `license` কী ব্যবহার করার পরিবর্তে সেই ফাইলের নাম উল্লেখ করতে `license-file` ব্যবহার করতে হবে।

আপনার প্রজেক্টের জন্য কোন লাইসেন্স উপযুক্ত তা নিয়ে আলোচনা এই বইয়ের সুযোগের বাইরে। Rust সম্প্রদায়ের অনেক লোক তাদের প্রজেক্টগুলিকে Rust-এর মতোই `MIT OR Apache-2.0` এর একটি দ্বৈত লাইসেন্স ব্যবহার করে লাইসেন্স দেয়। এই অনুশীলনটি প্রমাণ করে যে আপনি আপনার প্রজেক্টের জন্য একাধিক লাইসেন্স রাখার জন্য `OR` দ্বারা পৃথক করা একাধিক লাইসেন্স আইডেন্টিফায়ারও নির্দিষ্ট করতে পারেন।

একটি অনন্য নাম, সংস্করণ, আপনার বর্ণনা এবং একটি লাইসেন্স যোগ করার পরে, প্রকাশ করার জন্য প্রস্তুত একটি প্রজেক্টের _Cargo.toml_ ফাইলটি দেখতে এইরকম হতে পারে:

<span class="filename">Filename: Cargo.toml</span>

```toml
[package]
name = "guessing_game"
version = "0.1.0"
edition = "2021"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```

[Cargo-এর ডকুমেন্টেশন](https://doc.rust-lang.org/cargo/) অন্যান্য মেটাডাটা বর্ণনা করে যা আপনি নির্দিষ্ট করতে পারেন যাতে অন্যরা আপনার crate আরও সহজে আবিষ্কার করতে এবং ব্যবহার করতে পারে।

### Crates.io এ প্রকাশ করা

এখন যেহেতু আপনি একটি অ্যাকাউন্ট তৈরি করেছেন, আপনার API টোকেন সংরক্ষণ করেছেন, আপনার crate-এর জন্য একটি নাম বেছে নিয়েছেন এবং প্রয়োজনীয় মেটাডাটা নির্দিষ্ট করেছেন, আপনি প্রকাশ করার জন্য প্রস্তুত! একটি crate প্রকাশ করা অন্য লোকেদের ব্যবহারের জন্য [crates.io](https://crates.io/)<!-- ignore -->-এ একটি নির্দিষ্ট সংস্করণ আপলোড করে।

সতর্ক থাকুন, কারণ একটি প্রকাশ _স্থায়ী_। সংস্করণটি কখনও ওভাররাইট করা যাবে না এবং কোডটি মুছে ফেলা যাবে না। [crates.io](https://crates.io/)<!-- ignore -->-এর একটি প্রধান লক্ষ্য হল কোডের একটি স্থায়ী সংরক্ষণাগার হিসাবে কাজ করা যাতে [crates.io](https://crates.io/)<!-- ignore --> থেকে crate-এর উপর নির্ভরশীল সমস্ত প্রজেক্টের বিল্ড কাজ করা চালিয়ে যেতে পারে। সংস্করণ মুছে ফেলার অনুমতি দিলে সেই লক্ষ্য পূরণ করা অসম্ভব হয়ে পড়বে। যাইহোক, আপনি প্রকাশ করতে পারেন এমন crate সংস্করণের সংখ্যার কোনো সীমা নেই।

আবার `cargo publish` কমান্ডটি চালান। এখন এটি সফল হওয়া উচিত:

<!-- manual-regeneration
go to some valid crate, publish a new version
cargo publish
copy just the relevant lines below
-->

```console
$ cargo publish
    Updating crates.io index
   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
   Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.19s
   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
```

অভিনন্দন! আপনি এখন Rust সম্প্রদায়ের সাথে আপনার কোড শেয়ার করেছেন এবং যে কেউ সহজেই আপনার crate তাদের প্রজেক্টের নির্ভরতা হিসাবে যোগ করতে পারে।

### একটি বিদ্যমান Crate এর নতুন সংস্করণ প্রকাশ করা

আপনি যখন আপনার crate-এ পরিবর্তন করেছেন এবং একটি নতুন সংস্করণ প্রকাশ করার জন্য প্রস্তুত, তখন আপনি আপনার _Cargo.toml_ ফাইলে নির্দিষ্ট করা `version` মান পরিবর্তন করুন এবং পুনরায় প্রকাশ করুন। আপনি যে ধরনের পরিবর্তন করেছেন তার উপর ভিত্তি করে উপযুক্ত পরবর্তী সংস্করণ নম্বর কী হবে তা সিদ্ধান্ত নিতে [Semantic Versioning নিয়মাবলী][semver] ব্যবহার করুন। তারপর নতুন সংস্করণ আপলোড করতে `cargo publish` চালান।

<!-- Old link, do not remove -->

<a id="removing-versions-from-cratesio-with-cargo-yank"></a>

### `cargo yank` দিয়ে Crates.io থেকে সংস্করণ বাতিল করা

যদিও আপনি একটি crate-এর আগের সংস্করণগুলি মুছে ফেলতে পারবেন না, তবে আপনি ভবিষ্যতের যেকোনো প্রজেক্টকে নতুন নির্ভরতা হিসাবে যোগ করা থেকে আটকাতে পারেন। যখন একটি crate সংস্করণ কোনো কারণে ভেঙে যায় তখন এটি কাজে লাগে। এমন পরিস্থিতিতে, Cargo একটি crate সংস্করণ _yanking_ সমর্থন করে।

একটি সংস্করণ yank করলে নতুন প্রজেক্টগুলি সেই সংস্করণের উপর নির্ভর করা থেকে বিরত থাকে, তবে সেই সংস্করণের উপর নির্ভরশীল সমস্ত বিদ্যমান প্রজেক্ট চলতে থাকে। মূলত, একটি yank মানে হল একটি _Cargo.lock_ সহ সমস্ত প্রজেক্ট ভেঙে যাবে না এবং ভবিষ্যতে জেনারেট করা কোনো _Cargo.lock_ ফাইল yank করা সংস্করণ ব্যবহার করবে না।

একটি crate-এর সংস্করণ yank করতে, আপনি আগে প্রকাশ করেছেন এমন crate-এর ডিরেক্টরিতে `cargo yank` চালান এবং আপনি কোন সংস্করণ yank করতে চান তা নির্দিষ্ট করুন। উদাহরণস্বরূপ, যদি আমরা `guessing_game` নামের একটি crate সংস্করণ 1.0.1 প্রকাশ করে থাকি এবং আমরা এটিকে yank করতে চাই, তাহলে `guessing_game`-এর প্রজেক্ট ডিরেক্টরিতে আমরা চালাব:

<!-- manual-regeneration:
cargo yank carol-test --version 2.1.0
cargo yank carol-test --version 2.1.0 --undo
-->

```console
$ cargo yank --vers 1.0.1
    Updating crates.io index
        Yank guessing_game@1.0.1
```

কমান্ডটিতে `--undo` যোগ করে, আপনি একটি yank কে undo করতে পারেন এবং প্রজেক্টগুলিকে আবার একটি সংস্করণের উপর নির্ভর করতে দিতে পারেন:

```console
$ cargo yank --vers 1.0.1 --undo
    Updating crates.io index
      Unyank guessing_game@1.0.1
```

একটি yank কোনো কোড _মুছে দেয় না_। উদাহরণস্বরূপ, এটি ভুল করে আপলোড করা কোনো secret মুছে ফেলতে পারে না। যদি এমনটি ঘটে, তাহলে আপনাকে সেই secret গুলি অবিলম্বে রিসেট করতে হবে।

[spdx]: http://spdx.org/licenses/
[semver]: http://semver.org/
