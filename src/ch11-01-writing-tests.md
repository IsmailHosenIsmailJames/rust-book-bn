## কিভাবে পরীক্ষা লিখতে হয়

পরীক্ষা হল রাস্ট ফাংশন যা যাচাই করে যে অ-পরীক্ষা কোডটি প্রত্যাশিত পদ্ধতিতে কাজ করছে। পরীক্ষার ফাংশনের বডিগুলো সাধারণত এই তিনটি কাজ করে:

- প্রয়োজনীয় ডেটা বা অবস্থা সেট আপ করুন।
- আপনি যে কোডটি পরীক্ষা করতে চান সেটি চালান।
- দাবি করুন যে ফলাফলগুলো আপনার প্রত্যাশা অনুযায়ী।

আসুন দেখি রাস্ট বিশেষভাবে পরীক্ষা লেখার জন্য কী কী বৈশিষ্ট্য প্রদান করে, যার মধ্যে `test` অ্যাট্রিবিউট, কয়েকটি ম্যাক্রো এবং `should_panic` অ্যাট্রিবিউট অন্তর্ভুক্ত রয়েছে।

### একটি পরীক্ষার ফাংশনের গঠন

সবচেয়ে সহজভাবে, রাস্টে একটি পরীক্ষা হল একটি ফাংশন যা `test` অ্যাট্রিবিউট দিয়ে টীকা করা হয়। অ্যাট্রিবিউট হল রাস্ট কোডের অংশ সম্পর্কে মেটাডেটা; একটি উদাহরণ হল `derive` অ্যাট্রিবিউট যা আমরা Chapter 5-এ struct-এর সাথে ব্যবহার করেছি। একটি ফাংশনকে একটি পরীক্ষা ফাংশনে পরিবর্তন করতে, `fn`-এর আগের লাইনে `#[test]` যোগ করুন। আপনি যখন `cargo test` কমান্ড দিয়ে আপনার পরীক্ষাগুলো চালান, তখন রাস্ট একটি পরীক্ষা রানার বাইনারি তৈরি করে যা টীকা করা ফাংশনগুলো চালায় এবং প্রতিটি পরীক্ষা ফাংশন পাস হয়েছে নাকি ব্যর্থ হয়েছে তা রিপোর্ট করে।

যখনই আমরা Cargo-এর সাথে একটি নতুন লাইব্রেরি প্রজেক্ট তৈরি করি, তখন স্বয়ংক্রিয়ভাবে আমাদের জন্য একটি পরীক্ষা মডিউল তৈরি হয় যার ভিতরে একটি পরীক্ষা ফাংশন থাকে। এই মডিউলটি আপনাকে আপনার পরীক্ষা লেখার জন্য একটি টেমপ্লেট দেয় তাই প্রতিবার নতুন প্রজেক্ট শুরু করার সময় আপনাকে সঠিক গঠন এবং সিনট্যাক্স খুঁজে বের করতে হবে না। আপনি যত খুশি অতিরিক্ত পরীক্ষা ফাংশন এবং যত খুশি পরীক্ষা মডিউল যোগ করতে পারেন!

আমরা কোনো কোড পরীক্ষা করার আগে টেমপ্লেট পরীক্ষাটি নিয়ে পরীক্ষা করে দেখব কিভাবে পরীক্ষাগুলো কাজ করে, এবং এরপর আমরা কিছু বাস্তব পরীক্ষা লিখব যা আমরা লিখেছি এমন কিছু কোড কল করে এবং দাবি করে যে এর আচরণ সঠিক।

আসুন `adder` নামের একটি নতুন লাইব্রেরি প্রজেক্ট তৈরি করি যা দুটি সংখ্যা যোগ করবে:

```console
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```

আপনার `adder` লাইব্রেরির _src/lib.rs_ ফাইলের কন্টেন্টগুলো Listing 11-1 এর মতো হওয়া উচিত।

<Listing number="11-1" file-name="src/lib.rs" caption="`cargo new` দ্বারা স্বয়ংক্রিয়ভাবে তৈরি করা কোড">

<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

</Listing>

ফাইলটি একটি উদাহরণ `add` ফাংশন দিয়ে শুরু হয়, যাতে আমাদের পরীক্ষা করার মতো কিছু থাকে।

আপাতত, আসুন শুধুমাত্র `it_works` ফাংশনের উপর মনোযোগ দিই। `#[test]` টীকাটি লক্ষ্য করুন: এই অ্যাট্রিবিউটটি নির্দেশ করে যে এটি একটি পরীক্ষা ফাংশন, তাই পরীক্ষা রানার জানে যে এই ফাংশনটিকে একটি পরীক্ষা হিসাবে বিবেচনা করতে হবে। সাধারণ পরিস্থিতি সেট আপ করতে বা সাধারণ ক্রিয়াকলাপগুলো সম্পাদন করতে আমাদের `tests` মডিউলে অ-পরীক্ষা ফাংশনও থাকতে পারে, তাই কোন ফাংশনগুলো পরীক্ষা তা আমাদের সবসময় উল্লেখ করতে হবে।

উদাহরণ ফাংশন বডিটি `assert_eq!` ম্যাক্রো ব্যবহার করে দাবি করে যে `result`, যাতে 2 এবং 2 এর সাথে `add` কল করার ফলাফল রয়েছে, তা 4 এর সমান। এই দাবিটি একটি সাধারণ পরীক্ষার বিন্যাসের উদাহরণ হিসাবে কাজ করে। আসুন এটি চালিয়ে দেখি যে এই পরীক্ষাটি পাস হয় কিনা।

`cargo test` কমান্ড আমাদের প্রজেক্টের সমস্ত পরীক্ষা চালায়, যেমন Listing 11-2-এ দেখানো হয়েছে।

<Listing number="11-2" caption="স্বয়ংক্রিয়ভাবে তৈরি করা পরীক্ষা চালানোর আউটপুট">

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-01/output.txt}}
```

</Listing>

Cargo কম্পাইল করেছে এবং পরীক্ষাটি চালিয়েছে। আমরা `running 1 test` লাইনটি দেখতে পাচ্ছি। পরবর্তী লাইনে জেনারেট করা পরীক্ষা ফাংশনের নাম দেখায়, যা `tests::it_works` নামে পরিচিত এবং সেই পরীক্ষা চালানোর ফলাফল `ok`। সামগ্রিক সারসংক্ষেপ `test
result: ok.` মানে হল যে সমস্ত পরীক্ষা পাস হয়েছে, এবং `1
passed; 0 failed` অংশটি পাস বা ব্যর্থ হওয়া পরীক্ষার সংখ্যা যোগ করে।

একটি পরীক্ষাকে উপেক্ষা করা হিসাবে চিহ্নিত করা সম্ভব যাতে এটি একটি নির্দিষ্ট উদাহরণে না চলে; আমরা এই অধ্যায়ের পরে [“বিশেষভাবে অনুরোধ না করা পর্যন্ত কিছু পরীক্ষা উপেক্ষা করা”][ignoring]<!-- ignore --> বিভাগে এটি নিয়ে আলোচনা করব। যেহেতু আমরা এখানে তা করিনি, তাই সারসংক্ষেপ `0 ignored` দেখায়।

`0 measured` পরিসংখ্যানটি বেঞ্চমার্ক পরীক্ষাগুলোর জন্য যা কর্মক্ষমতা পরিমাপ করে। বেঞ্চমার্ক পরীক্ষাগুলো, এই লেখার সময় পর্যন্ত, শুধুমাত্র রাতের বেলা রাস্টে উপলব্ধ। আরও জানতে [বেঞ্চমার্ক পরীক্ষা সম্পর্কে ডকুমেন্টেশন][bench] দেখুন।

আমরা শুধুমাত্র সেই পরীক্ষাগুলো চালানোর জন্য `cargo test` কমান্ডে একটি আর্গুমেন্ট পাস করতে পারি যেগুলোর নাম একটি স্ট্রিংয়ের সাথে মেলে; এটিকে _ফিল্টারিং_ বলা হয় এবং আমরা এটি [“নাম দিয়ে পরীক্ষার একটি উপসেট চালানো”][subset]<!-- ignore --> বিভাগে আলোচনা করব। এখানে আমরা যে পরীক্ষাগুলো চালানো হচ্ছে সেগুলোকে ফিল্টার করিনি, তাই সারসংক্ষেপের শেষে `0
filtered out` দেখায়।

`Doc-tests adder` থেকে শুরু হওয়া পরীক্ষার আউটপুটের পরবর্তী অংশটি কোনো ডকুমেন্টেশন পরীক্ষার ফলাফলের জন্য। আমাদের এখনও কোনো ডকুমেন্টেশন পরীক্ষা নেই, তবে রাস্ট আমাদের API ডকুমেন্টেশনে প্রদর্শিত যেকোনো কোড উদাহরণ কম্পাইল করতে পারে। এই বৈশিষ্ট্যটি আপনার ডক্স এবং আপনার কোডকে সিঙ্ক রাখতে সাহায্য করে! আমরা Chapter 14-এর [“টেস্ট হিসাবে ডকুমেন্টেশন মন্তব্য”][doc-comments]<!-- ignore --> বিভাগে ডকুমেন্টেশন পরীক্ষা লেখার পদ্ধতি নিয়ে আলোচনা করব। আপাতত, আমরা `Doc-tests` আউটপুটটি উপেক্ষা করব।

আসুন আমাদের নিজস্ব প্রয়োজন অনুযায়ী পরীক্ষাটি কাস্টমাইজ করা শুরু করি। প্রথমে, `it_works` ফাংশনের নাম পরিবর্তন করে `exploration` এর মতো অন্য একটি নাম দিন, যেমন:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/src/lib.rs}}
```

তারপর আবার `cargo test` চালান। আউটপুট এখন `it_works`-এর পরিবর্তে `exploration` দেখাচ্ছে:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/output.txt}}
```

এখন আমরা আরেকটি পরীক্ষা যোগ করব, তবে এবার আমরা এমন একটি পরীক্ষা করব যা ব্যর্থ হবে! যখন পরীক্ষার ফাংশনের ভিতরে কিছু প্যানিক করে তখন পরীক্ষাগুলো ব্যর্থ হয়। প্রতিটি পরীক্ষা একটি নতুন থ্রেডে চালানো হয় এবং যখন মূল থ্রেড দেখে যে একটি পরীক্ষার থ্রেড মারা গেছে, তখন পরীক্ষাটিকে ব্যর্থ হিসাবে চিহ্নিত করা হয়। Chapter 9-এ, আমরা আলোচনা করেছি কিভাবে প্যানিক করার সবচেয়ে সহজ উপায় হল `panic!` ম্যাক্রো কল করা। `another` নামের একটি ফাংশন হিসাবে নতুন পরীক্ষাটি প্রবেশ করান, যাতে আপনার _src/lib.rs_ ফাইলটি Listing 11-3-এর মতো দেখায়।

<Listing number="11-3" file-name="src/lib.rs" caption="দ্বিতীয় একটি পরীক্ষা যোগ করা যা ব্যর্থ হবে কারণ আমরা `panic!` ম্যাক্রো কল করছি">

```rust,panics,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-03/src/lib.rs}}
```

</Listing>

`cargo test` ব্যবহার করে আবার পরীক্ষাগুলো চালান। আউটপুটটি Listing 11-4-এর মতো হওয়া উচিত, যা দেখায় যে আমাদের `exploration` পরীক্ষাটি পাস হয়েছে এবং `another` ব্যর্থ হয়েছে।

<Listing number="11-4" caption="পরীক্ষার ফলাফল যখন একটি পরীক্ষা পাস হয় এবং একটি পরীক্ষা ব্যর্থ হয়">

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-03/output.txt}}
```

</Listing>

<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->

`ok`-এর পরিবর্তে, `test tests::another` লাইনটি `FAILED` দেখাচ্ছে। পৃথক ফলাফল এবং সারসংক্ষেপের মধ্যে দুটি নতুন বিভাগ প্রদর্শিত হয়: প্রথমটি প্রতিটি পরীক্ষার ব্যর্থতার বিস্তারিত কারণ দেখায়। এই ক্ষেত্রে, আমরা বিস্তারিত জানতে পারি যে `another` ব্যর্থ হয়েছে কারণ এটি _src/lib.rs_ ফাইলের 17 নম্বর লাইনে `panicked at 'Make this test fail'`। পরবর্তী বিভাগে শুধুমাত্র ব্যর্থ হওয়া পরীক্ষাগুলোর নাম তালিকাভুক্ত করা হয়েছে, যা কাজে লাগে যখন প্রচুর পরীক্ষা এবং প্রচুর বিস্তারিত ব্যর্থ পরীক্ষার আউটপুট থাকে। আমরা একটি ব্যর্থ পরীক্ষার নাম ব্যবহার করে শুধুমাত্র সেই পরীক্ষাটি চালিয়ে আরও সহজে ডিবাগ করতে পারি; আমরা [“পরীক্ষাগুলো কীভাবে চালানো হয় তা নিয়ন্ত্রণ করা”][controlling-how-tests-are-run]<!-- ignore --> বিভাগে পরীক্ষা চালানোর পদ্ধতি নিয়ে আরও আলোচনা করব।

সারসংক্ষেপ লাইনটি শেষে প্রদর্শিত হয়: সামগ্রিকভাবে, আমাদের পরীক্ষার ফলাফল হল `FAILED`। আমাদের একটি পরীক্ষা পাস হয়েছে এবং একটি পরীক্ষা ব্যর্থ হয়েছে।

এখন যেহেতু আপনি বিভিন্ন পরিস্থিতিতে পরীক্ষার ফলাফলগুলো কেমন দেখায় তা দেখেছেন, আসুন `panic!` ছাড়াও অন্য কিছু ম্যাক্রো দেখি যা পরীক্ষায় কাজে লাগে।

### `assert!` ম্যাক্রো দিয়ে ফলাফল পরীক্ষা করা

স্ট্যান্ডার্ড লাইব্রেরি দ্বারা প্রদত্ত `assert!` ম্যাক্রোটি কাজে লাগে যখন আপনি নিশ্চিত করতে চান যে কোনো পরীক্ষার শর্ত `true` হিসাবে মূল্যায়ন করে। আমরা `assert!` ম্যাক্রোতে একটি আর্গুমেন্ট দিই যা একটি বুলিয়ান হিসাবে মূল্যায়ন করে। যদি ভ্যালুটি `true` হয়, তবে কিছুই ঘটে না এবং পরীক্ষাটি পাস হয়। যদি ভ্যালুটি `false` হয়, তাহলে `assert!` ম্যাক্রো পরীক্ষাটিকে ব্যর্থ করার জন্য `panic!` কল করে। `assert!` ম্যাক্রো ব্যবহার করা আমাদের কোডটি আমাদের উদ্দেশ্য অনুযায়ী কাজ করছে কিনা তা পরীক্ষা করতে সাহায্য করে।

Chapter 5-এ, Listing 5-15-এ, আমরা একটি `Rectangle` struct এবং একটি `can_hold` মেথড ব্যবহার করেছি, যা এখানে Listing 11-5-এ পুনরাবৃত্তি করা হয়েছে। আসুন এই কোডটি _src/lib.rs_ ফাইলে রাখি, তারপর `assert!` ম্যাক্রো ব্যবহার করে এর জন্য কিছু পরীক্ষা লিখি।

<Listing number="11-5" file-name="src/lib.rs" caption="Chapter 5 থেকে `Rectangle` struct এবং এর `can_hold` মেথড">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-05/src/lib.rs}}
```

</Listing>

`can_hold` মেথড একটি বুলিয়ান রিটার্ন করে, যার মানে এটি `assert!` ম্যাক্রোর জন্য একটি নিখুঁত ব্যবহারের ক্ষেত্র। Listing 11-6-এ, আমরা একটি পরীক্ষা লিখি যা `can_hold` মেথডটি 8 চওড়া এবং 7 উঁচু একটি `Rectangle` ইনস্ট্যান্স তৈরি করে এবং দাবি করে যে এটি 5 চওড়া এবং 1 উঁচু অন্য `Rectangle` ইনস্ট্যান্সকে ধরে রাখতে পারে।

<Listing number="11-6" file-name="src/lib.rs" caption="`can_hold`-এর জন্য একটি পরীক্ষা যা পরীক্ষা করে যে একটি বড় আয়তক্ষেত্র আসলে একটি ছোট আয়তক্ষেত্রকে ধরে রাখতে পারে কিনা">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-06/src/lib.rs:here}}
```

</Listing>

`tests` মডিউলের ভিতরে `use super::*;` লাইনটি লক্ষ্য করুন। `tests` মডিউল হল একটি নিয়মিত মডিউল যা Chapter 7-এর [“মডিউল ট্রি-এর একটি আইটেম উল্লেখ করার জন্য পাথ”][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore --> বিভাগে আলোচিত সাধারণ দৃশ্যমানতার নিয়ম অনুসরণ করে। যেহেতু `tests` মডিউলটি একটি ভিতরের মডিউল, তাই আমাদের ভিতরের মডিউলের স্কোপে বাইরের মডিউলের পরীক্ষার অধীনে থাকা কোডটি আনতে হবে। আমরা এখানে একটি গ্লোব ব্যবহার করি, তাই বাইরের মডিউলে আমরা যা সংজ্ঞায়িত করি তা এই `tests` মডিউলের জন্য উপলব্ধ।

আমরা আমাদের পরীক্ষার নাম `larger_can_hold_smaller` রেখেছি এবং আমরা দুটি `Rectangle` ইনস্ট্যান্স তৈরি করেছি যা আমাদের প্রয়োজন। তারপর আমরা `assert!` ম্যাক্রো কল করেছি এবং এটিকে `larger.can_hold(&smaller)` কল করার ফলাফল পাস করেছি। এই এক্সপ্রেশনটির `true` রিটার্ন করার কথা, তাই আমাদের পরীক্ষাটি পাস করা উচিত। আসুন খুঁজে বের করি!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-06/output.txt}}
```

এটা পাস হয়! আসুন আরেকটি পরীক্ষা যোগ করি, এবার দাবি করে যে একটি ছোট আয়তক্ষেত্র একটি বড় আয়তক্ষেত্রকে ধরে রাখতে পারে না:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/src/lib.rs:here}}
```

এই ক্ষেত্রে `can_hold` ফাংশনের সঠিক ফলাফল `false` হওয়ার কারণে, `assert!` ম্যাক্রোতে পাস করার আগে আমাদের সেই ফলাফলটিকে নেতিবাচক করতে হবে। ফলস্বরূপ, যদি `can_hold` `false` রিটার্ন করে তবে আমাদের পরীক্ষাটি পাস হবে:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/output.txt}}
```

দুটি পরীক্ষা যা পাস হয়! এখন দেখা যাক যখন আমরা আমাদের কোডে একটি বাগ প্রবর্তন করি তখন আমাদের পরীক্ষার ফলাফলের কী হয়। আমরা `can_hold` মেথডের বাস্তবায়ন পরিবর্তন করব যখন এটি প্রস্থগুলো তুলনা করে তখন বৃহত্তর চিহ্নের পরিবর্তে একটি কম চিহ্ন দিয়ে:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/src/lib.rs:here}}
```

এখন পরীক্ষাগুলো চালালে নিম্নলিখিতটি তৈরি হয়:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/output.txt}}
```

আমাদের পরীক্ষাগুলো বাগটি ধরেছে! যেহেতু `larger.width` হল `8` এবং `smaller.width` হল `5`, তাই `can_hold`-এ প্রস্থগুলোর তুলনা এখন `false` রিটার্ন করে: 8, 5-এর চেয়ে ছোট নয়।

### `assert_eq!` এবং `assert_ne!` ম্যাক্রো দিয়ে সমতা পরীক্ষা করা

কার্যকারিতা যাচাই করার একটি সাধারণ উপায় হল পরীক্ষার অধীনে থাকা কোডের ফলাফল এবং আপনি কোডটি রিটার্ন করার প্রত্যাশিত ভ্যালুর মধ্যে সমতা পরীক্ষা করা। আপনি `assert!` ম্যাক্রো ব্যবহার করে এবং `==` অপারেটর ব্যবহার করে একটি এক্সপ্রেশন পাস করে এটি করতে পারেন। যাইহোক, এটি এত সাধারণ একটি পরীক্ষা যে স্ট্যান্ডার্ড লাইব্রেরি এই পরীক্ষাটিকে আরও সহজে করার জন্য `assert_eq!` এবং `assert_ne!` নামের দুটি ম্যাক্রো প্রদান করে। এই ম্যাক্রো দুটি যথাক্রমে দুটি আর্গুমেন্টকে সমতা বা বৈষম্যের জন্য তুলনা করে। যদি দাবিটি ব্যর্থ হয় তবে তারা দুটি ভ্যালুও প্রিন্ট করবে, যা দেখতে সহজ করে তোলে যে কেন পরীক্ষাটি ব্যর্থ হয়েছে; বিপরীতে, `assert!` ম্যাক্রো শুধুমাত্র `==` এক্সপ্রেশনের জন্য একটি `false` ভ্যালু পেয়েছে কিনা তা নির্দেশ করে, `false` ভ্যালুর দিকে নিয়ে যাওয়া ভ্যালুগুলো প্রিন্ট না করে।

Listing 11-7-এ, আমরা `add_two` নামের একটি ফাংশন লিখি যা এর প্যারামিটারে `2` যোগ করে, তারপর আমরা `assert_eq!` ম্যাক্রো ব্যবহার করে এই ফাংশনটি পরীক্ষা করি।

<Listing number="11-7" file-name="src/lib.rs" caption="`assert_eq!` ম্যাক্রো ব্যবহার করে `add_two` ফাংশন পরীক্ষা করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-07/src/lib.rs}}
```

</Listing>

আসুন পরীক্ষা করি যে এটি পাস হয় কিনা!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-07/output.txt}}
```

আমরা `result` নামের একটি ভেরিয়েবল তৈরি করি যা `add_two(2)` কল করার ফলাফল ধারণ করে। তারপর আমরা `assert_eq!`-এ `result` এবং `4` কে আর্গুমেন্ট হিসাবে পাস করি। এই পরীক্ষার আউটপুট লাইনটি হল `test tests::it_adds_two ... ok`, এবং `ok` টেক্সটটি নির্দেশ করে যে আমাদের পরীক্ষা পাস হয়েছে!

আসুন আমাদের কোডে একটি বাগ প্রবর্তন করি এবং দেখি যখন এটি ব্যর্থ হয় তখন `assert_eq!` কেমন দেখায়। `add_two` ফাংশনের বাস্তবায়ন পরিবর্তন করে পরিবর্তে `3` যোগ করুন:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/src/lib.rs:here}}
```

আবার পরীক্ষাগুলো চালান:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/output.txt}}
```

আমাদের পরীক্ষাটি বাগটি ধরেছে! `it_adds_two` পরীক্ষাটি ব্যর্থ হয়েছে এবং বার্তাটি আমাদের বলছে ``assertion `left == right` failed`` এবং `left` এবং `right` ভ্যালুগুলো কী। এই বার্তাটি আমাদের ডিবাগিং শুরু করতে সাহায্য করে: `left` আর্গুমেন্ট, যেখানে আমাদের `add_two(2)` কল করার ফলাফল ছিল, তা `5` ছিল কিন্তু `right` আর্গুমেন্টটি ছিল `4`। আপনি কল্পনা করতে পারেন যে যখন আমাদের প্রচুর পরীক্ষা চলছে তখন এটি বিশেষভাবে সহায়ক হবে।

মনে রাখবেন যে কিছু ভাষা এবং পরীক্ষা কাঠামোতে, সমতা দাবি ফাংশনগুলোর প্যারামিটারগুলোকে `expected` এবং `actual` বলা হয়, এবং আমরা যে ক্রমে আর্গুমেন্টগুলো উল্লেখ করি তা গুরুত্বপূর্ণ। যাইহোক, রাস্টে, সেগুলোকে `left` এবং `right` বলা হয় এবং আমরা যে ক্রমে আমরা যে ভ্যালু আশা করি এবং কোডটি তৈরি করে তা নির্দিষ্ট করি তা গুরুত্বপূর্ণ নয়। আমরা এই পরীক্ষার দাবিটিকে `assert_eq!(4, result)` হিসাবে লিখতে পারি, যা একই ব্যর্থতা বার্তা তৈরি করবে যা `` assertion failed: `(left == right)` `` দেখায়।

`assert_ne!` ম্যাক্রো পাস হবে যদি আমরা এটিকে যে দুটি ভ্যালু দিই তা সমান না হয় এবং যদি সেগুলো সমান হয় তবে ব্যর্থ হবে। এই ম্যাক্রোটি সেইসব ক্ষেত্রে সবচেয়ে বেশি কাজে লাগে যখন আমরা নিশ্চিত নই যে একটি ভ্যালু কী _হবে_, তবে আমরা জানি যে ভ্যালু কী _হওয়া উচিত নয়_। উদাহরণস্বরূপ, যদি আমরা এমন একটি ফাংশন পরীক্ষা করি যা তার ইনপুট পরিবর্তন করার নিশ্চয়তা দেয়, কিন্তু ইনপুটটি পরিবর্তন করার উপায়টি আমরা আমাদের পরীক্ষা চালানোর সপ্তাহের দিনের উপর নির্ভর করে, তাহলে দাবি করার সবচেয়ে ভাল জিনিস হতে পারে যে ফাংশনের আউটপুট ইনপুটের সমান নয়।

ভিতরে, `assert_eq!` এবং `assert_ne!` ম্যাক্রো যথাক্রমে `==` এবং `!=` অপারেটর ব্যবহার করে। যখন দাবিগুলো ব্যর্থ হয়, তখন এই ম্যাক্রোগুলো ডিবাগ ফরম্যাটিং ব্যবহার করে তাদের আর্গুমেন্টগুলো প্রিন্ট করে, যার মানে তুলনা করা ভ্যালুগুলোকে অবশ্যই `PartialEq` এবং `Debug` ট্রেট প্রয়োগ করতে হবে। সমস্ত প্রিমিটিভ টাইপ এবং স্ট্যান্ডার্ড লাইব্রেরির বেশিরভাগ টাইপ এই ট্রেটগুলো প্রয়োগ করে। আপনি নিজে সংজ্ঞায়িত করা struct এবং enum-এর জন্য, সেই টাইপগুলোর সমতা দাবি করার জন্য আপনাকে `PartialEq` প্রয়োগ করতে হবে। দাবি ব্যর্থ হলে ভ্যালুগুলো প্রিন্ট করার জন্য আপনাকে `Debug`-ও প্রয়োগ করতে হবে। যেহেতু উভয় ট্রেটই ডেরাইভ করা যায় এমন ট্রেট, যেমন Chapter 5-এর Listing 5-12-এ উল্লেখ করা হয়েছে, তাই আপনার struct বা enum সংজ্ঞাতে `#[derive(PartialEq, Debug)]` টীকা যোগ করার মতোই এটি সাধারণত সোজা। এই এবং অন্যান্য ডেরাইভ করা যায় এমন ট্রেট সম্পর্কে আরও বিস্তারিত জানার জন্য Appendix C, [“ডেরাইভ করা যায় এমন ট্রেট”][derivable-traits]<!-- ignore --> দেখুন।

### কাস্টম ব্যর্থতা বার্তা যোগ করা

আপনি `assert!`, `assert_eq!` এবং `assert_ne!` ম্যাক্রোগুলোতে ঐচ্ছিক আর্গুমেন্ট হিসাবে ব্যর্থতার বার্তার সাথে প্রিন্ট করার জন্য একটি কাস্টম বার্তাও যোগ করতে পারেন। প্রয়োজনীয় আর্গুমেন্টের পরে নির্দিষ্ট করা যেকোনো আর্গুমেন্ট `format!` ম্যাক্রোতে (Chapter 8-এ [“`+` অপারেটর বা `format!` ম্যাক্রো দিয়ে কনক্যাটেনেশন”][concatenation-with-the--operator-or-the-format-macro]<!-- ignore --> বিভাগে আলোচনা করা হয়েছে) পাস করা হয়, তাই আপনি একটি ফরম্যাট স্ট্রিং পাস করতে পারেন যাতে `{}` স্থানধারক এবং সেই স্থানধারকগুলোতে যাওয়ার ভ্যালু থাকে। কাস্টম বার্তাগুলো একটি দাবি কী বোঝায় তা নথিভুক্ত করার জন্য উপযোগী; যখন একটি পরীক্ষা ব্যর্থ হয়, তখন আপনার কোডের সমস্যা কী তা সম্পর্কে আপনার আরও ভাল ধারণা থাকবে।

উদাহরণস্বরূপ, ধরা যাক আমাদের কাছে এমন একটি ফাংশন আছে যা নাম ধরে লোকেদের অভিবাদন জানায় এবং আমরা পরীক্ষা করতে চাই যে আমরা ফাংশনে যে নামটি পাস করি তা আউটপুটে প্রদর্শিত হয় কিনা:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-05-greeter/src/lib.rs}}
```

এই প্রোগ্রামের প্রয়োজনীয়তাগুলো এখনও সম্মত হয়নি, এবং আমরা মোটামুটি নিশ্চিত যে অভিবাদনের শুরুতে `Hello` টেক্সটটি পরিবর্তন হবে। আমরা সিদ্ধান্ত নিয়েছি যে প্রয়োজনীয়তাগুলো পরিবর্তিত হলে আমরা পরীক্ষাটি আপডেট করতে চাই না, তাই `greeting` ফাংশন থেকে রিটার্ন করা ভ্যালুর সাথে সঠিক সমতা পরীক্ষা করার পরিবর্তে, আমরা শুধু দাবি করব যে আউটপুটে ইনপুট প্যারামিটারের টেক্সট রয়েছে।

এখন আসুন `greeting` পরিবর্তন করে `name` বাদ দিয়ে এই কোডে একটি বাগ প্রবর্তন করি এবং দেখি ডিফল্ট পরীক্ষার ব্যর্থতা কেমন দেখায়:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/src/lib.rs:here}}
```

এই পরীক্ষা চালালে নিম্নলিখিতটি তৈরি হয়:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt}}
```

এই ফলাফলটি শুধুমাত্র নির্দেশ করে যে দাবিটি ব্যর্থ হয়েছে এবং কোন লাইনে দাবিটি করা হয়েছে। একটি আরও দরকারী ব্যর্থতার বার্তা `greeting` ফাংশন থেকে ভ্যালু প্রিন্ট করবে। আসুন একটি কাস্টম ব্যর্থতার বার্তা যোগ করি যা `greeting` ফাংশন থেকে আমরা যে প্রকৃত ভ্যালু পেয়েছি তা দিয়ে পূরণ করা একটি স্থানধারক সহ একটি ফরম্যাট স্ট্রিং দিয়ে গঠিত:

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/src/lib.rs:here}}
```

এখন যখন আমরা পরীক্ষাটি চালাব, তখন আমরা আরও তথ্যপূর্ণ একটি এরর বার্তা পাব:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/output.txt}}
```

আমরা পরীক্ষার আউটপুটে আসলে যে ভ্যালুটি পেয়েছি তা দেখতে পাচ্ছি, যা আমাদের কী ঘটেছে তা ডিবাগ করতে সাহায্য করবে, আমরা কী ঘটতে আশা করছিলাম তা নয়।

### `should_panic` দিয়ে প্যানিক পরীক্ষা করা

রিটার্ন ভ্যালুগুলো পরীক্ষা করার পাশাপাশি, আমাদের কোডটি আমাদের প্রত্যাশা অনুযায়ী এরর পরিস্থিতিগুলো পরিচালনা করে কিনা তা পরীক্ষা করাও গুরুত্বপূর্ণ। উদাহরণস্বরূপ, `Guess` টাইপটি বিবেচনা করুন যা আমরা Chapter 9, Listing 9-13-এ তৈরি করেছি। `Guess` ব্যবহার করে এমন অন্যান্য কোড এই গ্যারান্টির উপর নির্ভর করে যে `Guess` ইনস্ট্যান্সগুলোতে শুধুমাত্র 1 থেকে 100-এর মধ্যে ভ্যালু থাকবে। আমরা একটি পরীক্ষা লিখতে পারি যা নিশ্চিত করে যে সেই সীমার বাইরের ভ্যালু দিয়ে `Guess` ইনস্ট্যান্স তৈরি করার চেষ্টা করলে প্যানিক হয়।

আমরা আমাদের পরীক্ষা ফাংশনে `should_panic` অ্যাট্রিবিউট যোগ করে এটি করি। ফাংশনের ভিতরের কোডটি প্যানিক করলে পরীক্ষাটি পাস হয়; ফাংশনের ভিতরের কোডটি প্যানিক না করলে পরীক্ষাটি ব্যর্থ হয়।

Listing 11-8 একটি পরীক্ষা দেখায় যা পরীক্ষা করে যে `Guess::new`-এর এরর কন্ডিশনগুলো কখন আমরা আশা করি তখন ঘটে কিনা।

<Listing number="11-8" file-name="src/lib.rs" caption="একটি কন্ডিশন `panic!` সৃষ্টি করবে কিনা তা পরীক্ষা করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-08/src/lib.rs}}
```

</Listing>

আমরা `#[test]` অ্যাট্রিবিউটের পরে এবং এটি প্রয়োগ করে এমন পরীক্ষা ফাংশনের আগে `#[should_panic]` অ্যাট্রিবিউট রাখি। আসুন এই পরীক্ষাটি পাস হলে এর ফলাফলটি দেখি:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-08/output.txt}}
```

ভাল দেখাচ্ছে! এখন আসুন আমাদের কোডে একটি বাগ প্রবর্তন করি `new` ফাংশনটি যদি ভ্যালুটি 100-এর চেয়ে বড় হয় তবে প্যানিক করবে সেই কন্ডিশনটি সরিয়ে দিয়ে:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/src/lib.rs:here}}
```

যখন আমরা Listing 11-8-এ পরীক্ষাটি চালাই, তখন এটি ব্যর্থ হবে:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/output.txt}}
```

এই ক্ষেত্রে আমরা খুব বেশি সহায়ক বার্তা পাই না, তবে যখন আমরা পরীক্ষা ফাংশনটি দেখি, তখন আমরা দেখি যে এটি `#[should_panic]` দিয়ে টীকা করা আছে। আমরা যে ব্যর্থতা পেয়েছি তার মানে হল পরীক্ষা ফাংশনের কোড প্যানিক সৃষ্টি করেনি।

`should_panic` ব্যবহার করে পরীক্ষাগুলো ভুল হতে পারে। `should_panic` পরীক্ষাটি পাস হবে এমনকি যদি আমরা যে কারণে প্যানিক আশা করছিলাম তার থেকে ভিন্ন কারণে পরীক্ষাটি প্যানিক করে। `should_panic` পরীক্ষাগুলোকে আরও নির্ভুল করতে, আমরা `should_panic` অ্যাট্রিবিউটে একটি ঐচ্ছিক `expected` প্যারামিটার যোগ করতে পারি। পরীক্ষার সরঞ্জামটি নিশ্চিত করবে যে ব্যর্থতার বার্তায় প্রদত্ত টেক্সট রয়েছে। উদাহরণস্বরূপ, Listing 11-9-এর `Guess`-এর জন্য পরিবর্তিত কোডটি বিবেচনা করুন যেখানে `new` ফাংশনটি ভ্যালু খুব ছোট বা খুব বড় কিনা তার উপর নির্ভর করে বিভিন্ন বার্তা দিয়ে প্যানিক করে।

<Listing number="11-9" file-name="src/lib.rs" caption="একটি নির্দিষ্ট সাবস্ট্রিং ধারণকারী প্যানিক বার্তা সহ একটি `panic!` এর জন্য পরীক্ষা করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-09/src/lib.rs:here}}
```

</Listing>

এই পরীক্ষাটি পাস হবে কারণ আমরা `should_panic` অ্যাট্রিবিউটের `expected` প্যারামিটারে যে ভ্যালুটি রেখেছি তা হল সেই বার্তার একটি সাবস্ট্রিং যা `Guess::new` ফাংশনটি প্যানিক করার সময় ব্যবহার করে। আমরা সম্পূর্ণ প্যানিক বার্তাটি উল্লেখ করতে পারতাম যা আমরা আশা করি, যা এই ক্ষেত্রে হত `Guess value must be less than or equal to 100, got 200`। আপনি কী উল্লেখ করতে চান তা নির্ভর করে প্যানিক বার্তার কতটুকু অনন্য বা ডায়নামিক এবং আপনি আপনার পরীক্ষাকে কতটা নির্ভুল করতে চান তার উপর। এই ক্ষেত্রে, প্যানিক বার্তার একটি সাবস্ট্রিং যথেষ্ট নিশ্চিত করার জন্য যে পরীক্ষা ফাংশনের কোড `else if value > 100` কেসটি কার্যকর করে।

`expected` বার্তা সহ একটি `should_panic` পরীক্ষা ব্যর্থ হলে কী ঘটে তা দেখতে, আসুন আমরা আবার `if value < 1` এবং `else if value > 100` ব্লকের বডি অদলবদল করে আমাদের কোডে একটি বাগ প্রবর্তন করি:

```rust,ignore,not_desired_behavior
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/src/lib.rs:here}}
```

এইবার যখন আমরা `should_panic` পরীক্ষাটি চালাব, তখন এটি ব্যর্থ হবে:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/output.txt}}
```

ব্যর্থতার বার্তাটি নির্দেশ করে যে এই পরীক্ষাটি আসলেই প্যানিক করেছে যেমনটি আমরা আশা করেছিলাম, কিন্তু প্যানিক বার্তায় `less than or equal
to 100` নামক প্রত্যাশিত স্ট্রিংটি অন্তর্ভুক্ত ছিল না। এই ক্ষেত্রে আমরা যে প্যানিক বার্তাটি পেয়েছিলাম তা হল `Guess value must
be greater than or equal to 1, got 200.` এখন আমরা কোথায় আমাদের বাগ আছে তা বের করা শুরু করতে পারি!

### পরীক্ষায় `Result<T, E>` ব্যবহার করা

আমাদের পরীক্ষাগুলো এখন পর্যন্ত ব্যর্থ হলে প্যানিক করে। আমরা `Result<T, E>` ব্যবহার করে এমন পরীক্ষাও লিখতে পারি! Listing 11-1 থেকে পরীক্ষাটি এখানে `Result<T,
E>` ব্যবহার করার জন্য পুনরায় লেখা হয়েছে এবং প্যানিক করার পরিবর্তে একটি `Err` রিটার্ন করা হয়েছে:

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-10-result-in-tests/src/lib.rs:here}}
```

`it_works` ফাংশনের এখন `Result<(), String>` রিটার্ন টাইপ আছে। ফাংশনের বডিতে, `assert_eq!` ম্যাক্রো কল করার পরিবর্তে, আমরা যখন পরীক্ষাটি পাস হয় তখন `Ok(())` এবং যখন পরীক্ষাটি ব্যর্থ হয় তখন ভিতরে একটি `String` সহ একটি `Err` রিটার্ন করি।

পরীক্ষাগুলো এমনভাবে লেখা যাতে তারা একটি `Result<T, E>` রিটার্ন করে, তাহলে আপনি পরীক্ষার বডিতে প্রশ্নবোধক চিহ্ন অপারেটর ব্যবহার করতে পারবেন, যা এমন পরীক্ষা লেখার একটি সুবিধাজনক উপায় হতে পারে যা ব্যর্থ হওয়া উচিত যদি তাদের ভিতরের কোনো অপারেশন একটি `Err` ভেরিয়েন্ট রিটার্ন করে।

আপনি `Result<T,
E>` ব্যবহার করে এমন পরীক্ষায় `#[should_panic]` টীকা ব্যবহার করতে পারবেন না। একটি অপারেশন `Err` ভেরিয়েন্ট রিটার্ন করে কিনা তা দাবি করতে, `Result<T, E>` ভ্যালুতে প্রশ্নবোধক চিহ্ন অপারেটর ব্যবহার _করবেন না_। পরিবর্তে, `assert!(value.is_err())` ব্যবহার করুন।

এখন যেহেতু আপনি পরীক্ষা লেখার বিভিন্ন উপায় জানেন, আসুন দেখি যখন আমরা আমাদের পরীক্ষাগুলো চালাই তখন কী ঘটছে এবং `cargo
test`-এর সাথে আমরা যে বিভিন্ন অপশন ব্যবহার করতে পারি সেগুলো অন্বেষণ করি।

[concatenation-with-the--operator-or-the-format-macro]: ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro
[bench]: ../unstable-book/library-features/test.html
[ignoring]: ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested
[subset]: ch11-02-running-tests.html#running-a-subset-of-tests-by-name
[controlling-how-tests-are-run]: ch11-02-running-tests.html#controlling-how-tests-are-run
[derivable-traits]: appendix-03-derivable-traits.html
[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests
[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html
