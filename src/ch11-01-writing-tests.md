## টেস্ট কিভাবে লিখতে হয়

টেস্ট হলো Rust ফাংশন যা ভেরিফাই (verify) করে যে নন-টেস্ট কোড প্রত্যাশিত পদ্ধতিতে কাজ করছে কিনা। টেস্ট ফাংশনের বডি (body) সাধারণত এই তিনটি কাজ করে:

-   প্রয়োজনীয় ডেটা বা স্টেট সেট আপ করা।
-   আপনি যে কোডটি টেস্ট করতে চান তা রান করা।
-   ফলাফল আপনার প্রত্যাশা অনুযায়ী কিনা তা অ্যাসার্ট (assert) করা।

আসুন, Rust এর সেই ফিচারগুলো দেখি যা বিশেষভাবে টেস্ট লেখার জন্য এই কাজগুলো করতে সাহায্য করে। এর মধ্যে রয়েছে `test` অ্যাট্রিবিউট, কয়েকটি ম্যাক্রো এবং `should_panic` অ্যাট্রিবিউট।

### একটি টেস্ট ফাংশনের গঠন

সহজ ভাষায়, Rust-এ একটি টেস্ট হলো এমন একটি ফাংশন যা `test` অ্যাট্রিবিউট দিয়ে অ্যানোটেট (annotated) করা থাকে। অ্যাট্রিবিউট হলো Rust কোডের বিভিন্ন অংশ সম্পর্কে মেটাডেটা; এর একটি উদাহরণ হলো `derive` অ্যাট্রিবিউট যা আমরা পঞ্চম অধ্যায়ে struct-এর সাথে ব্যবহার করেছি। একটি সাধারণ ফাংশনকে টেস্ট ফাংশনে রূপান্তর করতে, `fn` এর আগের লাইনে `#[test]` যোগ করুন। যখন আপনি `cargo test` কমান্ড দিয়ে আপনার টেস্টগুলো চালান, তখন Rust একটি টেস্ট রানার বাইনারি (test runner binary) তৈরি করে যা এই অ্যানোটেট করা ফাংশনগুলো চালায় এবং প্রতিটি টেস্ট ফাংশন পাস করেছে না ফেইল করেছে তার রিপোর্ট দেয়।

যখনই আমরা Cargo দিয়ে একটি নতুন লাইব্রেরি প্রজেক্ট তৈরি করি, তখন আমাদের জন্য স্বয়ংক্রিয়ভাবে একটি টেস্ট মডিউল এবং তার ভেতরে একটি টেস্ট ফাংশন তৈরি হয়ে যায়। এই মডিউলটি আপনাকে টেস্ট লেখার জন্য একটি টেমপ্লেট দেয়, যাতে প্রতিবার নতুন প্রজেক্ট শুরু করার সময় আপনাকে সঠিক গঠন এবং সিনট্যাক্স খুঁজতে না হয়। আপনি যত খুশি অতিরিক্ত টেস্ট ফাংশন এবং টেস্ট মডিউল যোগ করতে পারেন!

কোনো কোড টেস্ট করার আগে, আমরা টেমপ্লেট টেস্টটি নিয়ে পরীক্ষা করে দেখব টেস্টগুলো কীভাবে কাজ করে। তারপর আমরা কিছু বাস্তবসম্মত টেস্ট লিখব যা আমাদের লেখা কোডকে কল করবে এবং তার আচরণ সঠিক কিনা তা অ্যাসার্ট করবে।

আসুন `adder` নামে একটি নতুন লাইব্রেরি প্রজেক্ট তৈরি করি যা দুটি সংখ্যা যোগ করবে:

```console
$ cargo new adder --lib
     Created library `adder` project
$ cd adder
```

আপনার `adder` লাইব্রেরির _src/lib.rs_ ফাইলের কন্টেন্ট তালিকা ১১-১ এর মতো দেখতে হওয়া উচিত।

<Listing number="11-1" file-name="src/lib.rs" caption="`cargo new` দ্বারা স্বয়ংক্রিয়ভাবে তৈরি কোড">

<!-- manual-regeneration
cd listings/ch11-writing-automated-tests
rm -rf listing-11-01
cargo new listing-11-01 --lib --name adder
cd listing-11-01
echo "$ cargo test" > output.txt
RUSTFLAGS="-A unused_variables -A dead_code" RUST_TEST_THREADS=1 cargo test >> output.txt 2>&1
git diff output.txt # commit any relevant changes; discard irrelevant ones
cd ../../..
-->

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-01/src/lib.rs}}
```

</Listing>

ফাইলটি একটি উদাহরণ `add` ফাংশন দিয়ে শুরু হয়, যাতে আমাদের টেস্ট করার জন্য কিছু একটা থাকে।

আপাতত, আসুন আমরা শুধু `it_works` ফাংশনটির উপর মনোযোগ দিই। `#[test]` অ্যানোটেশনটি লক্ষ্য করুন: এই অ্যাট্রিবিউটটি নির্দেশ করে যে এটি একটি টেস্ট ফাংশন, তাই টেস্ট রানার জানে যে এই ফাংশনটিকে একটি টেস্ট হিসাবে গণ্য করতে হবে। আমাদের `tests` মডিউলে নন-টেস্ট ফাংশনও থাকতে পারে যা সাধারণ পরিস্থিতি সেট আপ করতে বা সাধারণ অপারেশন করতে সাহায্য করে, তাই আমাদের সবসময় নির্দিষ্ট করে দিতে হবে কোন ফাংশনগুলো টেস্ট।

উদাহরণ ফাংশন বডি `assert_eq!` ম্যাক্রো ব্যবহার করে অ্যাসার্ট করে যে `result` (যেখানে ২ এবং ২ দিয়ে `add` কল করার ফলাফল রয়েছে) এর মান ৪ এর সমান। এই অ্যাসার্শনটি একটি সাধারণ টেস্টের ফরম্যাটের উদাহরণ হিসাবে কাজ করে। চলুন এটি রান করে দেখি যে এই টেস্টটি পাস করে কিনা।

`cargo test` কমান্ডটি আমাদের প্রজেক্টের সমস্ত টেস্ট চালায়, যা তালিকা ১১-২-এ দেখানো হয়েছে।

<Listing number="11-2" caption="স্বয়ংক্রিয়ভাবে জেনারেট হওয়া টেস্ট চালানোর আউটপুট">

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-01/output.txt}}
```

</Listing>

Cargo টেস্টটি কম্পাইল এবং রান করেছে। আমরা `running 1 test` লাইনটি দেখতে পাচ্ছি। পরবর্তী লাইনটি জেনারেট হওয়া টেস্ট ফাংশনের নাম দেখায়, যা হলো `tests::it_works` এবং সেই টেস্টটি চালানোর ফলাফল হলো `ok`। সামগ্রিক সারাংশ `test result: ok.` এর মানে হলো সমস্ত টেস্ট পাস করেছে এবং `1 passed; 0 failed` অংশটি পাস বা ফেইল করা টেস্টের সংখ্যা দেখায়।

একটি টেস্টকে ইগনোর (ignored) হিসেবে চিহ্নিত করা সম্ভব যাতে এটি একটি নির্দিষ্ট ক্ষেত্রে রান না হয়; আমরা এই অধ্যায়ের পরে ["Ignoring Some Tests Unless Specifically Requested"][ignoring]<!-- ignore --> বিভাগে এটি আলোচনা করব। যেহেতু আমরা এখানে তা করিনি, তাই সারাংশে `0 ignored` দেখাচ্ছে। আমরা `cargo test` কমান্ডে একটি আর্গুমেন্ট পাস করে শুধুমাত্র সেইসব টেস্ট চালাতে পারি যাদের নাম একটি স্ট্রিং এর সাথে মেলে; একে _ফিল্টারিং_ বলা হয় এবং আমরা এটি ["Running a Subset of Tests by Name”][subset]<!-- ignore --> বিভাগে আলোচনা করব। এখানে আমরা কোনো টেস্ট ফিল্টার করিনি, তাই সারাংশের শেষে `0 filtered out` দেখাচ্ছে।

`0 measured` পরিসংখ্যানটি বেঞ্চমার্ক টেস্টের জন্য যা পারফরম্যান্স পরিমাপ করে। বেঞ্চমার্ক টেস্ট, এই লেখা পর্যন্ত, শুধুমাত্র নাইটলি রাস্ট-এ (nightly Rust) উপলব্ধ। বেঞ্চমার্ক টেস্ট সম্পর্কে আরও জানতে [the documentation about benchmark tests][bench] দেখুন।

টেস্ট আউটপুটের পরবর্তী অংশ যা `Doc-tests adder` দিয়ে শুরু হয়েছে, তা যেকোনো ডকুমেন্টেশন টেস্টের ফলাফলের জন্য। আমাদের এখনো কোনো ডকুমেন্টেশন টেস্ট নেই, কিন্তু Rust আমাদের API ডকুমেন্টেশনে থাকা যেকোনো কোড উদাহরণ কম্পাইল করতে পারে। এই ফিচারটি আপনার ডকুমেন্টেশন এবং আপনার কোডকে সিঙ্কে রাখতে সাহায্য করে! আমরা ১৪ অধ্যায়ের [“Documentation Comments as Tests”][doc-comments]<!-- ignore --> বিভাগে কীভাবে ডকুমেন্টেশন টেস্ট লিখতে হয় তা আলোচনা করব। আপাতত, আমরা `Doc-tests` আউটপুটটি উপেক্ষা করব।

আসুন আমাদের প্রয়োজন অনুযায়ী টেস্টটি কাস্টমাইজ করা শুরু করি। প্রথমে, `it_works` ফাংশনের নাম পরিবর্তন করে অন্য কোনো নাম দিন, যেমন `exploration`, এইভাবে:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/src/lib.rs}}
```

তারপর আবার `cargo test` চালান। আউটপুট এখন `it_works` এর পরিবর্তে `exploration` দেখাবে:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-01-changing-test-name/output.txt}}
```

এখন আমরা আরেকটি টেস্ট যোগ করব, কিন্তু এবার আমরা এমন একটি টেস্ট তৈরি করব যা ফেইল করবে! টেস্ট তখন ফেইল করে যখন টেস্ট ফাংশনের কোনো কিছু প্যানিক (panic) করে। প্রতিটি টেস্ট একটি নতুন থ্রেডে (thread) চালানো হয়, এবং যখন প্রধান থ্রেড দেখে যে একটি টেস্ট থ্রেড মারা গেছে, তখন টেস্টটিকে ফেইল হিসেবে চিহ্নিত করা হয়। নবম অধ্যায়ে আমরা আলোচনা করেছি যে প্যানিক করার সবচেয়ে সহজ উপায় হলো `panic!` ম্যাক্রো কল করা। নতুন টেস্টটি `another` নামে একটি ফাংশন হিসাবে প্রবেশ করান, যাতে আপনার _src/lib.rs_ ফাইলটি তালিকা ১১-৩ এর মতো দেখায়।

<Listing number="11-3" file-name="src/lib.rs" caption="একটি দ্বিতীয় টেস্ট যোগ করা যা `panic!` ম্যাক্রো কল করার কারণে ফেইল করবে">

```rust,panics,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-03/src/lib.rs}}
```

</Listing>

`cargo test` ব্যবহার করে আবার টেস্টগুলো চালান। আউটপুটটি তালিকা ১১-৪ এর মতো হওয়া উচিত, যা দেখায় যে আমাদের `exploration` টেস্ট পাস করেছে এবং `another` ফেইল করেছে।

<Listing number="11-4" caption="যখন একটি টেস্ট পাস করে এবং একটি ফেইল করে তখনকার টেস্ট ফলাফল">

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-03/output.txt}}
```

</Listing>

<!-- manual-regeneration
rg panicked listings/ch11-writing-automated-tests/listing-11-03/output.txt
check the line number of the panic matches the line number in the following paragraph
 -->

`ok` এর পরিবর্তে, `test tests::another` লাইনটি `FAILED` দেখাচ্ছে। স্বতন্ত্র ফলাফলের এবং সারাংশের মধ্যে দুটি নতুন বিভাগ উপস্থিত হয়েছে: প্রথমটি প্রতিটি টেস্ট ফেইলের বিস্তারিত কারণ প্রদর্শন করে। এক্ষেত্রে, আমরা বিস্তারিতভাবে জানতে পারি যে `tests::another` ফেইল করেছে কারণ এটি _src/lib.rs_ ফাইলের ১৭ নম্বর লাইনে `Make this test fail` বার্তা দিয়ে প্যানিক করেছে। পরবর্তী বিভাগটি শুধুমাত্র সমস্ত ফেইল করা টেস্টের নাম তালিকাভুক্ত করে, যা অনেক টেস্ট এবং অনেক বিস্তারিত ফেইলিং টেস্ট আউটপুট থাকলে কার্যকর। আমরা একটি ফেইল করা টেস্টের নাম ব্যবহার করে শুধুমাত্র সেই টেস্টটি চালাতে পারি যাতে এটি ডিবাগ করা সহজ হয়; আমরা [“Controlling How Tests Are Run”][controlling-how-tests-are-run]<!-- ignore --> বিভাগে টেস্ট চালানোর উপায় সম্পর্কে আরও কথা বলব।

সারাংশ লাইনটি শেষে প্রদর্শিত হয়: সামগ্রিকভাবে, আমাদের টেস্ট ফলাফল `FAILED`। আমাদের একটি টেস্ট পাস করেছে এবং একটি ফেইল করেছে।

এখন যেহেতু আপনি বিভিন্ন পরিস্থিতিতে টেস্টের ফলাফল কেমন দেখায় তা দেখেছেন, আসুন `panic!` ছাড়া অন্য কিছু ম্যাক্রো দেখি যা টেস্টে কার্যকর।

### `assert!` ম্যাক্রো দিয়ে ফলাফল পরীক্ষা করা

`assert!` ম্যাক্রো, যা স্ট্যান্ডার্ড লাইব্রেরি দ্বারা সরবরাহ করা হয়, তখন খুব দরকারি যখন আপনি নিশ্চিত করতে চান যে টেস্টের কোনো একটি শর্ত `true` হিসেবে মূল্যায়ন হয়। আমরা `assert!` ম্যাক্রোকে একটি আর্গুমেন্ট দিই যা একটি বুলিয়ানে (Boolean) পরিণত হয়। যদি মান `true` হয়, কিছুই হয় না এবং টেস্ট পাস করে। যদি মান `false` হয়, `assert!` ম্যাক্রো `panic!` কল করে টেস্টটিকে ফেইল করায়। `assert!` ম্যাক্রো ব্যবহার করে আমরা পরীক্ষা করতে পারি যে আমাদের কোডটি আমাদের উদ্দেশ্য অনুযায়ী কাজ করছে কিনা।

অধ্যায় ৫, তালিকা ৫-১৫-তে, আমরা একটি `Rectangle` struct এবং একটি `can_hold` মেথড ব্যবহার করেছিলাম, যা এখানে তালিকা ১১-৫-এ পুনরাবৃত্তি করা হলো। চলুন এই কোডটি _src/lib.rs_ ফাইলে রাখি, তারপর `assert!` ম্যাক্রো ব্যবহার করে এর জন্য কিছু টেস্ট লিখি।

<Listing number="11-5" file-name="src/lib.rs" caption="অধ্যায় ৫ থেকে `Rectangle` struct এবং এর `can_hold` মেথড">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-05/src/lib.rs}}
```

</Listing>

`can_hold` মেথডটি একটি বুলিয়ান রিটার্ন করে, যার মানে এটি `assert!` ম্যাক্রোর জন্য একটি উপযুক্ত ব্যবহারক্ষেত্র। তালিকা ১১-৬-এ, আমরা একটি টেস্ট লিখছি যা `can_hold` মেথডটি ব্যবহার করে। এতে আমরা ৮ প্রস্থ এবং ৭ উচ্চতার একটি `Rectangle` ইনস্ট্যান্স তৈরি করি এবং অ্যাসার্ট করি যে এটি ৫ প্রস্থ এবং ১ উচ্চতার আরেকটি `Rectangle` ইনস্ট্যান্সকে ধারণ করতে পারে।

<Listing number="11-6" file-name="src/lib.rs" caption="`can_hold`-এর জন্য একটি টেস্ট যা পরীক্ষা করে যে একটি বড় আয়তক্ষেত্র সত্যিই একটি ছোট আয়তক্ষেত্রকে ধারণ করতে পারে কিনা">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-06/src/lib.rs:here}}
```

</Listing>

`tests` মডিউলের ভিতরে `use super::*;` লাইনটি লক্ষ্য করুন। `tests` মডিউলটি একটি সাধারণ মডিউল যা আমরা ৭ অধ্যায়ের ["Paths for Referring to an Item in the Module Tree"][paths-for-referring-to-an-item-in-the-module-tree]<!-- ignore --> বিভাগে আলোচনা করা সাধারণ ভিজিবিলিটি নিয়ম অনুসরণ করে। যেহেতু `tests` মডিউলটি একটি অভ্যন্তরীণ মডিউল, তাই আমাদের বাইরের মডিউলের কোডটি ভেতরের মডিউলের স্কোপে আনতে হবে। আমরা এখানে একটি গ্লব (glob) ব্যবহার করি, তাই বাইরের মডিউলে আমরা যা কিছু ডিফাইন করি তা এই `tests` মডিউলের জন্য উপলব্ধ থাকে।

আমরা আমাদের টেস্টের নাম দিয়েছি `larger_can_hold_smaller` এবং আমাদের প্রয়োজনীয় দুটি `Rectangle` ইনস্ট্যান্স তৈরি করেছি। তারপর আমরা `assert!` ম্যাক্রো কল করে তাতে `larger.can_hold(&smaller)` এর ফলাফল পাস করেছি। এই এক্সপ্রেশনটির `true` রিটার্ন করার কথা, তাই আমাদের টেস্ট পাস করা উচিত। চলুন দেখি!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-06/output.txt}}
```

এটি পাস করেছে! আসুন আরেকটি টেস্ট যোগ করি, এবার অ্যাসার্ট করব যে একটি ছোট আয়তক্ষেত্র একটি বড় আয়তক্ষেত্রকে ধারণ করতে পারে না:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/src/lib.rs:here}}
```

যেহেতু এই ক্ষেত্রে `can_hold` ফাংশনের সঠিক ফলাফল `false`, তাই আমাদের `assert!` ম্যাক্রোতে পাস করার আগে সেই ফলাফলটিকে নেগেট (negate) করতে হবে। ফলস্বরূপ, যদি `can_hold` `false` রিটার্ন করে তাহলে আমাদের টেস্ট পাস করবে:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-02-adding-another-rectangle-test/output.txt}}
```

দুটি টেস্টই পাস করেছে! এখন দেখা যাক আমাদের কোডে একটি বাগ প্রবেশ করালে টেস্টের ফলাফলে কী ঘটে। আমরা `can_hold` মেথডের ইমপ্লিমেন্টেশনে প্রস্থ তুলনা করার সময় গ্রেটার-দ্যান চিহ্নের পরিবর্তে একটি লেস-দ্যান চিহ্ন দিয়ে পরিবর্তন করব:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/src/lib.rs:here}}
```

এখন টেস্ট চালালে নিম্নলিখিত ফলাফল পাওয়া যাবে:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-03-introducing-a-bug/output.txt}}```

আমাদের টেস্ট বাগটি ধরে ফেলেছে! যেহেতু `larger.width` হলো `8` এবং `smaller.width` হলো `5`, `can_hold`-এ প্রস্থের তুলনা এখন `false` রিটার্ন করছে: ৮, ৫-এর থেকে ছোট নয়।

### `assert_eq!` এবং `assert_ne!` ম্যাক্রো দিয়ে সমতা পরীক্ষা করা

ফাংশনালিটি যাচাই করার একটি সাধারণ উপায় হলো, টেস্ট করা কোডের ফলাফল এবং আপনার প্রত্যাশিত মানের মধ্যে সমতা পরীক্ষা করা। আপনি `assert!` ম্যাক্রো এবং `==` অপারেটর ব্যবহার করে এটি করতে পারেন। যাইহোক, এটি এত সাধারণ একটি পরীক্ষা যে স্ট্যান্ডার্ড লাইব্রেরি এই কাজটি আরও সুবিধাজনকভাবে করার জন্য `assert_eq!` এবং `assert_ne!`—নামে একজোড়া ম্যাক্রো সরবরাহ করে। এই ম্যাক্রোগুলো দুটি আর্গুমেন্টকে যথাক্রমে সমতা বা অসমতার জন্য তুলনা করে। যদি অ্যাসার্শন ফেইল করে, তবে তারা দুটি মানই প্রিন্ট করবে, যা টেস্টটি _কেন_ ফেইল করেছে তা দেখতে সহজ করে তোলে; বিপরীতভাবে, `assert!` ম্যাক্রো শুধুমাত্র নির্দেশ করে যে এটি `==` এক্সপ্রেশনের জন্য একটি `false` মান পেয়েছে, কিন্তু যে মানগুলোর কারণে `false` হয়েছে তা প্রিন্ট করে না।

তালিকা ১১-৭-এ, আমরা `add_two` নামে একটি ফাংশন লিখছি যা এর প্যারামিটারের সাথে `2` যোগ করে, তারপর আমরা `assert_eq!` ম্যাক্রো ব্যবহার করে এই ফাংশনটি টেস্ট করি।

<Listing number="11-7" file-name="src/lib.rs" caption="`assert_eq!` ম্যাক্রো ব্যবহার করে `add_two` ফাংশন টেস্ট করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-07/src/lib.rs}}
```

</Listing>

চলুন পরীক্ষা করি এটি পাস করে কিনা!

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-07/output.txt}}
```

আমরা `result` নামে একটি ভ্যারিয়েবল তৈরি করেছি যা `add_two(2)` কল করার ফলাফল ধারণ করে। তারপর আমরা `result` এবং `4` কে `assert_eq!` ম্যাক্রোর আর্গুমেন্ট হিসেবে পাস করেছি। এই টেস্টের আউটপুট লাইনটি হলো `test tests::it_adds_two ... ok`, এবং `ok` টেক্সটটি নির্দেশ করে যে আমাদের টেস্ট পাস করেছে!

আসুন আমাদের কোডে একটি বাগ প্রবেশ করাই এবং দেখি `assert_eq!` ফেইল করলে কেমন দেখায়। `add_two` ফাংশনের ইমপ্লিমেন্টেশন পরিবর্তন করে `3` যোগ করার ব্যবস্থা করি:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/src/lib.rs:here}}
```

আবার টেস্ট চালান:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-04-bug-in-add-two/output.txt}}
```

আমাদের টেস্ট বাগটি ধরে ফেলেছে! `tests::it_adds_two` টেস্টটি ফেইল করেছে, এবং মেসেজটি আমাদের বলছে যে যে অ্যাসার্শনটি ফেইল করেছে তা হলো `left == right` এবং `left` ও `right` এর মান কী। এই মেসেজটি আমাদের ডিবাগিং শুরু করতে সাহায্য করে: `left` আর্গুমেন্ট, যেখানে `add_two(2)` কল করার ফলাফল ছিল, সেটি ছিল `5` কিন্তু `right` আর্গুমেন্ট ছিল `4`। আপনি কল্পনা করতে পারেন যে যখন আমাদের অনেকগুলো টেস্ট থাকবে তখন এটি বিশেষভাবে সহায়ক হবে।

উল্লেখ্য যে কিছু ভাষা এবং টেস্ট ফ্রেমওয়ার্কে, সমতা অ্যাসার্শন ফাংশনের প্যারামিটারগুলোকে `expected` এবং `actual` বলা হয় এবং আমরা কোন ক্রমে আর্গুমেন্টগুলো নির্দিষ্ট করি তা গুরুত্বপূর্ণ। যাইহোক, Rust-এ এগুলোকে `left` এবং `right` বলা হয় এবং আমরা প্রত্যাশিত মান এবং কোডের উৎপাদিত মানের ক্রম নির্দিষ্ট করার ক্ষেত্রে কোনো বাধ্যবাধকতা নেই। আমরা এই টেস্টের অ্যাসার্শনটি `assert_eq!(4, result)` হিসেবেও লিখতে পারতাম, যা একই ফেইলার মেসেজ দিত যা `` assertion `left == right` failed`` প্রদর্শন করে।

`assert_ne!` ম্যাক্রো পাস করবে যদি আমরা দেওয়া দুটি মান সমান না হয় এবং ফেইল করবে যদি তারা সমান হয়। এই ম্যাক্রোটি সেইসব ক্ষেত্রে সবচেয়ে কার্যকর যখন আমরা নিশ্চিত নই যে একটি মান কী _হবে_, কিন্তু আমরা জানি যে মানটি নিশ্চিতভাবে কী _হওয়া উচিত নয়_। উদাহরণস্বরূপ, যদি আমরা এমন একটি ফাংশন টেস্ট করি যা তার ইনপুটকে কোনোভাবে পরিবর্তন করার গ্যারান্টি দেয়, কিন্তু ইনপুটটি কোন উপায়ে পরিবর্তিত হবে তা সপ্তাহের কোন দিনে আমরা টেস্ট চালাচ্ছি তার উপর নির্ভর করে, তবে সবচেয়ে ভালো অ্যাসার্শন হতে পারে যে ফাংশনের আউটপুট ইনপুটের সমান নয়।

ভিতরে ভিতরে, `assert_eq!` এবং `assert_ne!` ম্যাক্রোগুলো যথাক্রমে `==` এবং `!=` অপারেটর ব্যবহার করে। যখন অ্যাসার্শন ফেইল করে, তখন এই ম্যাক্রোগুলো ডিবাগ ফরম্যাটিং ব্যবহার করে তাদের আর্গুমেন্ট প্রিন্ট করে, যার মানে হলো তুলনা করা মানগুলোকে অবশ্যই `PartialEq` এবং `Debug` ট্রেইট ইমপ্লিমেন্ট করতে হবে। সমস্ত প্রিমিটিভ টাইপ এবং স্ট্যান্ডার্ড লাইব্রেরির বেশিরভাগ টাইপ এই ট্রেইটগুলো ইমপ্লিমেন্ট করে। আপনার নিজের ডিফাইন করা struct এবং enum-এর জন্য, সেই টাইপগুলোর সমতা অ্যাসার্ট করতে আপনাকে `PartialEq` ইমপ্লিমেন্ট করতে হবে। অ্যাসার্শন ফেইল করলে মানগুলো প্রিন্ট করার জন্য আপনাকে `Debug` ইমপ্লিমেন্ট করতে হবে। যেহেতু উভয়ই ডিরাইভেবল ট্রেইট (derivable traits), যেমনটি অধ্যায় ৫ এর তালিকা ৫-১২ তে উল্লেখ করা হয়েছে, এটি সাধারণত আপনার struct বা enum ডেফিনিশনে `#[derive(PartialEq, Debug)]` অ্যানোটেশন যোগ করার মতোই সহজ। এই এবং অন্যান্য ডিরাইভেবল ট্রেইট সম্পর্কে আরও বিস্তারিত জানতে পরিশিষ্ট C, [“Derivable Traits,”][derivable-traits]<!-- ignore --> দেখুন।

### কাস্টম ফেইলার মেসেজ যোগ করা

আপনি `assert!`, `assert_eq!`, এবং `assert_ne!` ম্যাক্রোগুলোতে ঐচ্ছিক আর্গুমেন্ট হিসেবে ফেইলার মেসেজের সাথে প্রিন্ট করার জন্য একটি কাস্টম মেসেজও যোগ করতে পারেন। প্রয়োজনীয় আর্গুমেন্টের পরে নির্দিষ্ট করা যেকোনো আর্গুমেন্ট `format!` ম্যাক্রোতে (অধ্যায় ৮-এর [“Concatenation with the `+` Operator or the `format!` Macro”][concatenation-with-the--operator-or-the-format-macro]<!-- ignore --> বিভাগে আলোচিত) পাস করা হয়, তাই আপনি একটি ফরম্যাট স্ট্রিং পাস করতে পারেন যাতে `{}` প্লেসহোল্ডার এবং সেই প্লেসহোল্ডারে যাওয়ার জন্য মান থাকে। কাস্টম মেসেজ একটি অ্যাসার্শনের অর্থ নথিভুক্ত করার জন্য কার্যকর; যখন একটি টেস্ট ফেইল করে, তখন কোডের সমস্যাটি কী সে সম্পর্কে আপনার একটি ভালো ধারণা থাকবে।

উদাহরণস্বরূপ, ধরা যাক আমাদের এমন একটি ফাংশন আছে যা নাম ধরে লোকেদের সম্ভাষণ জানায় এবং আমরা টেস্ট করতে চাই যে আমরা ফাংশনে যে নামটি পাস করছি তা আউটপুটে প্রদর্শিত হচ্ছে কিনা:

<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-05-greeter/src/lib.rs}}
```

এই প্রোগ্রামের প্রয়োজনীয়তা এখনও ঠিক হয়নি, এবং আমরা প্রায় নিশ্চিত যে সম্ভাষণের শুরুতে থাকা `Hello` টেক্সট পরিবর্তন হবে। আমরা সিদ্ধান্ত নিয়েছি যে প্রয়োজনীয়তা পরিবর্তিত হলে আমাদের টেস্ট আপডেট করতে হবে না, তাই `greeting` ফাংশন থেকে ফিরে আসা মানের সাথে হুবহু সমতা পরীক্ষা করার পরিবর্তে, আমরা কেবল অ্যাসার্ট করব যে আউটপুট ইনপুট প্যারামিটারের টেক্সট ধারণ করে।

এখন এই কোডে একটি বাগ প্রবেশ করাই `greeting` ফাংশন পরিবর্তন করে `name` বাদ দিয়ে, যাতে ডিফল্ট টেস্ট ফেইলার কেমন দেখায় তা দেখতে পারি:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/src/lib.rs:here}}
```

এই টেস্টটি চালালে নিম্নলিখিত ফলাফল পাওয়া যায়:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-06-greeter-with-bug/output.txt}}
```

এই ফলাফলটি কেবল নির্দেশ করে যে অ্যাসার্শনটি ফেইল করেছে এবং অ্যাসার্শনটি কোন লাইনে আছে। একটি আরও দরকারী ফেইলার মেসেজ `greeting` ফাংশন থেকে প্রাপ্ত মানটি প্রিন্ট করত। আসুন আমরা একটি কাস্টম ফেইলার মেসেজ যোগ করি যা একটি ফরম্যাট স্ট্রিং এবং `greeting` ফাংশন থেকে প্রাপ্ত আসল মান দিয়ে পূরণ করা একটি প্লেসহোল্ডার নিয়ে গঠিত:

```rust,ignore
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/src/lib.rs:here}}
```

এখন যখন আমরা টেস্টটি চালাব, আমরা একটি আরও তথ্যপূর্ণ ত্রুটি বার্তা পাব:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-07-custom-failure-message/output.txt}}
```

আমরা টেস্ট আউটপুটে আসলে যে মানটি পেয়েছি তা দেখতে পাচ্ছি, যা আমাদের প্রত্যাশার পরিবর্তে কী ঘটেছে তা ডিবাগ করতে সাহায্য করবে।

### `should_panic` দিয়ে প্যানিক পরীক্ষা করা

রিটার্ন ভ্যালু পরীক্ষা করার পাশাপাশি, আমাদের কোড প্রত্যাশা অনুযায়ী ত্রুটির শর্তগুলো পরিচালনা করছে কিনা তা পরীক্ষা করাও গুরুত্বপূর্ণ। উদাহরণস্বরূপ, `Guess` টাইপটি বিবেচনা করুন যা আমরা অধ্যায় ৯, তালিকা ৯-১৩-এ তৈরি করেছি। `Guess` ব্যবহারকারী অন্যান্য কোড এই গ্যারান্টির উপর নির্ভর করে যে `Guess` ইনস্ট্যান্সগুলিতে শুধুমাত্র ১ থেকে ১০০ এর মধ্যে মান থাকবে। আমরা এমন একটি টেস্ট লিখতে পারি যা নিশ্চিত করে যে সেই সীমার বাইরের কোনো মান দিয়ে একটি `Guess` ইনস্ট্যান্স তৈরি করার চেষ্টা করলে তা প্যানিক করে।

আমরা আমাদের টেস্ট ফাংশনে `should_panic` অ্যাট্রিবিউট যোগ করে এটি করি। যদি ফাংশনের ভিতরের কোড প্যানিক করে তবে টেস্টটি পাস করে; যদি ফাংশনের ভিতরের কোড প্যানিক না করে তবে টেস্টটি ফেইল করে।

তালিকা ১১-৮ একটি টেস্ট দেখায় যা পরীক্ষা করে যে `Guess::new` এর ত্রুটির শর্তগুলো আমাদের প্রত্যাশা অনুযায়ী ঘটে কিনা।

<Listing number="11-8" file-name="src/lib.rs" caption="একটি শর্ত `panic!` ঘটাবে কিনা তা পরীক্ষা করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-08/src/lib.rs}}
```

</Listing>

আমরা `#[should_panic]` অ্যাট্রিবিউটটি `#[test]` অ্যাট্রিবিউটের পরে এবং যে টেস্ট ফাংশনে এটি প্রযোজ্য তার আগে স্থাপন করি। আসুন দেখি এই টেস্টটি পাস করলে ফলাফল কেমন হয়:

```console
{{#include ../listings/ch11-writing-automated-tests/listing-11-08/output.txt}}
```

বেশ ভালো দেখাচ্ছে! এখন আমাদের কোডে একটি বাগ প্রবেশ করাই `new` ফাংশনের সেই শর্তটি সরিয়ে দিয়ে যা বলে যে মান ১০০ এর বেশি হলে ফাংশনটি প্যানিক করবে:

```rust,not_desired_behavior,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/src/lib.rs:here}}
```

যখন আমরা তালিকা ১১-৮-এর টেস্টটি চালাই, তখন এটি ফেইল করবে:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-08-guess-with-bug/output.txt}}
```

এক্ষেত্রে আমরা খুব সহায়ক বার্তা পাই না, কিন্তু যখন আমরা টেস্ট ফাংশনটি দেখি, তখন আমরা দেখতে পাই যে এটি `#[should_panic]` দিয়ে অ্যানোটেটেড। আমরা যে ফেইলার পেয়েছি তার মানে হল টেস্ট ফাংশনের কোডটি প্যানিক ঘটায়নি।

`should_panic` ব্যবহার করা টেস্টগুলো অসম্পূর্ণ হতে পারে। একটি `should_panic` টেস্ট পাস করতে পারত এমনকি যদি টেস্টটি আমাদের প্রত্যাশিত কারণের থেকে ভিন্ন কোনো কারণে প্যানিক করত। `should_panic` টেস্টগুলোকে আরও সুনির্দিষ্ট করতে, আমরা `should_panic` অ্যাট্রিবিউটে একটি ঐচ্ছিক `expected` প্যারামিটার যোগ করতে পারি। টেস্ট হারনেস নিশ্চিত করবে যে ফেইলার মেসেজটিতে প্রদত্ত টেক্সট রয়েছে। উদাহরণস্বরূপ, তালিকা ১১-৯-এ `Guess`-এর পরিবর্তিত কোডটি বিবেচনা করুন যেখানে `new` ফাংশনটি মানটি খুব ছোট বা খুব বড় হওয়ার উপর নির্ভর করে বিভিন্ন মেসেজ দিয়ে প্যানিক করে।

<Listing number="11-9" file-name="src/lib.rs" caption="একটি নির্দিষ্ট সাবস্ট্রিং ধারণকারী প্যানিক মেসেজ দিয়ে `panic!`-এর জন্য পরীক্ষা করা">

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/listing-11-09/src/lib.rs:here}}
```

</Listing>

এই টেস্টটি পাস করবে কারণ `should_panic` অ্যাট্রিবিউটের `expected` প্যারামিটারে আমরা যে মানটি রেখেছি তা `Guess::new` ফাংশন যে মেসেজ দিয়ে প্যানিক করে তার একটি সাবস্ট্রিং। আমরা প্রত্যাশিত সম্পূর্ণ প্যানিক মেসেজটিও নির্দিষ্ট করতে পারতাম, যা এক্ষেত্রে `Guess value must be less than or equal to 100, got 200` হতো। আপনি কী নির্দিষ্ট করতে চান তা নির্ভর করে প্যানিক মেসেজের কতটা অংশ অনন্য বা ডাইনামিক এবং আপনি আপনার টেস্টকে কতটা সুনির্দিষ্ট করতে চান তার উপর। এক্ষেত্রে, প্যানিক মেসেজের একটি সাবস্ট্রিংই নিশ্চিত করার জন্য যথেষ্ট যে টেস্ট ফাংশনের কোডটি `else if value > 100` কেসটি এক্সিকিউট করে।

একটি `expected` মেসেজসহ `should_panic` টেস্ট ফেইল করলে কী হয় তা দেখতে, আসুন `if value < 1` এবং `else if value > 100` ব্লকগুলোর বডি অদলবদল করে আমাদের কোডে আবার একটি বাগ প্রবেশ করাই:

```rust,ignore,not_desired_behavior
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/src/lib.rs:here}}
```

এবার যখন আমরা `should_panic` টেস্টটি চালাই, তখন এটি ফেইল করবে:

```console
{{#include ../listings/ch11-writing-automated-tests/no-listing-09-guess-with-panic-msg-bug/output.txt}}
```

ফেইলার মেসেজটি নির্দেশ করে যে এই টেস্টটি আমাদের প্রত্যাশা অনুযায়ী প্যানিক করেছিল, কিন্তু প্যানিক মেসেজটিতে প্রত্যাশিত স্ট্রিং `less than or equal to 100` অন্তর্ভুক্ত ছিল না। এক্ষেত্রে আমরা যে প্যানিক মেসেজটি পেয়েছি তা হল `Guess value must be greater than or equal to 1, got 200.` এখন আমরা আমাদের বাগ কোথায় তা খুঁজে বের করা শুরু করতে পারি!

### টেস্টে `Result<T, E>` ব্যবহার করা

আমাদের এ পর্যন্ত সব টেস্ট ফেইল করলে প্যানিক করে। আমরা এমন টেস্টও লিখতে পারি যা `Result<T, E>` ব্যবহার করে! এখানে তালিকা ১১-১ থেকে টেস্টটি `Result<T, E>` ব্যবহার করে এবং প্যানিক করার পরিবর্তে একটি `Err` রিটার্ন করার জন্য পুনরায় লেখা হয়েছে:

```rust,noplayground
{{#rustdoc_include ../listings/ch11-writing-automated-tests/no-listing-10-result-in-tests/src/lib.rs:here}}
```

`it_works` ফাংশনটির এখন `Result<(), String>` রিটার্ন টাইপ রয়েছে। ফাংশনের বডিতে, `assert_eq!` ম্যাক্রো কল করার পরিবর্তে, আমরা টেস্ট পাস করলে `Ok(())` এবং টেস্ট ফেইল করলে একটি `String` সহ `Err` রিটার্ন করি।

টেস্ট এমনভাবে লেখা যাতে তারা একটি `Result<T, E>` রিটার্ন করে, তা আপনাকে টেস্টের বডিতে প্রশ্নবোধক চিহ্ন অপারেটর (?) ব্যবহার করতে সক্ষম করে, যা এমন টেস্ট লেখার জন্য একটি সুবিধাজনক উপায় হতে পারে যা তাদের মধ্যে কোনো অপারেশন `Err` ভ্যারিয়েন্ট রিটার্ন করলে ফেইল করা উচিত।

`Result<T, E>` ব্যবহার করা টেস্টে আপনি `#[should_panic]` অ্যানোটেশন ব্যবহার করতে পারবেন না। কোনো অপারেশন একটি `Err` ভ্যারিয়েন্ট রিটার্ন করে তা অ্যাসার্ট করতে, `Result<T, E>` মানের উপর প্রশ্নবোধক চিহ্ন অপারেটর ব্যবহার _করবেন না_। পরিবর্তে, `assert!(value.is_err())` ব্যবহার করুন।

এখন যেহেতু আপনি টেস্ট লেখার বিভিন্ন উপায় জানেন, আসুন দেখি আমাদের টেস্ট চালানোর সময় কী ঘটছে এবং `cargo test` এর সাথে আমরা যে বিভিন্ন অপশন ব্যবহার করতে পারি তা অন্বেষণ করি।

[concatenation-with-the--operator-or-the-format-macro]: ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro
[bench]: ../unstable-book/library-features/test.html
[ignoring]: ch11-02-running-tests.html#ignoring-some-tests-unless-specifically-requested
[subset]: ch11-02-running-tests.html#running-a-subset-of-tests-by-name
[controlling-how-tests-are-run]: ch11-02-running-tests.html#controlling-how-tests-are-run
[derivable-traits]: appendix-03-derivable-traits.html
[doc-comments]: ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests
[paths-for-referring-to-an-item-in-the-module-tree]: ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html