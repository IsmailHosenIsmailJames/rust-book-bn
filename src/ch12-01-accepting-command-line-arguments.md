## কমান্ড লাইন আর্গুমেন্ট গ্রহণ করা

আসুন, যথারীতি, `cargo new` দিয়ে একটি নতুন প্রজেক্ট তৈরি করি। আমাদের প্রজেক্টটিকে `minigrep` বলব যাতে এটি আপনার সিস্টেমে থাকা `grep` টুল থেকে আলাদা হয়।

```console
$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
```

প্রথম কাজটি হল `minigrep`-কে এর দুটি কমান্ড লাইন আর্গুমেন্ট গ্রহণ করানো: ফাইলের পাথ এবং অনুসন্ধানের জন্য একটি স্ট্রিং। অর্থাৎ, আমরা আমাদের প্রোগ্রামটিকে `cargo run`, দুটি হাইফেন দিয়ে চালানোর ক্ষমতা চাই যাতে বোঝা যায় যে নিম্নলিখিত আর্গুমেন্টগুলো `cargo`-এর জন্য নয় বরং আমাদের প্রোগ্রামের জন্য, একটি অনুসন্ধানের স্ট্রিং এবং একটি ফাইল পাথ যেটিতে অনুসন্ধান করতে হবে, যেমন:

```console
$ cargo run -- searchstring example-filename.txt
```

এই মুহূর্তে, `cargo new` দ্বারা জেনারেট করা প্রোগ্রামটি আমরা এটিকে দেওয়া আর্গুমেন্টগুলো প্রক্রিয়া করতে পারে না। [crates.io](https://crates.io/)-এর কিছু বিদ্যমান লাইব্রেরি কমান্ড লাইন আর্গুমেন্ট গ্রহণ করে এমন একটি প্রোগ্রাম লিখতে সাহায্য করতে পারে, তবে যেহেতু আপনি এই ধারণাটি শিখছেন, তাই আসুন আমরা নিজেরাই এই ক্ষমতাটি প্রয়োগ করি।

### আর্গুমেন্টের ভ্যালুগুলো পড়া

`minigrep`-কে আমরা যে কমান্ড লাইন আর্গুমেন্টগুলো পাস করি তার ভ্যালুগুলো পড়তে সক্ষম করার জন্য, আমাদের রাস্টের স্ট্যান্ডার্ড লাইব্রেরিতে দেওয়া `std::env::args` ফাংশনটির প্রয়োজন হবে। এই ফাংশনটি `minigrep`-এ পাস করা কমান্ড লাইন আর্গুমেন্টগুলোর একটি ইটারেটর রিটার্ন করে। আমরা [Chapter 13][ch13]<!-- ignore -->-এ ইটারেটরগুলো সম্পূর্ণরূপে আলোচনা করব। আপাতত, আপনাকে ইটারেটর সম্পর্কে শুধুমাত্র দুটি বিশদ জানতে হবে: ইটারেটরগুলো ভ্যালুর একটি সিরিজ তৈরি করে এবং ইটারেটর দ্বারা তৈরি করা সমস্ত উপাদান ধারণ করে এমন একটি ভেক্টর, যেমন একটি সংগ্রহে রূপান্তর করার জন্য আমরা একটি ইটারেটরের উপর `collect` মেথড কল করতে পারি।

Listing 12-1-এর কোডটি আপনার `minigrep` প্রোগ্রামকে এর কাছে পাস করা যেকোনো কমান্ড লাইন আর্গুমেন্ট পড়তে এবং তারপরে ভ্যালুগুলোকে একটি ভেক্টরে সংগ্রহ করতে দেয়।

<Listing number="12-1" file-name="src/main.rs" caption="কমান্ড লাইন আর্গুমেন্টগুলোকে একটি ভেক্টরে সংগ্রহ করা এবং সেগুলোকে প্রিন্ট করা">

```rust
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-01/src/main.rs}}
```

</Listing>

প্রথমে আমরা `use` স্টেটমেন্ট দিয়ে `std::env` মডিউলটিকে স্কোপে আনি যাতে আমরা এর `args` ফাংশন ব্যবহার করতে পারি। লক্ষ্য করুন যে `std::env::args` ফাংশনটি দুটি স্তরের মডিউলের মধ্যে নেস্ট করা আছে। আমরা [Chapter 7][ch7-idiomatic-use]<!-- ignore -->-এ আলোচনা করেছি, যেখানে কাঙ্ক্ষিত ফাংশনটি একাধিক মডিউলে নেস্ট করা থাকে, সেখানে আমরা ফাংশনের পরিবর্তে প্যারেন্ট মডিউলটিকে স্কোপে আনার সিদ্ধান্ত নিয়েছি। এটি করার মাধ্যমে, আমরা সহজেই `std::env` থেকে অন্যান্য ফাংশন ব্যবহার করতে পারি। `use std::env::args` যোগ করে এবং তারপর শুধু `args` দিয়ে ফাংশন কল করার চেয়ে এটি কম অস্পষ্ট, কারণ `args` সহজেই বর্তমান মডিউলে সংজ্ঞায়িত একটি ফাংশন হিসাবে ভুল হতে পারে।

> ### `args` ফাংশন এবং অবৈধ ইউনিকোড
>
> মনে রাখবেন যে যদি কোনো আর্গুমেন্টে অবৈধ ইউনিকোড থাকে তবে `std::env::args` প্যানিক করবে। যদি আপনার প্রোগ্রামকে অবৈধ ইউনিকোড ধারণকারী আর্গুমেন্ট গ্রহণ করতে হয়, তাহলে পরিবর্তে `std::env::args_os` ব্যবহার করুন। সেই ফাংশনটি একটি ইটারেটর রিটার্ন করে যা `String` ভ্যালুর পরিবর্তে `OsString` ভ্যালু তৈরি করে। আমরা এখানে সরলতার জন্য `std::env::args` ব্যবহার করতে বেছে নিয়েছি কারণ `OsString` ভ্যালুগুলো প্রতি প্ল্যাটফর্মে ভিন্ন এবং `String` ভ্যালুর চেয়ে কাজ করা আরও জটিল।

`main`-এর প্রথম লাইনে, আমরা `env::args` কল করি এবং আমরা অবিলম্বে ইটারেটর দ্বারা তৈরি করা সমস্ত ভ্যালু ধারণকারী একটি ভেক্টরে ইটারেটরটিকে রূপান্তর করতে `collect` ব্যবহার করি। আমরা `collect` ফাংশনটি বিভিন্ন ধরণের সংগ্রহ তৈরি করতে ব্যবহার করতে পারি, তাই আমরা স্পষ্টভাবে `args`-এর টাইপ টীকা করি যাতে নির্দিষ্ট করা যায় যে আমরা স্ট্রিংগুলোর একটি ভেক্টর চাই। যদিও রাস্টে আপনাকে খুব কমই টাইপ টীকা করতে হয়, `collect` হল এমন একটি ফাংশন যা আপনাকে প্রায়শই টীকা করতে হয় কারণ রাস্ট আপনি যে ধরনের সংগ্রহ চান তা অনুমান করতে সক্ষম নয়।

অবশেষে, আমরা ডিবাগ ম্যাক্রো ব্যবহার করে ভেক্টরটি প্রিন্ট করি। আসুন প্রথমে কোনো আর্গুমেন্ট ছাড়াই এবং তারপরে দুটি আর্গুমেন্ট দিয়ে কোডটি চালানোর চেষ্টা করি:

```console
{{#include ../listings/ch12-an-io-project/listing-12-01/output.txt}}
```

```console
{{#include ../listings/ch12-an-io-project/output-only-01-with-args/output.txt}}
```

লক্ষ্য করুন যে ভেক্টরের প্রথম ভ্যালুটি হল `"target/debug/minigrep"`, যা আমাদের বাইনারির নাম। এটি C-এর আর্গুমেন্ট তালিকার আচরণের সাথে মেলে, প্রোগ্রামগুলোকে তাদের নির্বাহে তারা যে নামে আহ্বান করা হয়েছে তা ব্যবহার করতে দেয়। আপনি বার্তাগুলোতে এটি প্রিন্ট করতে বা প্রোগ্রামটি আহ্বান করার জন্য ব্যবহৃত কমান্ড লাইন অ্যালিয়াসের উপর ভিত্তি করে প্রোগ্রামের আচরণ পরিবর্তন করতে চাইলে প্রোগ্রামের নামে অ্যাক্সেস পাওয়া প্রায়শই সুবিধাজনক। তবে এই অধ্যায়ের উদ্দেশ্যে, আমরা এটিকে উপেক্ষা করব এবং আমাদের প্রয়োজনীয় দুটি আর্গুমেন্টই শুধুমাত্র রাখব।

### ভেরিয়েবলে আর্গুমেন্টের ভ্যালুগুলো সেভ করা

প্রোগ্রামটি বর্তমানে কমান্ড লাইন আর্গুমেন্ট হিসাবে নির্দিষ্ট করা ভ্যালুগুলো অ্যাক্সেস করতে সক্ষম। এখন আমাদের দুটি আর্গুমেন্টের ভ্যালু ভেরিয়েবলে সেভ করতে হবে যাতে আমরা প্রোগ্রামের বাকি অংশে ভ্যালুগুলো ব্যবহার করতে পারি। আমরা Listing 12-2-এ তা করি।

<Listing number="12-2" file-name="src/main.rs" caption="ভেরিয়েবল তৈরি করে কোয়েরি আর্গুমেন্ট এবং ফাইল পাথ আর্গুমেন্ট ধারণ করা">

```rust,should_panic,noplayground
{{#rustdoc_include ../listings/ch12-an-io-project/listing-12-02/src/main.rs}}
```

</Listing>

আমরা ভেক্টরটি প্রিন্ট করার সময় দেখেছি, প্রোগ্রামের নামটি `args[0]`-এ ভেক্টরের প্রথম ভ্যালুটি নেয়, তাই আমরা 1 নম্বর ইনডেক্স থেকে আর্গুমেন্টগুলো শুরু করছি। `minigrep` যে প্রথম আর্গুমেন্টটি নেয় তা হল সেই স্ট্রিংটি যা আমরা খুঁজছি, তাই আমরা প্রথম আর্গুমেন্টের একটি রেফারেন্স `query` ভেরিয়েবলে রাখি। দ্বিতীয় আর্গুমেন্টটি ফাইলের পাথ হবে, তাই আমরা দ্বিতীয় আর্গুমেন্টের একটি রেফারেন্স `file_path` ভেরিয়েবলে রাখি।

কোডটি আমাদের উদ্দেশ্য অনুযায়ী কাজ করছে কিনা তা প্রমাণ করার জন্য আমরা অস্থায়ীভাবে এই ভেরিয়েবলগুলোর ভ্যালু প্রিন্ট করি। আসুন আমরা `test` এবং `sample.txt` আর্গুমেন্টগুলো দিয়ে আবার এই প্রোগ্রামটি চালাই:

```console
{{#include ../listings/ch12-an-io-project/listing-12-02/output.txt}}
```

চমৎকার, প্রোগ্রামটি কাজ করছে! আমাদের প্রয়োজনীয় আর্গুমেন্টের ভ্যালুগুলো সঠিক ভেরিয়েবলে সেভ করা হচ্ছে। পরে আমরা কিছু সম্ভাব্য ভুল পরিস্থিতি মোকাবেলা করার জন্য কিছু এরর হ্যান্ডলিং যোগ করব, যেমন যখন ব্যবহারকারী কোনো আর্গুমেন্ট প্রদান না করে; আপাতত, আমরা সেই পরিস্থিতিটি উপেক্ষা করব এবং পরিবর্তে ফাইল-পড়ার ক্ষমতা যোগ করার দিকে কাজ করব।

[ch13]: ch13-00-functional-features.html
[ch7-idiomatic-use]: ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths
