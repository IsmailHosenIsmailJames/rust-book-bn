## `Send` এবং `Sync` ট্রেইট দিয়ে এক্সটেনসিবল কনকারেন্সি

<!-- Old link, do not remove -->

<a id="extensible-concurrency-with-the-sync-and-send-traits"></a>

মজার ব্যাপার হলো, এই অধ্যায়ে আমরা এখন পর্যন্ত যে সমস্ত কনকারেন্সি ফিচার নিয়ে আলোচনা করেছি, তার প্রায় সবগুলোই স্ট্যান্ডার্ড লাইব্রেরির অংশ ছিল, ল্যাঙ্গুয়েজের নয়। আপনার কনকারেন্সি পরিচালনা করার বিকল্পগুলো ল্যাঙ্গুয়েজ বা স্ট্যান্ডার্ড লাইব্রেরির মধ্যে সীমাবদ্ধ নয়; আপনি আপনার নিজের কনকারেন্সি ফিচার লিখতে পারেন বা অন্যদের লেখা ফিচার ব্যবহার করতে পারেন।

তবে, যে মূল কনকারেন্সি ধারণাগুলো স্ট্যান্ডার্ড লাইব্রেরির পরিবর্তে ল্যাঙ্গুয়েজে এম্বেড করা আছে, তার মধ্যে রয়েছে `std::marker` ট্রেইট `Send` এবং `Sync`।

### `Send` দিয়ে থ্রেডের মধ্যে মালিকানা স্থানান্তরের অনুমতি দেওয়া

`Send` মার্কার ট্রেইটটি নির্দেশ করে যে `Send` ইমপ্লিমেন্ট করা টাইপের ভ্যালুগুলোর মালিকানা থ্রেডের মধ্যে স্থানান্তর করা যেতে পারে। প্রায় প্রতিটি Rust টাইপ `Send` ইমপ্লিমেন্ট করে, তবে কিছু ব্যতিক্রম আছে, যার মধ্যে `Rc<T>` অন্তর্ভুক্ত: এটি `Send` ইমপ্লিমেন্ট করতে পারে না কারণ আপনি যদি একটি `Rc<T>` ভ্যালু ক্লোন করেন এবং ক্লোনটির মালিকানা অন্য থ্রেডে স্থানান্তর করার চেষ্টা করেন, তবে উভয় থ্রেড একই সাথে রেফারেন্স কাউন্ট আপডেট করতে পারে। এই কারণে, `Rc<T>` একক-থ্রেডেড পরিস্থিতিতে ব্যবহারের জন্য ইমপ্লিমেন্ট করা হয়েছে যেখানে আপনি থ্রেড-সেফ পারফরম্যান্স পেনাল্টি দিতে চান না।

অতএব, Rust-এর টাইপ সিস্টেম এবং ট্রেইট বাউন্ডস নিশ্চিত করে যে আপনি কখনও ভুলবশত একটি `Rc<T>` ভ্যালু অনিরাপদভাবে থ্রেডের মধ্যে পাঠাতে পারবেন না। যখন আমরা তালিকা ১৬-১৪-এ এটি করার চেষ্টা করেছিলাম, তখন আমরা `` the trait `Send` is not implemented for `Rc<Mutex<i32>>` `` এই এররটি পেয়েছিলাম। যখন আমরা `Arc<T>`-এ স্যুইচ করেছিলাম, যা `Send` ইমপ্লিমেন্ট করে, কোডটি কম্পাইল হয়েছিল।

সম্পূর্ণরূপে `Send` টাইপ দ্বারা গঠিত যেকোনো টাইপ স্বয়ংক্রিয়ভাবে `Send` হিসাবে চিহ্নিত হয়। কাঁচা পয়েন্টার (raw pointers) ছাড়া প্রায় সব প্রিমিটিভ টাইপই `Send`, যা আমরা অধ্যায় ২০-এ আলোচনা করব।

### `Sync` দিয়ে একাধিক থ্রেড থেকে অ্যাক্সেসের অনুমতি দেওয়া

`Sync` মার্কার ট্রেইটটি নির্দেশ করে যে `Sync` ইমপ্লিমেন্ট করা টাইপটিকে একাধিক থ্রেড থেকে রেফারেন্স করা নিরাপদ। অন্য কথায়, যেকোনো টাইপ `T` `Sync` ইমপ্লিমেন্ট করে যদি `&T` (`T`-এর একটি অপরিবর্তনীয় রেফারেন্স) `Send` ইমপ্লিমেন্ট করে, যার মানে রেফারেন্সটি নিরাপদে অন্য থ্রেডে পাঠানো যেতে পারে। `Send`-এর মতো, প্রিমিটিভ টাইপগুলো সবই `Sync` ইমপ্লিমেন্ট করে, এবং যে টাইপগুলো সম্পূর্ণরূপে `Sync` ইমপ্লিমেন্ট করা টাইপ দ্বারা গঠিত সেগুলোও `Sync` ইমপ্লিমেন্ট করে।

স্মার্ট পয়েন্টার `Rc<T>` ও `Sync` ইমপ্লিমেন্ট করে না সেই একই কারণে যে এটি `Send` ইমপ্লিমেন্ট করে না। `RefCell<T>` টাইপ (যা আমরা অধ্যায় ১৫-এ আলোচনা করেছি) এবং সম্পর্কিত `Cell<T>` টাইপের পরিবার `Sync` ইমপ্লিমেন্ট করে না। `RefCell<T>` রানটাইমে যে ধার পরীক্ষা (borrow checking) প্রয়োগ করে তা থ্রেড-সেফ নয়। স্মার্ট পয়েন্টার `Mutex<T>` `Sync` ইমপ্লিমেন্ট করে এবং একাধিক থ্রেডের সাথে অ্যাক্সেস শেয়ার করতে ব্যবহার করা যেতে পারে, যেমনটি আপনি ["Sharing a `Mutex<T>` Between Multiple Threads"][sharing-a-mutext-between-multiple-threads]<!-- ignore --> বিভাগে দেখেছেন।

### `Send` এবং `Sync` ম্যানুয়ালি ইমপ্লিমেন্ট করা অনিরাপদ

যেহেতু যে টাইপগুলো সম্পূর্ণরূপে `Send` এবং `Sync` ট্রেইট ইমপ্লিমেন্ট করা অন্য টাইপ দ্বারা গঠিত সেগুলোও স্বয়ংক্রিয়ভাবে `Send` এবং `Sync` ইমপ্লিমেন্ট করে, তাই আমাদের সেই ট্রেইটগুলো ম্যানুয়ালি ইমপ্লিমেন্ট করতে হয় না। মার্কার ট্রেইট হিসাবে, তাদের ইমপ্লিমেন্ট করার জন্য কোনো মেথডও নেই। তারা শুধু কনকারেন্সি সম্পর্কিত ইনভ্যারিয়েন্টগুলো প্রয়োগ করার জন্য দরকারি।

এই ট্রেইটগুলো ম্যানুয়ালি ইমপ্লিমেন্ট করার জন্য অনিরাপদ (unsafe) Rust কোড ইমপ্লিমেন্ট করতে হয়। আমরা অধ্যায় ২০-এ অনিরাপদ Rust কোড ব্যবহার করার বিষয়ে কথা বলব; আপাতত, গুরুত্বপূর্ণ তথ্য হলো `Send` এবং `Sync` অংশ দ্বারা গঠিত নয় এমন নতুন কনকারেন্ট টাইপ তৈরি করার জন্য সেফটি গ্যারান্টি বজায় রাখার জন্য সতর্ক চিন্তাভাবনার প্রয়োজন। ["The Rustonomicon"][nomicon] এই গ্যারান্টিগুলো এবং কীভাবে সেগুলো বজায় রাখতে হয় সে সম্পর্কে আরও তথ্য রয়েছে।

## সারসংক্ষেপ

এই বইয়ে আপনি কনকারেন্সি নিয়ে শেষবারের মতো দেখছেন না: পরবর্তী অধ্যায়টি অ্যাসিঙ্ক প্রোগ্রামিংয়ের উপর আলোকপাত করে, এবং অধ্যায় ২১-এর প্রকল্পটি এই অধ্যায়ের ধারণাগুলো এখানে আলোচনা করা ছোট উদাহরণগুলোর চেয়ে আরও বাস্তবসম্মত পরিস্থিতিতে ব্যবহার করবে।

যেমন আগে উল্লেখ করা হয়েছে, যেহেতু Rust যেভাবে কনকারেন্সি পরিচালনা করে তার খুব কম অংশই ল্যাঙ্গুয়েজের অংশ, তাই অনেক কনকারেন্সি সলিউশন ক্রেট হিসাবে ইমপ্লিমেন্ট করা হয়। এগুলো স্ট্যান্ডার্ড লাইব্রেরির চেয়ে দ্রুত বিকশিত হয়, তাই মাল্টিথ্রেডেড পরিস্থিতিতে ব্যবহারের জন্য বর্তমান, অত্যাধুনিক ক্রেটগুলোর জন্য অনলাইনে অনুসন্ধান করতে ভুলবেন না।

Rust স্ট্যান্ডার্ড লাইব্রেরি মেসেজ পাসিংয়ের জন্য চ্যানেল এবং স্মার্ট পয়েন্টার টাইপ, যেমন `Mutex<T>` এবং `Arc<T>`, সরবরাহ করে যা কনকারেন্ট প্রেক্ষাপটে ব্যবহার করা নিরাপদ। টাইপ সিস্টেম এবং বোরো চেকার নিশ্চিত করে যে এই সলিউশনগুলো ব্যবহার করা কোডে ডেটা রেস বা অবৈধ রেফারেন্স থাকবে না। একবার আপনি আপনার কোড কম্পাইল করতে পারলে, আপনি নিশ্চিন্ত থাকতে পারেন যে এটি একাধিক থ্রেডে সুখে চলবে এবং অন্য ল্যাঙ্গুয়েজে সাধারণ এমন কঠিন-থেকে-ট্র্যাক-ডাউন করা বাগগুলো থাকবে না। কনকারেন্ট প্রোগ্রামিং আর ভয়ের কোনো ধারণা নয়: নির্ভীকভাবে এগিয়ে যান এবং আপনার প্রোগ্রামগুলোকে কনকারেন্ট করুন!

[sharing-a-mutext-between-multiple-threads]: ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads
[nomicon]: ../nomicon/index.html