## Hello, world!

এখন যেহেতু আপনি রাস্ট ইনস্টল করেছেন, আপনার প্রথম রাস্ট প্রোগ্রাম লেখার সময় এসেছে। নতুন কোনো ভাষা শেখার সময় স্ক্রিনে `Hello, world!` টেক্সট প্রিন্ট করে এমন একটি ছোট প্রোগ্রাম লেখা একটি ঐতিহ্য, তাই আমরাও এখানে তাই করব!

> দ্রষ্টব্য: এই বইটিতে কমান্ড লাইনের সাথে প্রাথমিক পরিচিতি আছে বলে ধরে নেওয়া হয়েছে। রাস্ট আপনার এডিটিং, টুলিং বা আপনার কোড কোথায় থাকবে সে সম্পর্কে কোনো নির্দিষ্ট চাহিদা রাখে না, তাই আপনি যদি কমান্ড লাইনের পরিবর্তে একটি ইন্টিগ্রেটেড ডেভেলপমেন্ট এনভায়রনমেন্ট (IDE) ব্যবহার করতে পছন্দ করেন, তবে আপনার প্রিয় IDE ব্যবহার করতে পারেন। অনেক IDE-তেই এখন রাস্ট সাপোর্ট রয়েছে; বিস্তারিত জানতে IDE-এর ডকুমেন্টেশন দেখুন। রাস্ট টিম `rust-analyzer`-এর মাধ্যমে சிறந்த IDE সাপোর্ট সক্ষম করার দিকে মনোনিবেশ করেছে। আরও বিস্তারিত জানতে [পরিশিষ্ট ডি][devtools]<!-- ignore --> দেখুন।

### একটি প্রজেক্ট ডিরেক্টরি তৈরি করা

আপনি আপনার রাস্ট কোড সংরক্ষণ করার জন্য একটি ডিরেক্টরি তৈরি করে শুরু করবেন। আপনার কোড কোথায় থাকবে তা রাস্টের কাছে গুরুত্বপূর্ণ নয়, তবে এই বইয়ের অনুশীলন এবং প্রজেক্টগুলোর জন্য, আমরা আপনার হোম ডিরেক্টরিতে একটি _projects_ ডিরেক্টরি তৈরি করার এবং আপনার সমস্ত প্রজেক্ট সেখানে রাখার পরামর্শ দিচ্ছি।

একটি টার্মিনাল খুলুন এবং একটি _projects_ ডিরেক্টরি এবং তার মধ্যে "Hello, world!" প্রজেক্টের জন্য একটি ডিরেক্টরি তৈরি করতে নিম্নলিখিত কমান্ডগুলো প্রবেশ করান।

Linux, macOS এবং Windows-এর PowerShell-এর জন্য, এটি প্রবেশ করান:

```console
$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
```

Windows CMD-এর জন্য, এটি প্রবেশ করান:

```cmd
> mkdir "%USERPROFILE%\projects"
> cd /d "%USERPROFILE%\projects"
> mkdir hello_world
> cd hello_world
```

### একটি রাস্ট প্রোগ্রাম লেখা এবং চালানো

এরপর, একটি নতুন সোর্স ফাইল তৈরি করুন এবং এর নাম দিন _main.rs_। রাস্ট ফাইলগুলো সর্বদা _.rs_ এক্সটেনশন দিয়ে শেষ হয়। আপনি যদি আপনার ফাইলের নামে একাধিক শব্দ ব্যবহার করেন, তবে সেগুলোকে আলাদা করার জন্য আন্ডারস্কোর ব্যবহার করার নিয়ম। উদাহরণস্বরূপ, _helloworld.rs_ এর পরিবর্তে _hello_world.rs_ ব্যবহার করুন।

এখন আপনি যে _main.rs_ ফাইলটি তৈরি করেছেন সেটি খুলুন এবং লিস্টিং ১-১ এর কোডটি প্রবেশ করান।

<Listing number="1-1" file-name="main.rs" caption="`Hello, world!` প্রিন্ট করে এমন একটি প্রোগ্রাম">

```rust
fn main() {
    println!("Hello, world!");
}
```

</Listing>

ফাইলটি সংরক্ষণ করুন এবং _~/projects/hello_world_ ডিরেক্টরিতে আপনার টার্মিনাল উইন্ডোতে ফিরে যান। Linux বা macOS-এ, ফাইলটি কম্পাইল এবং রান করতে নিম্নলিখিত কমান্ডগুলো প্রবেশ করান:

```console
$ rustc main.rs
$ ./main
Hello, world!
```

Windows-এ, `./main` এর পরিবর্তে `.\main` কমান্ডটি প্রবেশ করান:

```powershell
> rustc main.rs
> .\main
Hello, world!
```

আপনার অপারেটিং সিস্টেম নির্বিশেষে, `Hello, world!` স্ট্রিংটি টার্মিনালে প্রিন্ট হওয়া উচিত। আপনি যদি এই আউটপুটটি না দেখেন, তাহলে সাহায্যের জন্য ইনস্টলেশন বিভাগের ["Troubleshooting"][troubleshooting]<!-- ignore --> অংশে ফিরে যান।

যদি `Hello, world!` প্রিন্ট হয়ে থাকে, অভিনন্দন! আপনি আনুষ্ঠানিকভাবে একটি রাস্ট প্রোগ্রাম লিখেছেন। এটি আপনাকে একজন রাস্ট প্রোগ্রামার করে তুলেছে—স্বাগতম!

### একটি রাস্ট প্রোগ্রামের অ্যানাটমি

চলুন এই "Hello, world!" প্রোগ্রামটি বিস্তারিতভাবে পর্যালোচনা করি। এখানে পাজলের প্রথম অংশ:

```rust
fn main() {

}
```

এই লাইনগুলো `main` নামে একটি ফাংশন সংজ্ঞায়িত করে। `main` ফাংশনটি বিশেষ: এটি প্রতিটি এক্সিকিউটেবল রাস্ট প্রোগ্রামে সর্বদা প্রথম কোড যা রান হয়। এখানে, প্রথম লাইনটি `main` নামে একটি ফাংশন ঘোষণা করে যার কোনো প্যারামিটার নেই এবং কিছুই রিটার্ন করে না। যদি প্যারামিটার থাকত, তবে সেগুলো `()` বন্ধনীর ভিতরে যেত।

ফাংশন বডি `{}` দিয়ে মোড়ানো থাকে। রাস্টের সমস্ত ফাংশন বডির চারপাশে কার্লি ব্র্যাকেট প্রয়োজন। ফাংশন ঘোষণার একই লাইনে ওপেনিং কার্লি ব্র্যাকেট রাখা ভালো স্টাইল, এবং এর মধ্যে একটি স্পেস যোগ করা উচিত।

> দ্রষ্টব্য: আপনি যদি রাস্ট প্রজেক্ট জুড়ে একটি স্ট্যান্ডার্ড স্টাইল মেনে চলতে চান, তবে আপনি আপনার কোডকে একটি নির্দিষ্ট স্টাইলে ফর্ম্যাট করার জন্য `rustfmt` নামক একটি স্বয়ংক্রিয় ফর্মাটার টুল ব্যবহার করতে পারেন (`rustfmt` সম্পর্কে আরও জানতে [পরিশিষ্ট ডি][devtools]<!-- ignore --> দেখুন)। রাস্ট টিম এই টুলটিকে স্ট্যান্ডার্ড রাস্ট ডিস্ট্রিবিউশনের সাথে অন্তর্ভুক্ত করেছে, যেমন `rustc`, তাই এটি ইতিমধ্যে আপনার কম্পিউটারে ইনস্টল থাকা উচিত!

`main` ফাংশনের বডিতে নিম্নলিখিত কোডটি রয়েছে:

```rust
println!("Hello, world!");
```

এই লাইনটি এই ছোট প্রোগ্রামের সমস্ত কাজ করে: এটি স্ক্রিনে টেক্সট প্রিন্ট করে। এখানে তিনটি গুরুত্বপূর্ণ বিষয় লক্ষ্য করার আছে।

প্রথমত, `println!` একটি রাস্ট ম্যাক্রো কল করে। যদি এটি একটি ফাংশন কল করত, তবে এটি `println` ( `!` ছাড়া) হিসাবে লেখা হতো। রাস্ট ম্যাক্রো হলো এমন কোড লেখার একটি উপায় যা রাস্ট সিনট্যাক্স প্রসারিত করার জন্য কোড তৈরি করে, এবং আমরা [অধ্যায় ২০][ch20-macros]<!-- ignore -->-এ এগুলি নিয়ে আরও বিস্তারিত আলোচনা করব। আপাতত, আপনার শুধু এটা জানা দরকার যে `!` ব্যবহার করার অর্থ হল আপনি একটি সাধারণ ফাংশনের পরিবর্তে একটি ম্যাক্রো কল করছেন এবং ম্যাক্রোগুলো সবসময় ফাংশনের মতো একই নিয়ম অনুসরণ করে না।

দ্বিতীয়ত, আপনি `"Hello, world!"` স্ট্রিংটি দেখতে পাচ্ছেন। আমরা এই স্ট্রিংটি `println!`-এ একটি আর্গুমেন্ট হিসাবে পাস করি, এবং স্ট্রিংটি স্ক্রিনে প্রিন্ট হয়।

তৃতীয়ত, আমরা লাইনটি একটি সেমিকোলন (`;`) দিয়ে শেষ করি, যা নির্দেশ করে যে এই এক্সপ্রেশনটি শেষ হয়েছে এবং পরবর্তীটি শুরু করার জন্য প্রস্তুত। রাস্ট কোডের বেশিরভাগ লাইন একটি সেমিকোলন দিয়ে শেষ হয়।

### কম্পাইল এবং রান করা দুটি আলাদা ধাপ

আপনি এইমাত্র একটি নতুন তৈরি করা প্রোগ্রাম রান করেছেন, তাই চলুন প্রক্রিয়ার প্রতিটি ধাপ পরীক্ষা করে দেখি।

একটি রাস্ট প্রোগ্রাম রান করার আগে, আপনাকে অবশ্যই রাস্ট কম্পাইলার ব্যবহার করে এটি কম্পাইল করতে হবে, `rustc` কমান্ড প্রবেশ করিয়ে এবং আপনার সোর্স ফাইলের নাম পাস করে, যেমন:

```console
$ rustc main.rs
```

আপনার যদি C বা C++ ব্যাকগ্রাউন্ড থাকে, তাহলে আপনি লক্ষ্য করবেন যে এটি `gcc` বা `clang`-এর মতো। সফলভাবে কম্পাইল করার পর, রাস্ট একটি বাইনারি এক্সিকিউটেবল আউটপুট দেয়।

Linux, macOS এবং Windows-এর PowerShell-এ, আপনি আপনার শেলে `ls` কমান্ড প্রবেশ করে এক্সিকিউটেবলটি দেখতে পারেন:

```console
$ ls
main  main.rs
```

Linux এবং macOS-এ, আপনি দুটি ফাইল দেখতে পাবেন। Windows-এর PowerShell-এ, আপনি CMD ব্যবহার করে যে তিনটি ফাইল দেখতে পেতেন, সেই একই তিনটি ফাইল দেখতে পাবেন। Windows-এর CMD-তে, আপনি নিম্নলিখিতটি প্রবেশ করাবেন:

```cmd
> dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
```

এটি _.rs_ এক্সটেনশন সহ সোর্স কোড ফাইল, এক্সিকিউটেবল ফাইল (Windows-এ _main.exe_, কিন্তু অন্য সব প্ল্যাটফর্মে _main_), এবং Windows ব্যবহার করার সময়, _.pdb_ এক্সটেনশন সহ ডিবাগিং তথ্য সম্বলিত একটি ফাইল দেখায়। এখান থেকে, আপনি _main_ বা _main.exe_ ফাইলটি চালান, এইভাবে:

```console
$ ./main # or .\main on Windows
```

যদি আপনার _main.rs_ আপনার "Hello, world!" প্রোগ্রাম হয়, এই লাইনটি আপনার টার্মিনালে `Hello, world!` প্রিন্ট করবে।

আপনি যদি রুবি, পাইথন বা জাভাস্ক্রিপ্টের মতো ডাইনামিক ল্যাঙ্গুয়েজের সাথে বেশি পরিচিত হন, তাহলে আপনি হয়তো একটি প্রোগ্রামকে আলাদা ধাপে কম্পাইল এবং রান করতে অভ্যস্ত নন। রাস্ট একটি _ahead-of-time compiled_ ভাষা, যার মানে হল আপনি একটি প্রোগ্রাম কম্পাইল করে এক্সিকিউটেবলটি অন্য কাউকে দিতে পারেন, এবং তারা রাস্ট ইনস্টল না করেও এটি চালাতে পারবে। আপনি যদি কাউকে একটি _.rb_, _.py_, বা _.js_ ফাইল দেন, তাদের যথাক্রমে রুবি, পাইথন বা জাভাস্ক্রিপ্ট ইমপ্লিমেন্টেশন ইনস্টল করা থাকতে হবে। কিন্তু সেই ভাষাগুলিতে, আপনার প্রোগ্রাম কম্পাইল এবং রান করার জন্য শুধুমাত্র একটি কমান্ড প্রয়োজন। ভাষার ডিজাইনে সবকিছুই একটি ট্রেড-অফ।

সাধারণ প্রোগ্রামগুলির জন্য শুধু `rustc` দিয়ে কম্পাইল করাই ঠিক আছে, কিন্তু আপনার প্রজেক্ট বড় হওয়ার সাথে সাথে আপনি সমস্ত অপশন পরিচালনা করতে এবং আপনার কোড শেয়ার করা সহজ করতে চাইবেন। এরপর, আমরা আপনাকে কার্গো টুলের সাথে পরিচয় করিয়ে দেব, যা আপনাকে বাস্তব-বিশ্বের রাস্ট প্রোগ্রাম লিখতে সাহায্য করবে।

[troubleshooting]: ch01-01-installation.html#troubleshooting
[devtools]: appendix-04-useful-development-tools.html
[ch20-macros]: ch20-05-macros.html