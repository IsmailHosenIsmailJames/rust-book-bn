## পরিশিষ্ট C: ডেরাইভ করা যায় এমন trait

বইটির বিভিন্ন স্থানে, আমরা `derive` অ্যাট্রিবিউট নিয়ে আলোচনা করেছি, যা আপনি একটি struct বা enum সংজ্ঞার উপর প্রয়োগ করতে পারেন। `derive` অ্যাট্রিবিউট এমন কোড জেনারেট করে যা `derive` সিনট্যাক্স দিয়ে আপনি যে টাইপটিকে চিহ্নিত করেছেন, সেই টাইপের উপর নিজস্ব ডিফল্ট ইমপ্লিমেন্টেশন সহ একটি trait প্রয়োগ করবে।

এই পরিশিষ্টে, আমরা স্ট্যান্ডার্ড লাইব্রেরির সমস্ত trait-এর একটি রেফারেন্স প্রদান করছি যা আপনি `derive` এর সাথে ব্যবহার করতে পারেন। প্রতিটি বিভাগে নিম্নলিখিত বিষয়গুলি অন্তর্ভুক্ত করা হয়েছে:

- এই trait ডেরাইভ করলে কোন অপারেটর এবং মেথডগুলি সক্রিয় হবে
- `derive` দ্বারা প্রদত্ত trait-এর ইমপ্লিমেন্টেশন কী করে
- trait প্রয়োগ করা হলে টাইপটি সম্পর্কে কী বোঝায়
- আপনি কখন trait প্রয়োগ করতে পারবেন বা পারবেন না তার শর্ত
- trait প্রয়োজন এমন ক্রিয়াকলাপের উদাহরণ

যদি আপনি `derive` অ্যাট্রিবিউট দ্বারা প্রদত্ত আচরণের থেকে আলাদা আচরণ চান, তাহলে কীভাবে সেগুলি ম্যানুয়ালি প্রয়োগ করতে হয় তার বিস্তারিত জানার জন্য প্রতিটি trait-এর [স্ট্যান্ডার্ড লাইব্রেরি ডকুমেন্টেশন](../std/index.html) দেখুন।

এখানে তালিকাভুক্ত করা trait গুলিই স্ট্যান্ডার্ড লাইব্রেরি দ্বারা সংজ্ঞায়িত করা হয়েছে যা `derive` ব্যবহার করে আপনার টাইপের উপর প্রয়োগ করা যেতে পারে। স্ট্যান্ডার্ড লাইব্রেরিতে সংজ্ঞায়িত অন্যান্য trait গুলির কোনো বোধগম্য ডিফল্ট আচরণ নেই, তাই আপনি যা অর্জন করতে চাইছেন তার জন্য উপযুক্ত উপায়ে সেগুলি প্রয়োগ করা আপনার উপর নির্ভর করে।

একটি trait যা ডেরাইভ করা যায় না তার উদাহরণ হল `Display`, যা শেষ ব্যবহারকারীদের জন্য ফরম্যাটিং পরিচালনা করে। শেষ ব্যবহারকারীর কাছে একটি টাইপ প্রদর্শনের সঠিক উপায়টি আপনার সবসময় বিবেচনা করা উচিত। শেষ ব্যবহারকারীকে টাইপের কোন অংশগুলি দেখার অনুমতি দেওয়া উচিত? কোন অংশগুলি তাদের কাছে প্রাসঙ্গিক মনে হবে? ডেটার কোন ফর্ম্যাট তাদের জন্য সবচেয়ে প্রাসঙ্গিক হবে? Rust কম্পাইলারের এই ধারণা নেই, তাই এটি আপনার জন্য উপযুক্ত ডিফল্ট আচরণ প্রদান করতে পারে না।

এই পরিশিষ্টে প্রদত্ত ডেরাইভ করা যায় এমন trait-এর তালিকাটি সম্পূর্ণ নয়: লাইব্রেরিগুলি তাদের নিজস্ব trait-এর জন্য `derive` প্রয়োগ করতে পারে, যার ফলে আপনি `derive` ব্যবহার করতে পারেন এমন trait-এর তালিকাটি সত্যিই উন্মুক্ত হয়ে যায়। `derive` প্রয়োগ করার জন্য একটি প্রসিডিউরাল ম্যাক্রো ব্যবহার করা জড়িত, যা অধ্যায় ২০-এর ["ম্যাক্রোস"][macros] বিভাগে আলোচনা করা হয়েছে।

### প্রোগ্রামার আউটপুটের জন্য `Debug`

`Debug` trait ফরম্যাট স্ট্রিংগুলিতে ডিবাগ ফরম্যাটিং সক্ষম করে, যা আপনি `{}` প্লেসহোল্ডারগুলির মধ্যে `:?` যোগ করে নির্দেশ করেন।

`Debug` trait আপনাকে ডিবাগিং উদ্দেশ্যে একটি টাইপের উদাহরণ প্রিন্ট করার অনুমতি দেয়, যাতে আপনি এবং আপনার টাইপ ব্যবহারকারী অন্যান্য প্রোগ্রামাররা প্রোগ্রামের এক্সিকিউশনের একটি নির্দিষ্ট সময়ে একটি উদাহরণ পরীক্ষা করতে পারেন।

উদাহরণস্বরূপ, `assert_eq!` ম্যাক্রো ব্যবহার করার সময় `Debug` trait প্রয়োজন। এই ম্যাক্রো আর্গুমেন্ট হিসাবে দেওয়া উদাহরণগুলির মান প্রিন্ট করে যদি সমতা দাবিটি ব্যর্থ হয়, যাতে প্রোগ্রামাররা দেখতে পারে কেন দুটি উদাহরণ সমান ছিল না।

### সমতা তুলনার জন্য `PartialEq` এবং `Eq`

`PartialEq` trait আপনাকে একটি টাইপের উদাহরণগুলির মধ্যে সমতা পরীক্ষা করার জন্য তুলনা করতে দেয় এবং `==` এবং `!=` অপারেটরগুলির ব্যবহার সক্ষম করে।

`PartialEq` ডেরাইভ করলে `eq` মেথড প্রয়োগ করা হয়। যখন struct-এর উপর `PartialEq` ডেরাইভ করা হয়, তখন দুটি উদাহরণ সমান হয় শুধুমাত্র যদি _সমস্ত_ ফিল্ড সমান হয় এবং যদি কোনও ফিল্ড সমান না হয় তবে উদাহরণগুলি সমান হয় না। যখন enums এর উপর ডেরাইভ করা হয়, তখন প্রতিটি ভেরিয়েন্ট নিজের সাথে সমান এবং অন্যান্য ভেরিয়েন্টের সাথে সমান নয়।

উদাহরণস্বরূপ, `assert_eq!` ম্যাক্রো ব্যবহারের জন্য `PartialEq` trait প্রয়োজন, যা সমতার জন্য একটি টাইপের দুটি উদাহরণ তুলনা করতে সক্ষম হতে হবে।

`Eq` trait-এর কোনো মেথড নেই। এর উদ্দেশ্য হল সংকেত দেওয়া যে টীকাযুক্ত টাইপের প্রতিটি মানের জন্য, মানটি নিজের সাথে সমান। `Eq` trait শুধুমাত্র সেই টাইপগুলিতে প্রয়োগ করা যেতে পারে যা `PartialEq` প্রয়োগ করে, যদিও সমস্ত টাইপ যা `PartialEq` প্রয়োগ করে তা `Eq` প্রয়োগ করতে পারে না। এর একটি উদাহরণ হল ফ্লোটিং পয়েন্ট সংখ্যার প্রকার: ফ্লোটিং পয়েন্ট সংখ্যার ইমপ্লিমেন্টেশন বলে যে নট-এ-নাম্বার (`NaN`) মানের দুটি উদাহরণ একে অপরের সমান নয়।

`Eq` কখন প্রয়োজন হয় তার একটি উদাহরণ হল `HashMap<K, V>`-এর কীগুলির জন্য, যাতে `HashMap<K, V>` বলতে পারে যে দুটি কী একই কিনা।

### অর্ডারিং তুলনার জন্য `PartialOrd` এবং `Ord`

`PartialOrd` trait আপনাকে বাছাই করার উদ্দেশ্যে একটি টাইপের উদাহরণ তুলনা করার অনুমতি দেয়। যে টাইপ `PartialOrd` প্রয়োগ করে তা `<`, `>`, `<=`, এবং `>=` অপারেটরগুলির সাথে ব্যবহার করা যেতে পারে। আপনি শুধুমাত্র সেই টাইপগুলিতে `PartialOrd` trait প্রয়োগ করতে পারেন যা `PartialEq`-ও প্রয়োগ করে।

`PartialOrd` ডেরাইভ করলে `partial_cmp` মেথড প্রয়োগ করা হয়, যা একটি `Option<Ordering>` রিটার্ন করে যা `None` হবে যখন দেওয়া মানগুলি কোনো অর্ডারিং তৈরি করে না। একটি মান যা অর্ডারিং তৈরি করে না, যদিও সেই টাইপের বেশিরভাগ মান তুলনা করা যেতে পারে, তা হল নট-এ-নাম্বার (`NaN`) ফ্লোটিং পয়েন্ট মান। কোনো ফ্লোটিং পয়েন্ট সংখ্যা এবং `NaN` ফ্লোটিং পয়েন্ট মান দিয়ে `partial_cmp` কল করলে `None` রিটার্ন হবে।

যখন struct-এর উপর ডেরাইভ করা হয়, তখন `PartialOrd` struct সংজ্ঞাতে ফিল্ডগুলি যে ক্রমে প্রদর্শিত হয় সেই ক্রমে প্রতিটি ফিল্ডের মান তুলনা করে দুটি উদাহরণ তুলনা করে। যখন enums-এর উপর ডেরাইভ করা হয়, তখন enum সংজ্ঞাতে আগে ঘোষণা করা enum-এর ভেরিয়েন্টগুলিকে পরে তালিকাভুক্ত ভেরিয়েন্টগুলির চেয়ে কম হিসাবে বিবেচনা করা হয়।

উদাহরণস্বরূপ, `rand` crate থেকে `gen_range` মেথডের জন্য `PartialOrd` trait প্রয়োজন, যা একটি রেঞ্জ এক্সপ্রেশন দ্বারা নির্দিষ্ট করা রেঞ্জে একটি র্যান্ডম মান তৈরি করে।

`Ord` trait আপনাকে জানতে দেয় যে টীকাযুক্ত টাইপের যেকোনো দুটি মানের জন্য, একটি বৈধ অর্ডারিং বিদ্যমান থাকবে। `Ord` trait `cmp` মেথড প্রয়োগ করে, যা `Option<Ordering>` এর পরিবর্তে একটি `Ordering` রিটার্ন করে কারণ একটি বৈধ অর্ডারিং সবসময় সম্ভব হবে। আপনি শুধুমাত্র সেই টাইপগুলিতে `Ord` trait প্রয়োগ করতে পারেন যা `PartialOrd` এবং `Eq`-ও প্রয়োগ করে (এবং `Eq`-এর জন্য `PartialEq` প্রয়োজন)। যখন struct এবং enums-এর উপর ডেরাইভ করা হয়, তখন `cmp`, `PartialOrd` সহ `partial_cmp`-এর জন্য ডেরাইভ করা ইমপ্লিমেন্টেশনের মতোই আচরণ করে।

`Ord` কখন প্রয়োজন হয় তার একটি উদাহরণ হল `BTreeSet<T>`-এ মানগুলি সংরক্ষণ করার সময়, একটি ডেটা স্ট্রাকচার যা মানগুলির বাছাই করার ক্রমের উপর ভিত্তি করে ডেটা সংরক্ষণ করে।

### মান ডুপ্লিকেট করার জন্য `Clone` এবং `Copy`

`Clone` trait আপনাকে একটি মানের একটি সুস্পষ্ট গভীর অনুলিপি তৈরি করতে দেয় এবং ডুপ্লিকেশনের প্রক্রিয়ায় নির্বিচারে কোড চালানো এবং হিপ ডেটা অনুলিপি করা জড়িত থাকতে পারে। `Clone` সম্পর্কে আরও তথ্যের জন্য অধ্যায় ৪-এ ["ভেরিয়েবল এবং ডেটার মিথস্ক্রিয়া করার উপায়: ক্লোন"][ways-variables-and-data-interact-clone] বিভাগটি দেখুন।

`Clone` ডেরাইভ করলে `clone` মেথড প্রয়োগ করা হয়, যা পুরো টাইপের জন্য প্রয়োগ করা হলে, টাইপের প্রতিটি অংশের উপর `clone` কল করে। এর মানে হল `Clone` ডেরাইভ করার জন্য টাইপের সমস্ত ফিল্ড বা মানকেও `Clone` প্রয়োগ করতে হবে।

`Clone` কখন প্রয়োজন হয় তার একটি উদাহরণ হল একটি স্লাইসে `to_vec` মেথড কল করার সময়। স্লাইসটিতে থাকা টাইপের উদাহরণগুলির মালিকানা নেই, তবে `to_vec` থেকে ফেরত আসা ভেক্টরটির নিজস্ব উদাহরণগুলির মালিকানা থাকতে হবে, তাই `to_vec` প্রতিটি আইটেমের উপর `clone` কল করে। সুতরাং, স্লাইসে সংরক্ষিত টাইপটিকে `Clone` প্রয়োগ করতে হবে।

`Copy` trait আপনাকে শুধুমাত্র স্ট্যাকে সঞ্চিত বিটগুলি অনুলিপি করে একটি মান ডুপ্লিকেট করার অনুমতি দেয়; কোনো নির্বিচারে কোডের প্রয়োজন নেই। `Copy` সম্পর্কে আরও তথ্যের জন্য অধ্যায় ৪-এ ["স্ট্যাক-অনলি ডেটা: কপি"][stack-only-data-copy] বিভাগটি দেখুন।

প্রোগ্রামারদের সেই মেথডগুলিকে ওভারলোড করা থেকে বিরত রাখতে এবং কোনও নির্বিচারে কোড চালানো হচ্ছে না এমন অনুমান লঙ্ঘন করা থেকে আটকাতে `Copy` trait কোনও মেথড সংজ্ঞায়িত করে না। এইভাবে, সমস্ত প্রোগ্রামার অনুমান করতে পারে যে একটি মান কপি করা খুব দ্রুত হবে।

আপনি যেকোনো টাইপের উপর `Copy` ডেরাইভ করতে পারেন যার সমস্ত অংশ `Copy` প্রয়োগ করে। যে টাইপ `Copy` প্রয়োগ করে তাকে `Clone`-ও প্রয়োগ করতে হবে, কারণ যে টাইপ `Copy` প্রয়োগ করে তার `Clone`-এর একটি সাধারণ ইমপ্লিমেন্টেশন রয়েছে যা `Copy` এর মতোই কাজ করে।

`Copy` trait এর খুব কমই প্রয়োজন হয়; যে টাইপগুলি `Copy` প্রয়োগ করে তাদের অপটিমাইজেশন উপলব্ধ রয়েছে, যার অর্থ আপনাকে `clone` কল করতে হবে না, যা কোডটিকে আরও সংক্ষিপ্ত করে তোলে।

`Copy` দিয়ে যা কিছু করা সম্ভব, `Clone` দিয়েও তা অর্জন করতে পারেন, তবে কোডটি ধীর হতে পারে বা কিছু জায়গায় `clone` ব্যবহার করতে হতে পারে।

### একটি মানকে নির্দিষ্ট আকারের মানে ম্যাপ করার জন্য `Hash`

`Hash` trait আপনাকে নির্বিচারে আকারের একটি টাইপের উদাহরণ নিতে এবং একটি হ্যাশ ফাংশন ব্যবহার করে সেই উদাহরণটিকে নির্দিষ্ট আকারের একটি মানে ম্যাপ করার অনুমতি দেয়। `Hash` ডেরাইভ করলে `hash` মেথড প্রয়োগ করা হয়। `hash` মেথডের ডেরাইভ করা ইমপ্লিমেন্টেশন টাইপের প্রতিটি অংশের উপর `hash` কল করার ফলাফলকে একত্রিত করে, যার মানে `Hash` ডেরাইভ করার জন্য সমস্ত ফিল্ড বা মানকেও `Hash` প্রয়োগ করতে হবে।

`Hash` কখন প্রয়োজন হয় তার একটি উদাহরণ হল `HashMap<K, V>`-এ ডেটা দক্ষতার সাথে সংরক্ষণ করার জন্য কীগুলি সংরক্ষণ করা।

### ডিফল্ট মানের জন্য `Default`

`Default` trait আপনাকে একটি টাইপের জন্য একটি ডিফল্ট মান তৈরি করতে দেয়। `Default` ডেরাইভ করলে `default` ফাংশন প্রয়োগ করা হয়। `default` ফাংশনের ডেরাইভ করা ইমপ্লিমেন্টেশন টাইপের প্রতিটি অংশের উপর `default` ফাংশন কল করে, যার মানে হল `Default` ডেরাইভ করার জন্য টাইপের সমস্ত ফিল্ড বা মানকেও `Default` প্রয়োগ করতে হবে।

অধ্যায় ৫-এ ["স্ট্রাক্ট আপডেট সিনট্যাক্স সহ অন্যান্য উদাহরণ থেকে উদাহরণ তৈরি করা"][creating-instances-from-other-instances-with-struct-update-syntax] বিভাগে আলোচিত struct আপডেট সিনট্যাক্সের সাথে `Default::default` ফাংশনটি সাধারণত ব্যবহার করা হয়। আপনি একটি struct-এর কয়েকটি ফিল্ড কাস্টমাইজ করতে পারেন এবং তারপর `..Default::default()` ব্যবহার করে বাকি ফিল্ডগুলির জন্য একটি ডিফল্ট মান সেট করতে এবং ব্যবহার করতে পারেন।

উদাহরণস্বরূপ, যখন আপনি `Option<T>` ইনস্ট্যান্সগুলিতে `unwrap_or_default` মেথড ব্যবহার করেন তখন `Default` trait প্রয়োজন। যদি `Option<T>` `None` হয়, তবে `unwrap_or_default` মেথডটি `Option<T>`-এ সংরক্ষিত `T` টাইপের জন্য `Default::default`-এর ফলাফল রিটার্ন করবে।

[creating-instances-from-other-instances-with-struct-update-syntax]: ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax
[stack-only-data-copy]: ch04-01-what-is-ownership.html#stack-only-data-copy
[ways-variables-and-data-interact-clone]: ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone
[macros]: ch20-05-macros.html#macros
