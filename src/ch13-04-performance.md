## কর্মক্ষমতা তুলনা করা: লুপ বনাম ইটারেটর

লুপ নাকি ইটারেটর ব্যবহার করবেন তা নির্ধারণ করতে, আপনাকে জানতে হবে যে কোন বাস্তবায়নটি দ্রুততর: একটি সুস্পষ্ট `for` লুপ সহ `search` ফাংশনের সংস্করণ বা ইটারেটর সহ সংস্করণটি।

আমরা স্যার আর্থার কোনান ডয়েলের _দ্য অ্যাডভেঞ্চারস অফ শার্লক হোমস_-এর সম্পূর্ণ বিষয়বস্তু একটি `String`-এ লোড করে এবং বিষয়বস্তুর মধ্যে _the_ শব্দটি অনুসন্ধান করে একটি বেঞ্চমার্ক চালিয়েছিলাম। এখানে `for` লুপ ব্যবহার করে `search`-এর সংস্করণ এবং ইটারেটর ব্যবহার করে সংস্করণের বেঞ্চমার্কের ফলাফল দেওয়া হল:

```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

দুটি বাস্তবায়নের কর্মক্ষমতা একই রকম! আমরা এখানে বেঞ্চমার্ক কোডটি ব্যাখ্যা করব না, কারণ দুটি সংস্করণ সমতুল্য প্রমাণ করা আমাদের উদ্দেশ্য নয়, তবে এই দুটি বাস্তবায়ন কর্মক্ষমতার দিক থেকে কীভাবে তুলনা করে তার একটি সাধারণ ধারণা পাওয়া।

আরও বিস্তৃত বেঞ্চমার্কের জন্য, আপনার বিভিন্ন আকারের বিভিন্ন টেক্সট `contents` হিসাবে, বিভিন্ন দৈর্ঘ্যের বিভিন্ন শব্দ এবং অন্যান্য সব ধরনের ভিন্নতা ব্যবহার করে পরীক্ষা করা উচিত। মূল কথাটি হল: ইটারেটরগুলো, একটি উচ্চ-স্তরের বিমূর্ততা হওয়া সত্ত্বেও, প্রায় একই কোডে কম্পাইল করা হয় যেন আপনি নিজেই নিম্ন-স্তরের কোডটি লিখে থাকেন। ইটারেটরগুলো হল রাস্টের _শূন্য-খরচের বিমূর্ততা_, যার দ্বারা আমরা বুঝি যে বিমূর্ততা ব্যবহার করলে কোনো অতিরিক্ত রানটাইম ওভারহেড হয় না। এটি C++-এর মূল ডিজাইনার এবং বাস্তবায়নকারী Bjarne Stroustrup, "ফাউন্ডেশন অফ C++" (2012)-এ _শূন্য-ওভারহেড_ কে যেভাবে সংজ্ঞায়িত করেছেন, তার মতোই:

> সাধারণভাবে, C++ বাস্তবায়নগুলো শূন্য-ওভারহেড নীতি মেনে চলে: আপনি যা ব্যবহার করেন না, তার জন্য আপনাকে অর্থ দিতে হয় না। এবং আরও: আপনি যা ব্যবহার করেন, আপনি এর চেয়ে ভালো কোড হাতে লিখতে পারতেন না।

অন্য একটি উদাহরণ হিসাবে, নিম্নলিখিত কোডটি একটি অডিও ডিকোডার থেকে নেওয়া হয়েছে। ডিকোডিং অ্যালগরিদম পূর্ববর্তী স্যাম্পেলগুলোর একটি লিনিয়ার ফাংশনের উপর ভিত্তি করে ভবিষ্যতের মান অনুমান করতে লিনিয়ার প্রেডিকশন গাণিতিক অপারেশন ব্যবহার করে। এই কোডটি স্কোপে থাকা তিনটি ভেরিয়েবলের উপর কিছু গণিত করার জন্য একটি ইটারেটর চেইন ব্যবহার করে: ডেটার একটি `buffer` স্লাইস, 12টি `coefficients` এর একটি অ্যারে এবং `qlp_shift`-এ ডেটা স্থানান্তরিত করার পরিমাণ। আমরা এই উদাহরণে ভেরিয়েবলগুলো ঘোষণা করেছি কিন্তু তাদের কোনো ভ্যালু দিইনি; যদিও এই কোডের প্রেক্ষাপটের বাইরে খুব বেশি অর্থ নেই, এটি এখনও একটি সংক্ষিপ্ত, বাস্তব-বিশ্বের উদাহরণ যে রাস্ট কীভাবে উচ্চ-স্তরের ধারণাগুলোকে নিম্ন-স্তরের কোডে অনুবাদ করে।

```rust,ignore
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

`prediction`-এর ভ্যালু গণনা করার জন্য, এই কোডটি `coefficients`-এর 12টি ভ্যালুর প্রতিটির উপর পুনরাবৃত্তি করে এবং `buffer`-এর আগের 12টি ভ্যালুর সাথে কোয়েফিসিয়েন্ট ভ্যালুগুলো জোড়া তৈরি করতে `zip` মেথড ব্যবহার করে। তারপরে, প্রতিটি জোড়ার জন্য, আমরা ভ্যালুগুলোকে গুণ করি, সমস্ত ফলাফল যোগ করি এবং `qlp_shift` বিট দ্বারা যোগফলের বিটগুলোকে ডানদিকে সরিয়ে দিই।

অডিও ডিকোডারের মতো অ্যাপ্লিকেশনগুলোতে হিসাব প্রায়শই কর্মক্ষমতাকে সবচেয়ে বেশি অগ্রাধিকার দেয়। এখানে, আমরা একটি ইটারেটর তৈরি করছি, দুটি অ্যাডাপ্টার ব্যবহার করছি এবং তারপরে ভ্যালু ব্যবহার করছি। এই রাস্ট কোডটি কোন অ্যাসেম্বলি কোডে কম্পাইল করবে? এই লেখার সময় পর্যন্ত, এটি সেই অ্যাসেম্বলিতে কম্পাইল করে যা আপনি হাতে লিখতেন। `coefficients`-এর ভ্যালুগুলোর উপর পুনরাবৃত্তির সাথে সম্পর্কিত কোনো লুপ নেই: রাস্ট জানে যে এখানে 12টি পুনরাবৃত্তি আছে, তাই এটি লুপটিকে "আনরোল" করে। _আনরোলিং_ হল একটি অপটিমাইজেশন যা লুপ নিয়ন্ত্রণকারী কোডের ওভারহেড সরিয়ে দেয় এবং পরিবর্তে লুপের প্রতিটি পুনরাবৃত্তির জন্য পুনরাবৃত্তিমূলক কোড তৈরি করে।

সমস্ত কোয়েফিসিয়েন্ট রেজিস্টারে স্টোর করা হয়, যার মানে ভ্যালুগুলোতে অ্যাক্সেস করা খুব দ্রুত। রানটাইমে অ্যারে অ্যাক্সেসের উপর কোনো বাউন্ডস চেক নেই। রাস্ট প্রয়োগ করতে পারে এমন এই সমস্ত অপটিমাইজেশনগুলো ফলস্বরূপ কোডটিকে অত্যন্ত দক্ষ করে তোলে। এখন যেহেতু আপনি এটি জানেন, তাই আপনি ভয় ছাড়াই ইটারেটর এবং ক্লোজার ব্যবহার করতে পারেন! এগুলো কোডটিকে উচ্চ স্তরের দেখায় কিন্তু তা করার জন্য কোনো রানটাইম কর্মক্ষমতা জরিমানা আরোপ করে না।

## সারসংক্ষেপ

ক্লোজার এবং ইটারেটর হল কার্যকরী প্রোগ্রামিং ভাষার ধারণাগুলো দ্বারা অনুপ্রাণিত রাস্টের বৈশিষ্ট্য। তারা নিম্ন-স্তরের কর্মক্ষমতায় উচ্চ-স্তরের ধারণাগুলো স্পষ্টভাবে প্রকাশ করার জন্য রাস্টের ক্ষমতাতে অবদান রাখে। ক্লোজার এবং ইটারেটরের বাস্তবায়ন এমন যে রানটাইম কর্মক্ষমতা প্রভাবিত হয় না। এটি শূন্য-খরচের বিমূর্ততা প্রদানের জন্য প্রচেষ্টা করার রাস্টের লক্ষ্যের অংশ।

এখন যেহেতু আমরা আমাদের I/O প্রজেক্টের অভিব্যক্তি উন্নত করেছি, আসুন `cargo`-এর আরও কিছু বৈশিষ্ট্য দেখি যা আমাদের প্রজেক্টটিকে বিশ্বের সাথে শেয়ার করতে সাহায্য করবে।
