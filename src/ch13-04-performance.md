## পারফরম্যান্সের তুলনা: লুপ বনাম ইটারেটর

লুপ নাকি ইটারেটর ব্যবহার করবেন, তা নির্ধারণ করার জন্য আপনাকে জানতে হবে কোন ইমপ্লিমেন্টেশনটি দ্রুততর: সুস্পষ্ট `for` লুপসহ `search` ফাংশনের সংস্করণটি নাকি ইটারেটরসহ সংস্করণটি।

আমরা স্যার আর্থার কোনান ডয়েলের লেখা *দ্য অ্যাডভেঞ্চারস অফ শার্লক হোমস* এর সম্পূর্ণ বিষয়বস্তু একটি `String`-এ লোড করে এবং বিষয়বস্তুর মধ্যে *the* শব্দটি খুঁজে একটি বেঞ্চমার্ক (benchmark) চালিয়েছি। এখানে `for` লুপ ব্যবহার করে `search` ফাংশনের সংস্করণ এবং ইটারেটর ব্যবহার করে সংস্করণটির বেঞ্চমার্কের ফলাফল দেওয়া হলো:

```text
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

দুটি ইমপ্লিমেন্টেশনের পারফরম্যান্স প্রায় একই! আমরা এখানে বেঞ্চমার্ক কোডটি ব্যাখ্যা করব না কারণ মূল উদ্দেশ্য দুটি সংস্করণ যে সমতুল্য তা প্রমাণ করা নয়, বরং এই দুটি ইমপ্লিমেন্টেশন পারফরম্যান্সের দিক থেকে কীভাবে তুলনা করা হয় সে সম্পর্কে একটি সাধারণ ধারণা দেওয়া।

আরও বিস্তারিত বেঞ্চমার্কের জন্য, আপনার বিভিন্ন আকারের টেক্সটকে `contents` হিসেবে, বিভিন্ন শব্দ এবং বিভিন্ন দৈর্ঘ্যের শব্দকে `query` হিসেবে, এবং অন্যান্য সব ধরনের ভিন্নতা ব্যবহার করে পরীক্ষা করা উচিত। মূল কথা হলো: ইটারেটর, যদিও একটি উচ্চ-স্তরের (high-level) অ্যাবস্ট্র্যাকশন, সেগুলো প্রায় একই কোডে কম্পাইল হয় যা আপনি নিজে থেকে নিম্ন-স্তরের (lower-level) কোড লিখলে হতো। ইটারেটর হলো রাস্টের একটি *জিরো-কস্ট অ্যাবস্ট্র্যাকশন* (zero-cost abstractions), যার মাধ্যমে আমরা বোঝাই যে অ্যাবস্ট্র্যাকশন ব্যবহার করলে কোনো অতিরিক্ত রানটাইম ওভারহেড (runtime overhead) হয় না। এটি C++ এর মূল ডিজাইনার এবং ইমপ্লিমেন্টার Bjarne Stroustrup যেভাবে "Foundations of C++" (2012) বইতে *জিরো-ওভারহেড* (zero-overhead) সংজ্ঞায়িত করেছেন তার অনুরূপ:

> সাধারণভাবে, C++ ইমপ্লিমেন্টেশনগুলো জিরো-ওভারহেড নীতি মেনে চলে: যা আপনি ব্যবহার করেন না, তার জন্য আপনাকে মূল্য দিতে হয় না। এবং আরও: যা আপনি ব্যবহার করেন, তা আপনি হাতে লিখে এর চেয়ে ভালো কোড তৈরি করতে পারতেন না।

অনেক ক্ষেত্রে, ইটারেটর ব্যবহার করে লেখা রাস্ট কোড সেই একই অ্যাসেম্বলি কোডে কম্পাইল হয় যা আপনি হাতে লিখতেন। লুপ আনরোলিং (loop unrolling) এবং অ্যারে অ্যাক্সেসের ক্ষেত্রে বাউন্ডস চেকিং (bounds checking) বাদ দেওয়ার মতো অপ্টিমাইজেশনগুলো প্রয়োগ হয় এবং ফলস্বরূপ কোডটিকে অত্যন্ত দক্ষ করে তোলে। এখন যেহেতু আপনি এটি জানেন, আপনি ভয় ছাড়াই ইটারেটর এবং ক্লোজার ব্যবহার করতে পারেন! এগুলি কোডকে উচ্চ-স্তরের বলে মনে করায়, কিন্তু তা করার জন্য কোনো রানটাইম পারফরম্যান্স পেনাল্টি আরোপ করে না।

## সারসংক্ষেপ

ক্লোজার এবং ইটারেটর হলো ফাংশনাল প্রোগ্রামিং ভাষার ধারণা দ্বারা অনুপ্রাণিত রাস্টের বৈশিষ্ট্য। এগুলো রাস্টের উচ্চ-স্তরের ধারণাগুলোকে নিম্ন-স্তরের পারফরম্যান্সে স্পষ্টভাবে প্রকাশ করার ক্ষমতায় অবদান রাখে। ক্লোজার এবং ইটারেটরের ইমপ্লিমেন্টেশন এমনভাবে করা হয়েছে যাতে রানটাইম পারফরম্যান্স প্রভাবিত না হয়। এটি রাস্টের জিরো-কস্ট অ্যাবস্ট্র্যাকশন প্রদানের লক্ষ্যের একটি অংশ।

এখন যেহেতু আমরা আমাদের I/O প্রজেক্টের প্রকাশক্ষমতা উন্নত করেছি, আসুন `cargo`-এর আরও কিছু বৈশিষ্ট্য দেখি যা আমাদের প্রজেক্টটি বিশ্বের সাথে শেয়ার করতে সাহায্য করবে।