<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ইটারেটর দিয়ে আইটেমের একটি সিরিজ প্রসেস করা - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="ইটারেটর-বযবহার-করে-আইটেমের-সিরিজ-পরসেস-করা"><a class="header" href="#ইটারেটর-বযবহার-করে-আইটেমের-সিরিজ-পরসেস-করা">ইটারেটর ব্যবহার করে আইটেমের সিরিজ প্রসেস করা</a></h2>
<p>ইটারেটর প্যাটার্ন (iterator pattern) আপনাকে একটি সিকোয়েন্সের (sequence) প্রতিটি আইটেমের উপর পর্যায়ক্রমে কোনো কাজ করার সুযোগ দেয়। একটি ইটারেটর প্রতিটি আইটেমের উপর পুনরাবৃত্তি (iterating) করার এবং সিকোয়েন্সটি কখন শেষ হয়েছে তা নির্ধারণ করার লজিকের জন্য দায়ী থাকে। আপনি যখন ইটারেটর ব্যবহার করেন, তখন আপনাকে সেই লজিকটি নিজে থেকে পুনরায় ইমপ্লিমেন্ট (reimplement) করতে হয় না।</p>
<p>রাস্টে, ইটারেটরগুলো <em>lazy</em> (অলস), যার মানে হলো যতক্ষণ না আপনি ইটারেটরটিকে ব্যবহার করার জন্য কোনো মেথড কল করছেন, ততক্ষণ পর্যন্ত এর কোনো প্রভাব থাকে না। উদাহরণস্বরূপ, Listing 13-10-এর কোড <code>v1</code> ভেক্টরের আইটেমগুলোর উপর একটি ইটারেটর তৈরি করে, যা <code>Vec&lt;T&gt;</code>-তে ডিফাইন করা <code>iter</code> মেথড কল করার মাধ্যমে করা হয়। এই কোডটি নিজে থেকে কোনো দরকারী কাজ করে না।</p>
<Listing number="13-10" file-name="src/main.rs" caption="একটি ইটারেটর তৈরি করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();
<span class="boring">}```
</span>
&lt;/Listing&gt;

ইটারেটরটি `v1_iter` ভ্যারিয়েবলে সংরক্ষণ করা হয়েছে। একবার আমরা একটি ইটারেটর তৈরি করলে, আমরা এটিকে বিভিন্ন উপায়ে ব্যবহার করতে পারি। Listing 3-5-এ, আমরা একটি `for` লুপ ব্যবহার করে একটি অ্যারের উপর ইটারেট করেছিলাম এবং প্রতিটি আইটেমের উপর কিছু কোড এক্সিকিউট করেছিলাম। পর্দার আড়ালে, এটি একটি ইটারেটর তৈরি করে এবং তারপর তা ব্যবহার করে, কিন্তু এখন পর্যন্ত আমরা এটি ঠিক কীভাবে কাজ করে তা বিস্তারিত আলোচনা করিনি।

Listing 13-11-এর উদাহরণে, আমরা ইটারেটর তৈরি করা এবং `for` লুপে ইটারেটর ব্যবহার করাকে আলাদা করেছি। যখন `v1_iter`-এর ইটারেটর ব্যবহার করে `for` লুপ কল করা হয়, তখন ইটারেটরের প্রতিটি এলিমেন্ট লুপের একটি ইটারেশনে ব্যবহৃত হয়, যা প্রতিটি মান প্রিন্ট করে।

&lt;Listing number="13-11" file-name="src/main.rs" caption="`for` লুপে একটি ইটারেটর ব্যবহার করা"&gt;

```rust
<span class="boring">fn main() {
</span>    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    for val in v1_iter {
        println!("Got: {val}");
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>যেসব ভাষায় তাদের স্ট্যান্ডার্ড লাইব্রেরিতে ইটারেটর সরবরাহ করা হয় না, সেখানে আপনাকে সম্ভবত একই কার্যকারিতা লিখতে হতো একটি ভ্যারিয়েবলকে ইনডেক্স ০ থেকে শুরু করে, সেই ভ্যারিয়েবলটি ব্যবহার করে ভেক্টর থেকে একটি মান পেতে, এবং লুপের মধ্যে ভ্যারিয়েবলের মান বাড়িয়ে যতক্ষণ না এটি ভেক্টরের মোট আইটেমের সংখ্যায় পৌঁছায়।</p>
<p>ইটারেটর আপনার জন্য এই সমস্ত লজিক পরিচালনা করে, যা পুনরাবৃত্তিমূলক কোড কমিয়ে দেয় এবং সম্ভাব্য ভুল এড়াতে সাহায্য করে। ইটারেটর আপনাকে অনেক বিভিন্ন ধরণের সিকোয়েন্সের সাথে একই লজিক ব্যবহার করার জন্য আরও বেশি ফ্লেক্সিবিলিটি দেয়, শুধু ভেক্টরের মতো ডেটা স্ট্রাকচার নয় যা আপনি ইনডেক্স করতে পারেন। আসুন দেখি ইটারেটর কীভাবে তা করে।</p>
<h3 id="iterator-টরেইট-এবং-next-মেথড"><a class="header" href="#iterator-টরেইট-এবং-next-মেথড"><code>Iterator</code> ট্রেইট এবং <code>next</code> মেথড</a></h3>
<p>সমস্ত ইটারেটর <code>Iterator</code> নামের একটি ট্রেইট (trait) ইমপ্লিমেন্ট করে যা স্ট্যান্ডার্ড লাইব্রেরিতে ডিফাইন করা আছে। ট্রেইটের ডেফিনিশনটি দেখতে এইরকম:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}</span></code></pre></pre>
<p>লক্ষ্য করুন যে এই ডেফিনিশনে কিছু নতুন সিনট্যাক্স ব্যবহার করা হয়েছে: <code>type Item</code> এবং <code>Self::Item</code>, যা এই ট্রেইটের সাথে একটি <em>associated type</em> ডিফাইন করছে। আমরা Chapter 20-এ associated type নিয়ে গভীরভাবে আলোচনা করব। আপাতত, আপনার শুধু এটুকু জানলেই চলবে যে এই কোডটি বলছে <code>Iterator</code> ট্রেইট ইমপ্লিমেন্ট করার জন্য আপনাকে একটি <code>Item</code> টাইপও ডিফাইন করতে হবে, এবং এই <code>Item</code> টাইপটি <code>next</code> মেথডের রিটার্ন টাইপে ব্যবহৃত হয়। অন্য কথায়, <code>Item</code> টাইপটি হবে ইটারেটর থেকে রিটার্ন করা টাইপ।</p>
<p><code>Iterator</code> ট্রেইট ইমপ্লিমেন্ট করার জন্য শুধুমাত্র একটি মেথড ডিফাইন করতে হয়: <code>next</code> মেথড, যা ইটারেটরের একটি করে আইটেম <code>Some</code>-এ মুড়িয়ে রিটার্ন করে, এবং যখন ইটারেশন শেষ হয়ে যায়, তখন <code>None</code> রিটার্ন করে।</p>
<p>আমরা ইটারেটরের উপর সরাসরি <code>next</code> মেথড কল করতে পারি; Listing 13-12 দেখায় যে ভেক্টর থেকে তৈরি করা ইটারেটরের উপর বারবার <code>next</code> কল করলে কী মান রিটার্ন হয়।</p>
<Listing number="13-12" file-name="src/lib.rs" caption="একটি ইটারেটরের উপর `next` মেথড কল করা">
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_demonstration() {
        let v1 = vec![1, 2, 3];

        let mut v1_iter = v1.iter();

        assert_eq!(v1_iter.next(), Some(&amp;1));
        assert_eq!(v1_iter.next(), Some(&amp;2));
        assert_eq!(v1_iter.next(), Some(&amp;3));
        assert_eq!(v1_iter.next(), None);
    }
<span class="boring">}</span></code></pre>
</Listing>
<p>লক্ষ্য করুন যে আমাদের <code>v1_iter</code>-কে মিউটেবল (mutable) করতে হয়েছিল: একটি ইটারেটরের উপর <code>next</code> মেথড কল করলে এর অভ্যন্তরীণ অবস্থা পরিবর্তিত হয়, যা ইটারেটর সিকোয়েন্সে তার অবস্থান ট্র্যাক করতে ব্যবহার করে। অন্য কথায়, এই কোডটি ইটারেটরটিকে <em>কনজিউম</em> (consumes) বা ব্যবহার করে ফেলে। প্রতিটি <code>next</code> কল ইটারেটর থেকে একটি আইটেম গ্রহণ করে। <code>for</code> লুপ ব্যবহার করার সময় আমাদের <code>v1_iter</code>-কে মিউটেবল করতে হয়নি কারণ লুপটি <code>v1_iter</code>-এর মালিকানা নিয়ে পর্দার আড়ালে এটিকে মিউটেবল করে দিয়েছিল।</p>
<p>আরও লক্ষ্য করুন যে <code>next</code> কল থেকে আমরা যে মানগুলো পাই তা ভেক্টরের মানগুলোর ইমিউটেবল রেফারেন্স (immutable references)। <code>iter</code> মেথড ইমিউটেবল রেফারেন্সের উপর একটি ইটারেটর তৈরি করে। যদি আমরা এমন একটি ইটারেটর তৈরি করতে চাই যা <code>v1</code>-এর মালিকানা নেয় এবং ওউনড ভ্যালু (owned values) রিটার্ন করে, তাহলে আমরা <code>iter</code>-এর পরিবর্তে <code>into_iter</code> কল করতে পারি। একইভাবে, যদি আমরা মিউটেবল রেফারেন্সের উপর ইটারেট করতে চাই, তাহলে আমরা <code>iter</code>-এর পরিবর্তে <code>iter_mut</code> কল করতে পারি।</p>
<h3 id="যে-মেথডগুলো-ইটারেটরকে-বযবহার-করে-ফেলে-consume"><a class="header" href="#যে-মেথডগুলো-ইটারেটরকে-বযবহার-করে-ফেলে-consume">যে মেথডগুলো ইটারেটরকে ব্যবহার করে ফেলে (consume)</a></h3>
<p><code>Iterator</code> ট্রেইটে স্ট্যান্ডার্ড লাইব্রেরি দ্বারা সরবরাহ করা ডিফল্ট ইমপ্লিমেন্টেশনসহ বেশ কয়েকটি ভিন্ন মেথড রয়েছে; আপনি <code>Iterator</code> ট্রেইটের জন্য স্ট্যান্ডার্ড লাইব্রেরি API ডকুমেন্টেশনে এই মেথডগুলো সম্পর্কে জানতে পারবেন। এই মেথডগুলোর মধ্যে কিছু তাদের ডেফিনিশনে <code>next</code> মেথডকে কল করে, যে কারণে <code>Iterator</code> ট্রেইট ইমপ্লিমেন্ট করার সময় আপনাকে <code>next</code> মেথড ইমপ্লিমেন্ট করতে হয়।</p>
<p>যে মেথডগুলো <code>next</code> কল করে, সেগুলোকে <em>কনজিউমিং অ্যাডাপ্টার</em> (consuming adapters) বলা হয়, কারণ এগুলো কল করলে ইটারেটরটি ব্যবহৃত হয়ে যায়। একটি উদাহরণ হলো <code>sum</code> মেথড, যা ইটারেটরের মালিকানা নেয় এবং বারবার <code>next</code> কল করে আইটেমগুলোর মধ্য দিয়ে ইটারেট করে, ফলে ইটারেটরটি ব্যবহৃত হয়। এটি ইটারেট করার সময় প্রতিটি আইটেমকে একটি চলমান মোটের সাথে যোগ করে এবং ইটারেশন সম্পূর্ণ হলে মোটটি রিটার্ন করে। Listing 13-13-এ <code>sum</code> মেথডের ব্যবহার দেখানো একটি টেস্ট রয়েছে।</p>
<Listing number="13-13" file-name="src/lib.rs" caption="ইটারেটরের সমস্ত আইটেমের যোগফল পেতে `sum` মেথড কল করা">
<pre><code class="language-rust noplayground"><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span>    #[test]
    fn iterator_sum() {
        let v1 = vec![1, 2, 3];

        let v1_iter = v1.iter();

        let total: i32 = v1_iter.sum();

        assert_eq!(total, 6);
    }
<span class="boring">}</span></code></pre>
</Listing>
<p><code>sum</code> কল করার পরে আমরা <code>v1_iter</code> ব্যবহার করতে পারব না কারণ <code>sum</code> যে ইটারেটরের উপর কল করা হয় তার মালিকানা নিয়ে নেয়।</p>
<h3 id="যে-মেথডগুলো-অনয-ইটারেটর-তৈরি-করে"><a class="header" href="#যে-মেথডগুলো-অনয-ইটারেটর-তৈরি-করে">যে মেথডগুলো অন্য ইটারেটর তৈরি করে</a></h3>
<p><em>ইটারেটর অ্যাডাপ্টার</em> (Iterator adapters) হলো <code>Iterator</code> ট্রেইটে ডিফাইন করা এমন মেথড যা ইটারেটরকে ব্যবহার করে না। বরং, এগুলো মূল ইটারেটরের কিছু দিক পরিবর্তন করে ভিন্ন ইটারেটর তৈরি করে।</p>
<p>Listing 13-14 ইটারেটর অ্যাডাপ্টার মেথড <code>map</code> কল করার একটি উদাহরণ দেখায়, যা একটি ক্লোজার নেয় এবং আইটেমগুলোর উপর ইটারেট করার সময় প্রতিটি আইটেমের উপর সেই ক্লোজারকে কল করে। <code>map</code> মেথড একটি নতুন ইটারেটর রিটার্ন করে যা পরিবর্তিত আইটেমগুলো তৈরি করে। এখানকার ক্লোজারটি একটি নতুন ইটারেটর তৈরি করে যেখানে ভেক্টরের প্রতিটি আইটেমের মান ১ করে বাড়ানো হবে।</p>
<Listing number="13-14" file-name="src/main.rs" caption="একটি নতুন ইটারেটর তৈরি করতে ইটারেটর অ্যাডাপ্টার `map` কল করা">
<pre><pre class="playground"><code class="language-rust not_desired_behavior edition2024"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    v1.iter().map(|x| x + 1);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>তবে, এই কোডটি একটি সতর্কবার্তা (warning) তৈরি করে:</p>
<pre><code class="language-console">$ cargo run
   Compiling iterators v0.1.0 (file:///projects/iterators)
warning: unused `Map` that must be used
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: iterators are lazy and do nothing unless consumed
  = note: `#[warn(unused_must_use)]` on by default
help: use `let _ = ...` to ignore the resulting value
  |
4 |     let _ = v1.iter().map(|x| x + 1);
  |     +++++++

warning: `iterators` (bin "iterators") generated 1 warning
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/iterators`
</code></pre>
<p>Listing 13-14-এর কোডটি কিছুই করে না; আমরা যে ক্লোজারটি নির্দিষ্ট করেছি তা কখনই কল করা হয় না। সতর্কবার্তাটি আমাদের মনে করিয়ে দেয় কেন: ইটারেটর অ্যাডাপ্টারগুলো lazy, এবং আমাদের এখানে ইটারেটরটি ব্যবহার করতে হবে।</p>
<p>এই সতর্কবার্তাটি ঠিক করতে এবং ইটারেটরটি ব্যবহার করতে, আমরা <code>collect</code> মেথড ব্যবহার করব, যা আমরা Listing 12-1-এ <code>env::args</code>-এর সাথে ব্যবহার করেছিলাম। এই মেথডটি ইটারেটরকে ব্যবহার করে এবং ফলস্বরূপ মানগুলোকে একটি কালেকশন ডেটা টাইপে সংগ্রহ করে।</p>
<p>Listing 13-15-এ, আমরা <code>map</code> কল থেকে রিটার্ন করা ইটারেটরের উপর ইটারেট করার ফলাফল একটি ভেক্টরে সংগ্রহ করি। এই ভেক্টরটিতে মূল ভেক্টরের প্রতিটি আইটেম থাকবে, যার মান ১ করে বাড়ানো হয়েছে।</p>
<Listing number="13-15" file-name="src/main.rs" caption="একটি নতুন ইটারেটর তৈরি করতে `map` মেথড কল করা, এবং তারপর নতুন ইটারেটরটি ব্যবহার করে একটি ভেক্টর তৈরি করতে `collect` মেথড কল করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>যেহেতু <code>map</code> একটি ক্লোজার নেয়, তাই আমরা প্রতিটি আইটেমের উপর যেকোনো অপারেশন নির্দিষ্ট করতে পারি। এটি একটি চমৎকার উদাহরণ যে কীভাবে ক্লোজার আপনাকে কিছু আচরণ কাস্টমাইজ করতে দেয় এবং একই সাথে <code>Iterator</code> ট্রেইট দ্বারা প্রদত্ত ইটারেশন আচরণটি পুনরায় ব্যবহার করতে দেয়।</p>
<p>আপনি একাধিক ইটারেটর অ্যাডাপ্টার কল চেইন করে জটিল কাজগুলো একটি পঠনযোগ্য উপায়ে সম্পাদন করতে পারেন। কিন্তু যেহেতু সমস্ত ইটারেটর lazy, তাই ইটারেটর অ্যাডাপ্টার কল থেকে ফলাফল পেতে আপনাকে কনজিউমিং অ্যাডাপ্টার মেথডগুলোর একটি কল করতে হবে।</p>
<h3 id="এনভাযরনমেনট-কযাপচার-করে-এমন-কলোজার-বযবহার-করা"><a class="header" href="#এনভাযরনমেনট-কযাপচার-করে-এমন-কলোজার-বযবহার-করা">এনভায়রনমেন্ট ক্যাপচার করে এমন ক্লোজার ব্যবহার করা</a></h3>
<p>অনেক ইটারেটর অ্যাডাপ্টার আর্গুমেন্ট হিসেবে ক্লোজার নেয়, এবং সাধারণত আমরা ইটারেটর অ্যাডাপ্টারের আর্গুমেন্ট হিসেবে যে ক্লোজারগুলো নির্দিষ্ট করব তা তাদের এনভায়রনমেন্ট ক্যাপচার করে।</p>
<p>এই উদাহরণের জন্য, আমরা <code>filter</code> মেথড ব্যবহার করব যা একটি ক্লোজার নেয়। ক্লোজারটি ইটারেটর থেকে একটি আইটেম পায় এবং একটি <code>bool</code> রিটার্ন করে। যদি ক্লোজারটি <code>true</code> রিটার্ন করে, তবে মানটি <code>filter</code> দ্বারা উৎপাদিত ইটারেশনে অন্তর্ভুক্ত হবে। যদি ক্লোজারটি <code>false</code> রিটার্ন করে, তবে মানটি অন্তর্ভুক্ত হবে না।</p>
<p>Listing 13-16-এ, আমরা <code>filter</code> ব্যবহার করি একটি ক্লোজারের সাথে যা তার এনভায়রনমেন্ট থেকে <code>shoe_size</code> ভ্যারিয়েবলটি ক্যাপচার করে <code>Shoe</code> struct ইনস্ট্যান্সের একটি কালেকশনের উপর ইটারেট করার জন্য। এটি শুধুমাত্র নির্দিষ্ট আকারের জুতা রিটার্ন করবে।</p>
<Listing number="13-16" file-name="src/lib.rs" caption="`shoe_size` ক্যাপচার করে এমন একটি ক্লোজারের সাথে `filter` মেথড ব্যবহার করা">
<pre><code class="language-rust noplayground">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn filters_by_size() {
        let shoes = vec![
            Shoe {
                size: 10,
                style: String::from("sneaker"),
            },
            Shoe {
                size: 13,
                style: String::from("sandal"),
            },
            Shoe {
                size: 10,
                style: String::from("boot"),
            },
        ];

        let in_my_size = shoes_in_size(shoes, 10);

        assert_eq!(
            in_my_size,
            vec![
                Shoe {
                    size: 10,
                    style: String::from("sneaker")
                },
                Shoe {
                    size: 10,
                    style: String::from("boot")
                },
            ]
        );
    }
}</code></pre>
</Listing>
<p><code>shoes_in_size</code> ফাংশনটি প্যারামিটার হিসেবে একটি জুতার ভেক্টরের মালিকানা এবং একটি জুতার সাইজ নেয়। এটি শুধুমাত্র নির্দিষ্ট আকারের জুতা ধারণকারী একটি ভেক্টর রিটার্ন করে।</p>
<p><code>shoes_in_size</code>-এর বডিতে, আমরা <code>into_iter</code> কল করে একটি ইটারেটর তৈরি করি যা ভেক্টরের মালিকানা নেয়। তারপর আমরা <code>filter</code> কল করে সেই ইটারেটরটিকে একটি নতুন ইটারেটরে অ্যাডাপ্ট করি যা শুধুমাত্র সেই এলিমেন্টগুলো ধারণ করে যার জন্য ক্লোজারটি <code>true</code> রিটার্ন করে।</p>
<p>ক্লোজারটি এনভায়রনমেন্ট থেকে <code>shoe_size</code> প্যারামিটারটি ক্যাপচার করে এবং প্রতিটি জুতার আকারের সাথে মানটি তুলনা করে, শুধুমাত্র নির্দিষ্ট আকারের জুতাগুলো রাখে। অবশেষে, <code>collect</code> কল করা অ্যাডাপ্টেড ইটারেটর দ্বারা রিটার্ন করা মানগুলোকে একটি ভেক্টরে সংগ্রহ করে যা ফাংশন দ্বারা রিটার্ন করা হয়।</p>
<p>টেস্টটি দেখায় যে যখন আমরা <code>shoes_in_size</code> কল করি, তখন আমরা শুধুমাত্র সেই জুতাগুলো ফেরত পাই যেগুলোর আকার আমাদের নির্দিষ্ট করা মানের সমান।</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-01-closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch13-03-improving-our-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-01-closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch13-03-improving-our-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
