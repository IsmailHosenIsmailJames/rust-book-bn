<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>একটি Enum ডিফাইন করা - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="একটি-enum-ডিফাইন-করা"><a class="header" href="#একটি-enum-ডিফাইন-করা">একটি Enum ডিফাইন করা</a></h2>
<p>যেখানে <code>struct</code> আপনাকে সম্পর্কিত field এবং data-কে একসাথে গ্রুপ করার একটি উপায় দেয়, যেমন একটি <code>Rectangle</code> এর <code>width</code> এবং <code>height</code>, সেখানে <code>enum</code> আপনাকে বলার একটি উপায় দেয় যে একটি value একটি সম্ভাব্য সেটের মধ্যে একটি। উদাহরণস্বরূপ, আমরা বলতে পারি যে <code>Rectangle</code> একটি সম্ভাব্য shape-এর সেট-এর মধ্যে একটি, যার মধ্যে <code>Circle</code> এবং <code>Triangle</code>-ও রয়েছে। এটি করার জন্য, Rust আমাদের এই সম্ভাবনাগুলোকে একটি enum হিসাবে এনকোড করার অনুমতি দেয়।</p>
<p>আসুন আমরা এমন একটি পরিস্থিতি দেখি যা আমরা কোডে প্রকাশ করতে চাই এবং দেখি কেন এই ক্ষেত্রে struct-এর চেয়ে enum বেশি উপযোগী এবং উপযুক্ত। ধরুন আমাদের IP address নিয়ে কাজ করতে হবে। বর্তমানে, IP address-এর জন্য দুটি প্রধান standard ব্যবহৃত হয়: ভার্সন ফোর এবং ভার্সন সিক্স। যেহেতু আমাদের প্রোগ্রামে একটি IP address-এর জন্য এই দুটিই একমাত্র সম্ভাবনা, তাই আমরা সমস্ত সম্ভাব্য variant-গুলোকে <em>enumerate</em> বা গণনা করতে পারি, যেখান থেকে enumeration নামটি এসেছে।</p>
<p>যেকোনো IP address হয় ভার্সন ফোর বা ভার্সন সিক্স হতে পারে, কিন্তু একই সাথে উভয়ই হতে পারে না। IP address-এর এই বৈশিষ্ট্যটি enum ডেটা স্ট্রাকচারকে উপযুক্ত করে তোলে কারণ একটি enum value তার variant-গুলোর মধ্যে শুধুমাত্র একটি হতে পারে। ভার্সন ফোর এবং ভার্সন সিক্স উভয় address-ই এখনও মৌলিকভাবে IP address, তাই যখন কোডটি যেকোনো ধরনের IP address-এর জন্য প্রযোজ্য পরিস্থিতি পরিচালনা করে, তখন তাদের একই type হিসাবে গণ্য করা উচিত।</p>
<p>আমরা এই ধারণাটি কোডে প্রকাশ করতে পারি একটি <code>IpAddrKind</code> enum ডিফাইন করে এবং একটি IP address-এর সম্ভাব্য প্রকার <code>V4</code> এবং <code>V6</code>-কে তালিকাভুক্ত করে। এগুলি হলো enum-এর variant:</p>
<pre><pre class="playground"><code class="language-rust edition2024">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p><code>IpAddrKind</code> এখন একটি কাস্টম ডেটা type যা আমরা আমাদের কোডের অন্য কোথাও ব্যবহার করতে পারি।</p>
<h3 id="enum-ভযালু"><a class="header" href="#enum-ভযালু">Enum ভ্যালু</a></h3>
<p>আমরা <code>IpAddrKind</code>-এর দুটি variant-এর প্রত্যেকটির instance এভাবে তৈরি করতে পারি:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>লক্ষ্য করুন যে enum-এর variant-গুলো তার আইডেন্টিফায়ারের অধীনে namespaced থাকে এবং আমরা দুটিকে আলাদা করতে একটি ডাবল কোলন (::) ব্যবহার করি। এটি দরকারী কারণ এখন <code>IpAddrKind::V4</code> এবং <code>IpAddrKind::V6</code> উভয়ই একই type-এর: <code>IpAddrKind</code>। এর ফলে আমরা, উদাহরণস্বরূপ, একটি function ডিফাইন করতে পারি যা যেকোনো <code>IpAddrKind</code> গ্রহণ করে:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}</code></pre></pre>
<p>এবং আমরা এই function-টিকে যেকোনো variant দিয়ে কল করতে পারি:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}</span></code></pre></pre>
<p>enum ব্যবহার করার আরও সুবিধা আছে। আমাদের IP address type সম্পর্কে আরও ভাবলে দেখা যায়, এই মুহূর্তে আমাদের কাছে আসল IP address <em>data</em> সংরক্ষণ করার কোনো উপায় নেই; আমরা কেবল জানি এটি কোন <em>kind</em> বা প্রকারের। চ্যাপ্টার ৫-এ আপনি যেহেতু struct সম্পর্কে শিখেছেন, আপনি হয়তো এই সমস্যাটি struct দিয়ে সমাধান করার চেষ্টা করতে পারেন, যেমনটি লিস্টিং ৬-১ এ দেখানো হয়েছে।</p>
<Listing number="6-1" caption="একটি `struct` ব্যবহার করে IP address-এর data এবং `IpAddrKind` variant সংরক্ষণ করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddrKind {
        V4,
        V6,
    }

    struct IpAddr {
        kind: IpAddrKind,
        address: String,
    }

    let home = IpAddr {
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6,
        address: String::from("::1"),
    };
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>এখানে, আমরা একটি <code>IpAddr</code> struct ডিফাইন করেছি যার দুটি field আছে: একটি <code>kind</code> field যা <code>IpAddrKind</code> type-এর (আমাদের আগে ডিফাইন করা enum) এবং একটি <code>address</code> field যা <code>String</code> type-এর। আমাদের এই struct-এর দুটি instance আছে। প্রথমটি হলো <code>home</code>, এবং এটির <code>kind</code> হিসেবে <code>IpAddrKind::V4</code> এবং এর সাথে সম্পর্কিত address data হিসেবে <code>127.0.0.1</code> আছে। দ্বিতীয় instance হলো <code>loopback</code>। এটির <code>kind</code> হিসেবে <code>IpAddrKind</code>-এর অন্য variant, <code>V6</code> আছে এবং এর সাথে <code>::1</code> address সম্পর্কিত আছে। আমরা <code>kind</code> এবং <code>address</code> value-গুলোকে একসাথে বান্ডিল করতে একটি struct ব্যবহার করেছি, তাই এখন variant-টি value-এর সাথে সম্পর্কিত।</p>
<p>যাইহোক, শুধু একটি enum ব্যবহার করে একই ধারণা প্রকাশ করা আরও সংক্ষিপ্ত: একটি struct-এর ভিতরে enum না রেখে, আমরা সরাসরি প্রতিটি enum variant-এর মধ্যে data রাখতে পারি। <code>IpAddr</code> enum-এর এই নতুন সংজ্ঞাটি বলছে যে <code>V4</code> এবং <code>V6</code> উভয় variant-এর সাথেই <code>String</code> value যুক্ত থাকবে:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(String),
        V6(String),
    }

    let home = IpAddr::V4(String::from("127.0.0.1"));

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>আমরা সরাসরি enum-এর প্রতিটি variant-এর সাথে data সংযুক্ত করি, তাই অতিরিক্ত struct-এর কোনো প্রয়োজন নেই। এখানে, enum কিভাবে কাজ করে তার আরেকটি বিস্তারিত দিক দেখাও সহজ: আমরা যে প্রতিটি enum variant ডিফাইন করি তার নামও একটি function হয়ে যায় যা enum-এর একটি instance তৈরি করে। অর্থাৎ, <code>IpAddr::V4()</code> একটি function কল যা একটি <code>String</code> আর্গুমেন্ট নেয় এবং <code>IpAddr</code> type-এর একটি instance রিটার্ন করে। enum ডিফাইন করার ফলে আমরা স্বয়ংক্রিয়ভাবে এই constructor function-টি পেয়ে যাই।</p>
<p>struct-এর চেয়ে enum ব্যবহার করার আরেকটি সুবিধা হলো: প্রতিটি variant-এর সাথে বিভিন্ন type এবং পরিমাণের data যুক্ত থাকতে পারে। ভার্সন ফোর IP address-এ সবসময় চারটি সাংখ্যিক কম্পোনেন্ট থাকবে যার মান ০ থেকে ২৫৫ এর মধ্যে হবে। যদি আমরা <code>V4</code> address-কে চারটি <code>u8</code> মান হিসেবে সংরক্ষণ করতে চাই কিন্তু <code>V6</code> address-কে একটি <code>String</code> মান হিসাবেই প্রকাশ করতে চাই, তবে আমরা একটি struct দিয়ে তা করতে পারতাম না। enum এই কাজটি সহজেই করতে পারে:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from("::1"));
<span class="boring">}</span></code></pre></pre>
<p>আমরা ভার্সন ফোর এবং ভার্সন সিক্স IP address সংরক্ষণ করার জন্য ডেটা স্ট্রাকচার ডিফাইন করার বিভিন্ন উপায় দেখিয়েছি। তবে, দেখা যাচ্ছে যে IP address সংরক্ষণ করা এবং সেগুলি কোন প্রকারের তা এনকোড করার প্রয়োজনীয়তা এতটাই সাধারণ যে <a href="../std/net/enum.IpAddr.html">স্ট্যান্ডার্ড লাইব্রেরিতে আমাদের ব্যবহারের জন্য একটি সংজ্ঞা রয়েছে!</a><!-- ignore --> আসুন দেখি স্ট্যান্ডার্ড লাইব্রেরি কিভাবে <code>IpAddr</code> ডিফাইন করে: এটিতে আমাদের ডিফাইন করা এবং ব্যবহৃত enum এবং variant-গুলোই আছে, তবে এটি variant-গুলোর ভিতরে address data দুটি ভিন্ন struct-এর আকারে এম্বেড করে, যা প্রতিটি variant-এর জন্য ভিন্নভাবে ডিফাইন করা হয়েছে:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}</span></code></pre></pre>
<p>এই কোডটি দেখায় যে আপনি একটি enum variant-এর ভিতরে যেকোনো ধরনের ডেটা রাখতে পারেন: উদাহরণস্বরূপ, স্ট্রিং, নিউমেরিক টাইপ, বা struct। এমনকি আপনি অন্য একটি enum-ও অন্তর্ভুক্ত করতে পারেন! এছাড়াও, স্ট্যান্ডার্ড লাইব্রেরির type-গুলো প্রায়শই আপনার নিজের ভাবনার চেয়ে খুব বেশি জটিল হয় না।</p>
<p>লক্ষ্য করুন যে যদিও স্ট্যান্ডার্ড লাইব্রেরিতে <code>IpAddr</code>-এর একটি সংজ্ঞা রয়েছে, আমরা এখনও কোনো conflict ছাড়াই আমাদের নিজস্ব সংজ্ঞা তৈরি এবং ব্যবহার করতে পারি কারণ আমরা স্ট্যান্ডার্ড লাইব্রেরির সংজ্ঞাটি আমাদের স্কোপে নিয়ে আসিনি। আমরা চ্যাপ্টার ৭-এ স্কোপে type নিয়ে আসার বিষয়ে আরও আলোচনা করব।</p>
<p>আসুন লিস্টিং ৬-২-এ enum-এর আরেকটি উদাহরণ দেখি: এটিতে এর variant-গুলোর মধ্যে বিভিন্ন ধরণের type এম্বেড করা আছে।</p>
<Listing number="6-2" caption="একটি `Message` enum যার প্রতিটি variant বিভিন্ন পরিমাণ এবং ধরনের মান সংরক্ষণ করে">
<pre><pre class="playground"><code class="language-rust edition2024">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
</Listing>
<p>এই enum-টির চারটি variant আছে এবং তাদের সাথে বিভিন্ন ধরনের ডেটা যুক্ত আছে:</p>
<ul>
<li><code>Quit</code>: এর সাথে কোনো ডেটা যুক্ত নেই।</li>
<li><code>Move</code>: এর মধ্যে struct-এর মতো named field আছে।</li>
<li><code>Write</code>: একটি <code>String</code> অন্তর্ভুক্ত করে।</li>
<li><code>ChangeColor</code>: তিনটি <code>i32</code> মান অন্তর্ভুক্ত করে।</li>
</ul>
<p>লিস্টিং ৬-২-এর মতো variant সহ একটি enum ডিফাইন করা বিভিন্ন ধরণের struct ডিফাইন করার মতোই, তবে enum <code>struct</code> কীওয়ার্ড ব্যবহার করে না এবং সমস্ত variant <code>Message</code> type-এর অধীনে একসাথে গ্রুপ করা হয়। নিম্নলিখিত struct-গুলো পূর্ববর্তী enum variant-গুলোর মতো একই ডেটা ধারণ করতে পারত:</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>কিন্তু যদি আমরা বিভিন্ন struct ব্যবহার করতাম, যার প্রত্যেকটির নিজস্ব type আছে, আমরা তত সহজে একটি function ডিফাইন করতে পারতাম না যা এই ধরনের যেকোনো message নিতে পারে, যেমনটা আমরা লিস্টিং ৬-২-এ ডিফাইন করা <code>Message</code> enum দিয়ে করতে পারি, যা একটি একক type।</p>
<p>enum এবং struct-এর মধ্যে আরও একটি মিল আছে: ঠিক যেমন আমরা <code>impl</code> ব্যবহার করে struct-এর উপর মেথড ডিফাইন করতে পারি, তেমনি আমরা enum-এর উপরও মেথড ডিফাইন করতে পারি। এখানে <code>call</code> নামে একটি মেথড রয়েছে যা আমরা আমাদের <code>Message</code> enum-এ ডিফাইন করতে পারি:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // method body would be defined here
        }
    }

    let m = Message::Write(String::from("hello"));
    m.call();
<span class="boring">}</span></code></pre></pre>
<p>মেথডটির বডি <code>self</code> ব্যবহার করে সেই মানটি পাবে যার উপর আমরা মেথডটি কল করেছি। এই উদাহরণে, আমরা একটি ভেরিয়েবল <code>m</code> তৈরি করেছি যার মান <code>Message::Write(String::from("hello"))</code>, এবং যখন <code>m.call()</code> চালানো হবে, তখন <code>call</code> মেথডের বডিতে <code>self</code> এটিই হবে।</p>
<p>আসুন স্ট্যান্ডার্ড লাইব্রেরির আরেকটি enum দেখি যা খুব সাধারণ এবং দরকারী: <code>Option</code>।</p>
<h3 id="option-enum-এবং-null-ভযালুর-উপর-এর-সুবিধা"><a class="header" href="#option-enum-এবং-null-ভযালুর-উপর-এর-সুবিধা"><code>Option</code> Enum এবং Null ভ্যালুর উপর এর সুবিধা</a></h3>
<p>এই বিভাগটি <code>Option</code>-এর একটি কেস স্টাডি নিয়ে আলোচনা করে, যা স্ট্যান্ডার্ড লাইব্রেরি দ্বারা ডিফাইন করা আরেকটি enum। <code>Option</code> type-টি একটি খুব সাধারণ পরিস্থিতি এনকোড করে যেখানে একটি মান কিছু একটা হতে পারে বা কিছুই নাও হতে পারে।</p>
<p>উদাহরণস্বরূপ, যদি আপনি একটি খালি নয় এমন লিস্ট থেকে প্রথম আইটেমটি অনুরোধ করেন, আপনি একটি মান পাবেন। যদি আপনি একটি খালি লিস্ট থেকে প্রথম আইটেমটি অনুরোধ করেন, আপনি কিছুই পাবেন না। এই ধারণাটিকে type সিস্টেমের ভাষায় প্রকাশ করার অর্থ হলো compiler পরীক্ষা করতে পারে যে আপনি সমস্ত প্রয়োজনীয় কেসগুলি হ্যান্ডেল করেছেন কিনা; এই কার্যকারিতাটি অন্যান্য প্রোগ্রামিং ভাষায় অত্যন্ত সাধারণ বাগ প্রতিরোধ করতে পারে।</p>
<p>প্রোগ্রামিং ভাষার ডিজাইন প্রায়শই কোন বৈশিষ্ট্যগুলি অন্তর্ভুক্ত করা হয় তার উপর ভিত্তি করে ভাবা হয়, তবে কোন বৈশিষ্ট্যগুলি বাদ দেওয়া হয় তাও গুরুত্বপূর্ণ। Rust-এ <code>null</code> বৈশিষ্ট্যটি নেই যা অনেক অন্যান্য ভাষায় রয়েছে। <em>Null</em> হলো এমন একটি মান যার অর্থ সেখানে কোনো মান নেই। যেসব ভাষায় <code>null</code> আছে, সেখানে ভেরিয়েবল সবসময় দুটি অবস্থার একটিতে থাকতে পারে: <code>null</code> অথবা <code>not-null</code>।</p>
<p>তার ২০০৯ সালের উপস্থাপনা "Null References: The Billion Dollar Mistake"-এ, <code>null</code>-এর উদ্ভাবক টনি হোর একথা বলেছিলেন:</p>
<blockquote>
<p>আমি এটাকে আমার বিলিয়ন-ডলারের ভুল বলি। সেই সময়ে, আমি একটি অবজেক্ট-ওরিয়েন্টেড ভাষার জন্য রেফারেন্সের প্রথম ব্যাপক টাইপ সিস্টেম ডিজাইন করছিলাম। আমার লক্ষ্য ছিল নিশ্চিত করা যে রেফারেন্সের সমস্ত ব্যবহার একেবারে নিরাপদ হবে, এবং compiler দ্বারা স্বয়ংক্রিয়ভাবে পরীক্ষা করা হবে। কিন্তু আমি একটি null রেফারেন্স রাখার লোভ সামলাতে পারিনি, কারণ এটি বাস্তবায়ন করা খুব সহজ ছিল। এটি অগণিত ভুল, দুর্বলতা এবং সিস্টেম ক্র্যাশের কারণ হয়েছে, যা সম্ভবত গত চল্লিশ বছরে এক বিলিয়ন ডলারের কষ্ট ও ক্ষতির কারণ হয়েছে।</p>
</blockquote>
<p><code>null</code> মানের সমস্যা হলো যে যদি আপনি একটি <code>null</code> মানকে <code>not-null</code> মান হিসাবে ব্যবহার করার চেষ্টা করেন, তবে আপনি কোনো না কোনো ধরনের একটি error পাবেন। যেহেতু এই <code>null</code> বা <code>not-null</code> বৈশিষ্ট্যটি সর্বব্যাপী, তাই এই ধরনের ভুল করা অত্যন্ত সহজ।</p>
<p>তবে, <code>null</code> যে ধারণাটি প্রকাশ করার চেষ্টা করে তা এখনও একটি দরকারী ধারণা: একটি <code>null</code> হলো এমন একটি মান যা বর্তমানে কোনো কারণে অবৈধ বা অনুপস্থিত।</p>
<p>সমস্যাটি আসলে ধারণার সাথে নয়, বরং নির্দিষ্ট বাস্তবায়নের সাথে। তাই, Rust-এ <code>null</code> নেই, তবে এটিতে একটি enum রয়েছে যা একটি মানের উপস্থিতি বা অনুপস্থিতির ধারণাটি এনকোড করতে পারে। এই enum-টি হলো <code>Option&lt;T&gt;</code>, এবং এটি <a href="../std/option/enum.Option.html">স্ট্যান্ডার্ড লাইব্রেরি দ্বারা ডিফাইন করা হয়েছে</a><!-- ignore --> এভাবে:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p><code>Option&lt;T&gt;</code> enum-টি এতটাই দরকারী যে এটি প্রিলিউডেও অন্তর্ভুক্ত করা হয়েছে; আপনাকে এটিকে স্পষ্টভাবে স্কোপে আনতে হবে না। এর variant-গুলোও প্রিলিউডে অন্তর্ভুক্ত: আপনি <code>Option::</code> উপসর্গ ছাড়াই সরাসরি <code>Some</code> এবং <code>None</code> ব্যবহার করতে পারেন। <code>Option&lt;T&gt;</code> enum-টি এখনও একটি সাধারণ enum, এবং <code>Some(T)</code> ও <code>None</code> এখনও <code>Option&lt;T&gt;</code> type-এর variant।</p>
<p><code>&lt;T&gt;</code> সিনট্যাক্সটি Rust-এর একটি বৈশিষ্ট্য যা নিয়ে আমরা এখনও কথা বলিনি। এটি একটি জেনেরিক টাইপ প্যারামিটার, এবং আমরা চ্যাপ্টার ১০-এ জেনেরিক সম্পর্কে আরও বিস্তারিত আলোচনা করব। আপাতত, আপনাকে শুধু জানতে হবে যে <code>&lt;T&gt;</code> মানে <code>Option</code> enum-এর <code>Some</code> variant যেকোনো type-এর ডেটার একটি অংশ ধারণ করতে পারে, এবং <code>T</code>-এর পরিবর্তে ব্যবহৃত প্রতিটি সুনির্দিষ্ট type সামগ্রিক <code>Option&lt;T&gt;</code> type-কে একটি ভিন্ন type-এ পরিণত করে। এখানে সংখ্যা এবং ক্যারেক্টার type ধারণ করার জন্য <code>Option</code> মান ব্যবহার করার কিছু উদাহরণ দেওয়া হলো:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p><code>some_number</code>-এর type হলো <code>Option&lt;i32&gt;</code>। <code>some_char</code>-এর type হলো <code>Option&lt;char&gt;</code>, যা একটি ভিন্ন type। Rust এই type-গুলো অনুমান করতে পারে কারণ আমরা <code>Some</code> variant-এর ভিতরে একটি মান নির্দিষ্ট করেছি। <code>absent_number</code>-এর জন্য, Rust আমাদের সামগ্রিক <code>Option</code> type-টি annotate করতে বলে: compiler শুধুমাত্র একটি <code>None</code> মান দেখে সংশ্লিষ্ট <code>Some</code> variant কোন type ধারণ করবে তা অনুমান করতে পারে না। এখানে, আমরা Rust-কে বলি যে আমরা <code>absent_number</code>-কে <code>Option&lt;i32&gt;</code> type-এর হিসাবে বোঝাতে চাই।</p>
<p>যখন আমাদের কাছে একটি <code>Some</code> মান থাকে, আমরা জানি যে একটি মান উপস্থিত আছে এবং মানটি <code>Some</code>-এর ভিতরে রয়েছে। যখন আমাদের কাছে একটি <code>None</code> মান থাকে, তখন এটি某种 অর্থে <code>null</code>-এর মতোই: আমাদের কাছে একটি বৈধ মান নেই। তাহলে <code>Option&lt;T&gt;</code> থাকাটা <code>null</code> থাকার চেয়ে ভালো কেন?</p>
<p>সংক্ষেপে, কারণ <code>Option&lt;T&gt;</code> এবং <code>T</code> (যেখানে <code>T</code> যেকোনো type হতে পারে) ভিন্ন type, তাই compiler আমাদের একটি <code>Option&lt;T&gt;</code> মানকে এমনভাবে ব্যবহার করতে দেবে না যেন এটি অবশ্যই একটি বৈধ মান। উদাহরণস্বরূপ, এই কোডটি কম্পাইল হবে না, কারণ এটি একটি <code>i8</code>-কে একটি <code>Option&lt;i8&gt;</code>-এর সাথে যোগ করার চেষ্টা করছে:</p>
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
<span class="boring">}</span></code></pre>
<p>যদি আমরা এই কোডটি চালাই, আমরা এই ধরনের একটি error বার্তা পাই:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`
  |
  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`
  = help: the following other types implement trait `Add&lt;Rhs&gt;`:
            `&amp;i8` implements `Add&lt;i8&gt;`
            `&amp;i8` implements `Add`
            `i8` implements `Add&lt;&amp;i8&gt;`
            `i8` implements `Add`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums` (bin "enums") due to 1 previous error
</code></pre>
<p>ব্যাপক! কার্যতঃ, এই error বার্তাটির অর্থ হলো Rust বুঝতে পারছে না কিভাবে একটি <code>i8</code> এবং একটি <code>Option&lt;i8&gt;</code> যোগ করতে হয়, কারণ তারা ভিন্ন type। যখন আমাদের কাছে Rust-এ <code>i8</code>-এর মতো কোনো type-এর মান থাকে, তখন compiler নিশ্চিত করবে যে আমাদের কাছে সবসময় একটি বৈধ মান আছে। আমরা সেই মানটি ব্যবহার করার আগে <code>null</code>-এর জন্য পরীক্ষা না করেই আত্মবিশ্বাসের সাথে এগিয়ে যেতে পারি। শুধুমাত্র যখন আমাদের কাছে একটি <code>Option&lt;i8&gt;</code> থাকে (বা আমরা যে ধরনের মান নিয়ে কাজ করছি), তখনই আমাদের একটি মান না থাকার সম্ভাবনা নিয়ে চিন্তা করতে হয়, এবং compiler নিশ্চিত করবে যে আমরা মানটি ব্যবহার করার আগে সেই পরিস্থিতিটি হ্যান্ডেল করি।</p>
<p>অন্য কথায়, <code>T</code> অপারেশন সম্পাদন করার আগে আপনাকে একটি <code>Option&lt;T&gt;</code>-কে <code>T</code>-তে রূপান্তর করতে হবে। সাধারণত, এটি <code>null</code>-এর সবচেয়ে সাধারণ সমস্যাগুলির মধ্যে একটি ধরতে সাহায্য করে: কোনো কিছুকে <code>not-null</code> ধরে নেওয়া যখন এটি আসলে <code>null</code>।</p>
<p>একটি <code>not-null</code> মান ভুলভাবে ধরে নেওয়ার ঝুঁকি দূর করা আপনাকে আপনার কোডের প্রতি আরও আত্মবিশ্বাসী হতে সাহায্য করে। এমন একটি মান পেতে যা সম্ভবত <code>null</code> হতে পারে, আপনাকে স্পষ্টভাবে সেই মানের type-কে <code>Option&lt;T&gt;</code> করে অপ্ট-ইন করতে হবে। তারপরে, যখন আপনি সেই মানটি ব্যবহার করেন, তখন মানটি <code>null</code> হলে সেই কেসটি স্পষ্টভাবে হ্যান্ডেল করতে হবে। যেখানেই একটি মানের type <code>Option&lt;T&gt;</code> নয়, আপনি নিরাপদে ধরে নিতে পারেন যে মানটি <code>null</code> নয়। এটি Rust-এর একটি ইচ্ছাকৃত ডিজাইন সিদ্ধান্ত ছিল <code>null</code>-এর ব্যাপকতা সীমিত করতে এবং Rust কোডের নিরাপত্তা বৃদ্ধি করতে।</p>
<p>তাহলে আপনি কিভাবে <code>Some</code> variant থেকে <code>T</code> মানটি বের করবেন যখন আপনার কাছে <code>Option&lt;T&gt;</code> type-এর একটি মান থাকে, যাতে আপনি সেই মানটি ব্যবহার করতে পারেন? <code>Option&lt;T&gt;</code> enum-এর অনেক মেথড রয়েছে যা বিভিন্ন পরিস্থিতিতে দরকারী; আপনি <a href="../std/option/enum.Option.html">এর ডকুমেন্টেশনে</a><!-- ignore --> সেগুলি দেখতে পারেন। <code>Option&lt;T&gt;</code>-এর মেথডগুলোর সাথে পরিচিত হওয়া Rust-এর সাথে আপনার যাত্রায় অত্যন্ত দরকারী হবে।</p>
<p>সাধারণভাবে, একটি <code>Option&lt;T&gt;</code> মান ব্যবহার করার জন্য, আপনার এমন কোড থাকা দরকার যা প্রতিটি variant হ্যান্ডেল করবে। আপনি চান কিছু কোড শুধুমাত্র তখনই চলুক যখন আপনার কাছে একটি <code>Some(T)</code> মান থাকে, এবং এই কোডটি ভিতরের <code>T</code> ব্যবহার করার অনুমতি পায়। আপনি চান অন্য কিছু কোড শুধুমাত্র তখনই চলুক যদি আপনার কাছে একটি <code>None</code> মান থাকে, এবং সেই কোডের কাছে একটি <code>T</code> মান উপলব্ধ থাকে না। <code>match</code> এক্সপ্রেশন একটি কন্ট্রোল ফ্লো কনস্ট্রাক্ট যা enum-এর সাথে ব্যবহার করা হলে ঠিক এই কাজটিই করে: এটি enum-এর কোন variant-টি পেয়েছে তার উপর নির্ভর করে ভিন্ন কোড চালাবে, এবং সেই কোডটি ম্যাচিং মানের ভিতরের ডেটা ব্যবহার করতে পারে।</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-00-enums.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch06-02-match.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-00-enums.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch06-02-match.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
