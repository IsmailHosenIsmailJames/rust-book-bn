<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>একটি অবজেক্ট-ওরিয়েন্টেড ডিজাইন প্যাটার্ন ইমপ্লিমেন্ট করা - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="একটি-অবজেকট-ওরিয়েনটেড-ডিজাইন-পযাটারন-ইমপলিমেনট-করা-implementing-an-object-oriented-design-pattern"><a class="header" href="#একটি-অবজেকট-ওরিয়েনটেড-ডিজাইন-পযাটারন-ইমপলিমেনট-করা-implementing-an-object-oriented-design-pattern">একটি অবজেক্ট-ওরিয়েন্টেড ডিজাইন প্যাটার্ন ইমপ্লিমেন্ট করা (Implementing an Object-Oriented Design Pattern)</a></h2>
<p>স্টেট প্যাটার্ন (state pattern) একটি অবজেক্ট-ওরিয়েন্টেড ডিজাইন প্যাটার্ন। এই প্যাটার্নের মূল ভিত্তি হলো, আমরা একটি ভ্যালুর সম্ভাব্য অভ্যন্তরীণ অবস্থা বা state-গুলোর একটি সেট নির্ধারণ করি। এই state-গুলোকে এক সেট <em>স্টেট অবজেক্ট</em> (state objects) দ্বারা প্রকাশ করা হয় এবং ভ্যালুটির state অনুযায়ী তার আচরণ পরিবর্তিত হয়। আমরা একটি ব্লগ পোস্টের struct-এর উদাহরণ নিয়ে কাজ করব, যার একটি ফিল্ড তার state ধরে রাখবে, এবং এই state অবজেক্টটি হবে "ড্রাফট" (draft), "রিভিউ" (review) বা "পাবলিশড" (published) এই তিনটির মধ্যে একটি।</p>
<p>স্টেট অবজেক্টগুলো কিছু কার্যকারিতা (functionality) শেয়ার করে: Rust-এ আমরা অবশ্যই অবজেক্ট এবং ইনহেরিটেন্সের পরিবর্তে struct এবং trait ব্যবহার করি। প্রতিটি স্টেট অবজেক্ট তার নিজের আচরণের জন্য এবং কখন অন্য state-এ পরিবর্তিত হবে তা নিয়ন্ত্রণের জন্য দায়ী। যে ভ্যালুটি স্টেট অবজেক্ট ধারণ করে, সে state-গুলোর বিভিন্ন আচরণ বা কখন তাদের মধ্যে পরিবর্তন হবে সে সম্পর্কে কিছুই জানে না।</p>
<p>স্টেট প্যাটার্ন ব্যবহারের সুবিধা হলো, যখন প্রোগ্রামের ব্যবসায়িক প্রয়োজনীয়তা (business requirements) পরিবর্তিত হয়, তখন আমাদের state ধারণকারী ভ্যালুর কোড বা সেই ভ্যালু ব্যবহারকারী কোড পরিবর্তন করতে হবে না। আমাদের শুধুমাত্র কোনো একটি স্টেট অবজেক্টের ভেতরের কোড আপডেট করে তার নিয়ম পরিবর্তন করতে হবে অথবা প্রয়োজনে আরও স্টেট অবজেক্ট যোগ করতে হবে।</p>
<p>প্রথমে আমরা স্টেট প্যাটার্নটি একটি প্রচলিত অবজেক্ট-ওরিয়েন্টেড পদ্ধতিতে ইমপ্লিমেন্ট করব, তারপর আমরা এমন একটি পদ্ধতি ব্যবহার করব যা Rust-এ কিছুটা বেশি স্বাভাবিক। চলুন, স্টেট প্যাটার্ন ব্যবহার করে একটি ব্লগ পোস্টের ওয়ার্কফ্লো ধাপে ধাপে ইমপ্লিমেন্ট করা যাক।</p>
<p>চূড়ান্ত কার্যকারিতাটি দেখতে এইরকম হবে:</p>
<ol>
<li>একটি ব্লগ পোস্ট একটি খালি ড্রাফট হিসাবে শুরু হয়।</li>
<li>ড্রাফট লেখা শেষ হলে, পোস্টটির একটি রিভিউয়ের জন্য অনুরোধ করা হয়।</li>
<li>পোস্টটি অনুমোদিত (approved) হলে, এটি পাবলিশড হয়ে যায়।</li>
<li>শুধুমাত্র পাবলিশড ব্লগ পোস্টগুলোই প্রিন্ট করার জন্য কন্টেন্ট ফেরত দেয়, যাতে অননুমোদিত পোস্টগুলো ভুলবশত পাবলিশড না হয়ে যায়।</li>
</ol>
<p>একটি পোস্টে অন্য কোনো পরিবর্তন করার চেষ্টা করলে তার কোনো প্রভাব থাকবে না। উদাহরণস্বরূপ, যদি আমরা রিভিউয়ের অনুরোধ করার আগেই একটি ড্রাফট ব্লগ পোস্ট অনুমোদন করার চেষ্টা করি, পোস্টটি একটি অপ্রকাশিত ড্রাফট হিসেবেই থাকবে।</p>
<h3 id="একটি-পরচলিত-অবজেকট-ওরিয়েনটেড-পরচেষটা-a-traditional-object-oriented-attempt"><a class="header" href="#একটি-পরচলিত-অবজেকট-ওরিয়েনটেড-পরচেষটা-a-traditional-object-oriented-attempt">একটি প্রচলিত অবজেক্ট-ওরিয়েন্টেড প্রচেষ্টা (A Traditional Object-oriented Attempt)</a></h3>
<p>একই সমস্যা সমাধানের জন্য কোড গঠন করার অসীম উপায় রয়েছে, প্রতিটিরই ভিন্ন ভিন্ন সুবিধা-অসুবিধা (trade-offs) আছে। এই সেকশনের ইমপ্লিমেন্টেশনটি অনেকটা প্রচলিত অবজেক্ট-ওরিয়েন্টেড ধরনের, যা Rust-এ লেখা সম্ভব, কিন্তু এটি Rust-এর কিছু শক্তিশালী দিকের সুবিধা নেয় না। পরে, আমরা একটি ভিন্ন সমাধান দেখাব যা এখনও অবজেক্ট-ওরিয়েন্টেড ডিজাইন প্যাটার্ন ব্যবহার করে কিন্তু এমনভাবে গঠন করা হয়েছে যা অবজেক্ট-ওরিয়েন্টেড অভিজ্ঞতাসম্পন্ন প্রোগ্রামারদের কাছে কিছুটা অপরিচিত মনে হতে পারে। আমরা দুটি সমাধানের তুলনা করে দেখব যে অন্য ল্যাঙ্গুয়েজের কোডের চেয়ে ভিন্নভাবে Rust কোড ডিজাইন করার সুবিধা-অসুবিধাগুলো কী।</p>
<p>লিস্টিং ১৮-১১ এই ওয়ার্কফ্লোটিকে কোড আকারে দেখায়: এটি <code>blog</code> নামে একটি লাইব্রেরি ক্রেটে আমরা যে API ইমপ্লিমেন্ট করব তার একটি উদাহরণ। এটি এখনও কম্পাইল হবে না কারণ আমরা <code>blog</code> ক্রেটটি ইমপ্লিমেন্ট করিনি।</p>
<Listing number="18-11" file-name="src/main.rs" caption="এমন কোড যা আমাদের `blog` ক্রেটের কাঙ্ক্ষিত আচরণ প্রদর্শন করে">
<pre><code class="language-rust ignore does_not_compile">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    post.request_review();
    assert_eq!("", post.content());

    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
</Listing>
<p>আমরা ব্যবহারকারীকে <code>Post::new</code> দিয়ে একটি নতুন ড্রাফট ব্লগ পোস্ট তৈরি করার সুযোগ দিতে চাই। আমরা ব্লগ পোস্টে টেক্সট যোগ করার অনুমতি দিতে চাই। যদি আমরা অনুমোদনের আগে অবিলম্বে পোস্টের কন্টেন্ট পাওয়ার চেষ্টা করি, আমাদের কোনো টেক্সট পাওয়া উচিত নয় কারণ পোস্টটি এখনও একটি ড্রাফট। আমরা প্রদর্শনের উদ্দেশ্যে কোডে <code>assert_eq!</code> যোগ করেছি। এর জন্য একটি চমৎকার ইউনিট টেস্ট হতে পারত यह নিশ্চিত করা যে একটি ড্রাফট ব্লগ পোস্ট <code>content</code> মেথড থেকে একটি খালি স্ট্রিং ফেরত দেয়, কিন্তু আমরা এই উদাহরণের জন্য টেস্ট লিখছি না।</p>
<p>এরপর, আমরা পোস্টের রিভিউয়ের জন্য একটি অনুরোধ সক্ষম করতে চাই, এবং রিভিউয়ের জন্য অপেক্ষারত অবস্থায় আমরা চাই <code>content</code> একটি খালি স্ট্রিং ফেরত দিক। যখন পোস্টটি অনুমোদন পাবে, তখন এটি পাবলিশড হওয়া উচিত, যার মানে <code>content</code> কল করা হলে পোস্টের টেক্সট ফেরত দেওয়া হবে।</p>
<p>লক্ষ্য করুন যে আমরা ক্রেট থেকে শুধুমাত্র <code>Post</code> টাইপের সাথেই ইন্টারঅ্যাক্ট করছি। এই টাইপটি স্টেট প্যাটার্ন ব্যবহার করবে এবং একটি মান ধারণ করবে যা তিনটি স্টেট অবজেক্টের মধ্যে একটি হবে, যা একটি পোস্টের বিভিন্ন অবস্থা—ড্রাফট, রিভিউ, বা পাবলিশড—উপস্থাপন করবে। এক state থেকে অন্য state-এ পরিবর্তন <code>Post</code> টাইপের অভ্যন্তরে পরিচালিত হবে। আমাদের লাইব্রেরির ব্যবহারকারীরা <code>Post</code> ইনস্ট্যান্সের উপর যে মেথডগুলো কল করে তার প্রতিক্রিয়ায় state-গুলো পরিবর্তিত হয়, কিন্তু তাদের সরাসরি state পরিবর্তন পরিচালনা করতে হয় না। এছাড়াও, ব্যবহারকারীরা state-গুলো নিয়ে ভুল করতে পারে না, যেমন রিভিউয়ের আগে একটি পোস্ট পাবলিশ করা।</p>
<h4 id="post-সংজঞাযিত-করা-এবং-ডরাফট-অবসথায-একটি-নতুন-ইনসটযানস-তৈরি-করা"><a class="header" href="#post-সংজঞাযিত-করা-এবং-ডরাফট-অবসথায-একটি-নতুন-ইনসটযানস-তৈরি-করা"><code>Post</code> সংজ্ঞায়িত করা এবং ড্রাফট অবস্থায় একটি নতুন ইনস্ট্যান্স তৈরি করা</a></h4>
<p>চলুন লাইব্রেরির ইমপ্লিমেন্টেশন শুরু করা যাক! আমরা জানি আমাদের একটি পাবলিক <code>Post</code> struct প্রয়োজন যা কিছু কন্টেন্ট ধারণ করবে, তাই আমরা struct-টির সংজ্ঞা এবং একটি <code>Post</code>-এর ইনস্ট্যান্স তৈরি করার জন্য একটি সংশ্লিষ্ট পাবলিক <code>new</code> ফাংশন দিয়ে শুরু করব, যেমনটি লিস্টিং ১৮-১২-তে দেখানো হয়েছে। আমরা একটি প্রাইভেট <code>State</code> trait-ও তৈরি করব যা একটি <code>Post</code>-এর জন্য সমস্ত স্টেট অবজেক্টের যে আচরণ থাকতে হবে তা সংজ্ঞায়িত করবে।</p>
<p>তারপর <code>Post</code> একটি <code>state</code> নামের প্রাইভেট ফিল্ডে <code>Option&lt;T&gt;</code>-এর ভিতরে <code>Box&lt;dyn State&gt;</code>-এর একটি ট্রেইট অবজেক্ট ধারণ করবে স্টেট অবজেক্ট রাখার জন্য। আপনি একটু পরেই দেখতে পাবেন কেন <code>Option&lt;T&gt;</code> প্রয়োজন।</p>
<Listing number="18-12" file-name="src/lib.rs" caption="একটি `Post` struct-এর সংজ্ঞা এবং একটি `new` ফাংশন যা একটি নতুন `Post` ইনস্ট্যান্স তৈরি করে, একটি `State` trait, এবং একটি `Draft` struct">
<pre><code class="language-rust noplayground">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}</code></pre>
</Listing>
<p><code>State</code> trait বিভিন্ন পোস্ট state দ্বারা শেয়ার করা আচরণকে সংজ্ঞায়িত করে। স্টেট অবজেক্টগুলো হলো <code>Draft</code>, <code>PendingReview</code>, এবং <code>Published</code>, এবং তারা সবাই <code>State</code> trait ইমপ্লিমেন্ট করবে। আপাতত, trait-টির কোনো মেথড নেই, এবং আমরা কেবল <code>Draft</code> state সংজ্ঞায়িত করে শুরু করব কারণ আমরা চাই একটি পোস্ট এই state-এ শুরু হোক।</p>
<p>যখন আমরা একটি নতুন <code>Post</code> তৈরি করি, আমরা এর <code>state</code> ফিল্ডটিকে একটি <code>Some</code> মান দিয়ে সেট করি যা একটি <code>Box</code> ধারণ করে। এই <code>Box</code> একটি <code>Draft</code> struct-এর নতুন ইনস্ট্যান্সের দিকে নির্দেশ করে। এটি নিশ্চিত করে যে যখনই আমরা <code>Post</code>-এর একটি নতুন ইনস্ট্যান্স তৈরি করব, এটি একটি ড্রাফট হিসাবে শুরু হবে। যেহেতু <code>Post</code>-এর <code>state</code> ফিল্ডটি প্রাইভেট, তাই অন্য কোনো state-এ একটি <code>Post</code> তৈরি করার কোনো উপায় নেই! <code>Post::new</code> ফাংশনে, আমরা <code>content</code> ফিল্ডটিকে একটি নতুন, খালি <code>String</code>-এ সেট করি।</p>
<h4 id="পোসট-কনটেনটের-টেকসট-সংরকষণ-করা"><a class="header" href="#পোসট-কনটেনটের-টেকসট-সংরকষণ-করা">পোস্ট কন্টেন্টের টেক্সট সংরক্ষণ করা</a></h4>
<p>আমরা লিস্টিং ১৮-১১-তে দেখেছি যে আমরা <code>add_text</code> নামের একটি মেথড কল করতে এবং এটিকে একটি <code>&amp;str</code> পাস করতে সক্ষম হতে চাই যা ব্লগ পোস্টের টেক্সট কন্টেন্ট হিসাবে যোগ করা হবে। আমরা এটি একটি মেথড হিসাবে ইমপ্লিমেন্ট করি, <code>content</code> ফিল্ডটিকে <code>pub</code> হিসাবে প্রকাশ করার পরিবর্তে, যাতে পরে আমরা এমন একটি মেথড ইমপ্লিমেন্ট করতে পারি যা <code>content</code> ফিল্ডের ডেটা কীভাবে পড়া হবে তা নিয়ন্ত্রণ করবে। <code>add_text</code> মেথডটি বেশ সহজবোধ্য, তাই চলুন লিস্টিং ১৮-১৩-এর ইমপ্লিমেন্টেশনটি <code>impl Post</code> ব্লকে যোগ করি।</p>
<Listing number="18-13" file-name="src/lib.rs" caption="একটি পোস্টের `content`-এ টেক্সট যোগ করার জন্য `add_text` মেথড ইমপ্লিমেন্ট করা">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p><code>add_text</code> মেথডটি <code>self</code>-এর একটি মিউটেবল রেফারেন্স নেয় কারণ আমরা যে <code>Post</code> ইনস্ট্যান্সের উপর <code>add_text</code> কল করছি তা পরিবর্তন করছি। তারপর আমরা <code>content</code>-এর <code>String</code>-এর উপর <code>push_str</code> কল করি এবং সংরক্ষিত <code>content</code>-এ যোগ করার জন্য <code>text</code> আর্গুমেন্টটি পাস করি। এই আচরণটি পোস্টটি কোন state-এ আছে তার উপর নির্ভর করে না, তাই এটি স্টেট প্যাটার্নের অংশ নয়। <code>add_text</code> মেথডটি <code>state</code> ফিল্ডের সাথে একেবারেই ইন্টারঅ্যাক্ট করে না, তবে এটি আমরা যে আচরণ সমর্থন করতে চাই তার অংশ।</p>
<h4 id="একটি-ডরাফট-পোসটের-কনটেনট-খালি-নিশচিত-করা"><a class="header" href="#একটি-ডরাফট-পোসটের-কনটেনট-খালি-নিশচিত-করা">একটি ড্রাফট পোস্টের কন্টেন্ট খালি নিশ্চিত করা</a></h4>
<p>এমনকি আমরা <code>add_text</code> কল করে আমাদের পোস্টে কিছু কন্টেন্ট যোগ করার পরেও, আমরা চাই <code>content</code> মেথডটি একটি খালি স্ট্রিং স্লাইস ফেরত দিক কারণ পোস্টটি এখনও ড্রাফট state-এ আছে, যেমনটি লিস্টিং ১৮-১১-এর ৭ নম্বর লাইনে দেখানো হয়েছে। আপাতত, চলুন <code>content</code> মেথডটি সবচেয়ে সহজ জিনিস দিয়ে ইমপ্লিমেন্ট করি যা এই প্রয়োজনীয়তা পূরণ করবে: সর্বদা একটি খালি স্ট্রিং স্লাইস ফেরত দেওয়া। আমরা এটি পরে পরিবর্তন করব যখন আমরা একটি পোস্টের state পরিবর্তন করার ক্ষমতা ইমপ্লিমেন্ট করব যাতে এটি পাবলিশড হতে পারে। এখন পর্যন্ত, পোস্টগুলো কেবল ড্রাফট state-এ থাকতে পারে, তাই পোস্ট কন্টেন্ট সর্বদা খালি থাকা উচিত। লিস্টিং ১৮-১৪ এই স্থানধারক (placeholder) ইমপ্লিমেন্টেশনটি দেখায়।</p>
<Listing number="18-14" file-name="src/lib.rs" caption="`Post`-এ `content` মেথডের জন্য একটি স্থানধারক ইমপ্লিমেন্টেশন যোগ করা যা সর্বদা একটি খালি স্ট্রিং স্লাইস ফেরত দেয়">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        ""
    }
}
<span class="boring">
</span><span class="boring">trait State {}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {}</span></code></pre>
</Listing>
<p>এই <code>content</code> মেথডটি যোগ করার সাথে, লিস্টিং ১৮-১১-এর ৭ নম্বর লাইন পর্যন্ত সবকিছু উদ্দেশ্য অনুযায়ী কাজ করে।</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="requesting-a-review-of-the-post-changes-its-state"></a></p>
<h4 id="একটি-রিভিউয়ের-অনুরোধ-পোসটের-সটেট-পরিবরতন-করে"><a class="header" href="#একটি-রিভিউয়ের-অনুরোধ-পোসটের-সটেট-পরিবরতন-করে">একটি রিভিউয়ের অনুরোধ পোস্টের স্টেট পরিবর্তন করে</a></h4>
<p>এরপরে, আমাদের একটি পোস্টের রিভিউয়ের অনুরোধ করার জন্য কার্যকারিতা যোগ করতে হবে, যা এর state <code>Draft</code> থেকে <code>PendingReview</code>-এ পরিবর্তন করবে। লিস্টিং ১৮-১৫ এই কোডটি দেখায়।</p>
<Listing number="18-15" file-name="src/lib.rs" caption="`Post` এবং `State` trait-এ `request_review` মেথড ইমপ্লিমেন্ট করা">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>আমরা <code>Post</code>-কে <code>request_review</code> নামে একটি পাবলিক মেথড দিই যা <code>self</code>-এর একটি মিউটেবল রেফারেন্স নেবে। তারপর আমরা <code>Post</code>-এর বর্তমান state-এর উপর একটি অভ্যন্তরীণ <code>request_review</code> মেথড কল করি, এবং এই দ্বিতীয় <code>request_review</code> মেথডটি বর্তমান state-কে কনজিউম (consume) করে এবং একটি নতুন state ফেরত দেয়।</p>
<p>আমরা <code>State</code> trait-এ <code>request_review</code> মেথডটি যোগ করি; যে সমস্ত টাইপ trait-টি ইমপ্লিমেন্ট করে তাদের এখন <code>request_review</code> মেথড ইমপ্লিমেন্ট করতে হবে। লক্ষ্য করুন যে মেথডের প্রথম প্যারামিটার হিসাবে <code>self</code>, <code>&amp;self</code>, বা <code>&amp;mut self</code> থাকার পরিবর্তে, আমাদের আছে <code>self: Box&lt;Self&gt;</code>। এই সিনট্যাক্সটির মানে হলো মেথডটি কেবল তখনই বৈধ যখন এটি টাইপ ধারণকারী একটি <code>Box</code>-এর উপর কল করা হয়। এই সিনট্যাক্সটি <code>Box&lt;Self&gt;</code>-এর মালিকানা নেয়, পুরানো state-কে অবৈধ করে দেয় যাতে <code>Post</code>-এর state ভ্যালুটি একটি নতুন state-এ রূপান্তরিত হতে পারে।</p>
<p>পুরানো state কনজিউম করার জন্য, <code>request_review</code> মেথডটিকে state ভ্যালুর মালিকানা নিতে হবে। এখানেই <code>Post</code>-এর <code>state</code> ফিল্ডে <code>Option</code>-এর ভূমিকা আসে: আমরা <code>state</code> ফিল্ড থেকে <code>Some</code> ভ্যালুটি বের করে নিতে এবং তার জায়গায় একটি <code>None</code> রেখে দিতে <code>take</code> মেথড কল করি, কারণ Rust আমাদের struct-এ খালি ফিল্ড রাখতে দেয় না। এটি আমাদের <code>Post</code> থেকে <code>state</code> ভ্যালুটি borrow করার পরিবর্তে move করার সুযোগ দেয়। তারপর আমরা পোস্টের <code>state</code> ভ্যালুটি এই অপারেশনের ফলাফলে সেট করব।</p>
<p>আমাদের <code>state</code> ভ্যালুর মালিকানা পেতে <code>self.state = self.state.request_review();</code>-এর মতো কোড দিয়ে সরাসরি সেট করার পরিবর্তে <code>state</code>-কে সাময়িকভাবে <code>None</code> হিসাবে সেট করতে হবে। এটি নিশ্চিত করে যে আমরা পুরানো <code>state</code> ভ্যালুটি একটি নতুন state-এ রূপান্তরিত করার পরে <code>Post</code> আর সেটি ব্যবহার করতে পারবে না।</p>
<p><code>Draft</code>-এর উপর <code>request_review</code> মেথডটি একটি নতুন <code>PendingReview</code> struct-এর একটি নতুন, বক্সড ইনস্ট্যান্স ফেরত দেয়, যা সেই state-কে প্রতিনিধিত্ব করে যখন একটি পোস্ট রিভিউয়ের জন্য অপেক্ষা করছে। <code>PendingReview</code> struct-টিও <code>request_review</code> মেথড ইমপ্লিমেন্ট করে কিন্তু কোনো রূপান্তর করে না। বরং, এটি নিজেকেই ফেরত দেয় কারণ যখন আমরা এমন একটি পোস্টে রিভিউয়ের অনুরোধ করি যা ইতিমধ্যে <code>PendingReview</code> state-এ আছে, তখন এটি <code>PendingReview</code> state-এ থাকা উচিত।</p>
<p>এখন আমরা স্টেট প্যাটার্নের সুবিধা দেখতে শুরু করতে পারি: <code>Post</code>-এর উপর <code>request_review</code> মেথডটি তার <code>state</code> ভ্যালু যাই হোক না কেন একই থাকে। প্রতিটি state তার নিজের নিয়মের জন্য দায়ী।</p>
<p>আমরা <code>Post</code>-এর <code>content</code> মেথডটি যেমন আছে তেমনই রাখব, একটি খালি স্ট্রিং স্লাইস ফেরত দিয়ে। আমরা এখন একটি <code>Post</code>-কে <code>Draft</code> state-এর পাশাপাশি <code>PendingReview</code> state-এও রাখতে পারি, কিন্তু আমরা <code>PendingReview</code> state-এও একই আচরণ চাই। লিস্টিং ১৮-১১ এখন ১০ নম্বর লাইন পর্যন্ত কাজ করে!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="adding-the-approve-method-that-changes-the-behavior-of-content"></a></p>
<h4 id="content-এর-আচরণ-পরিবরতনকারী-approve-মেথড-যোগ-করা"><a class="header" href="#content-এর-আচরণ-পরিবরতনকারী-approve-মেথড-যোগ-করা"><code>content</code>-এর আচরণ পরিবর্তনকারী <code>approve</code> মেথড যোগ করা</a></h4>
<p><code>approve</code> মেথডটি <code>request_review</code> মেথডের মতোই হবে: এটি <code>state</code>-কে সেই মানে সেট করবে যা বর্তমান state বলে যে অনুমোদিত হলে তার থাকা উচিত, যেমনটি লিস্টিং ১৮-১৬-তে দেখানো হয়েছে।</p>
<Listing number="18-16" file-name="src/lib.rs" caption="`Post` এবং `State` trait-এ `approve` মেথড ইমপ্লিমেন্ট করা">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        ""
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</Listing>
<p>আমরা <code>State</code> trait-এ <code>approve</code> মেথড যোগ করি এবং <code>State</code> ইমপ্লিমেন্টকারী একটি নতুন struct, <code>Published</code> state, যোগ করি।</p>
<p><code>PendingReview</code>-এর উপর <code>request_review</code> যেভাবে কাজ করে তার মতোই, যদি আমরা একটি <code>Draft</code>-এর উপর <code>approve</code> মেথড কল করি, তবে এর কোনো প্রভাব থাকবে না কারণ <code>approve</code> <code>self</code> ফেরত দেবে। যখন আমরা <code>PendingReview</code>-এর উপর <code>approve</code> কল করি, তখন এটি <code>Published</code> struct-এর একটি নতুন, বক্সড ইনস্ট্যান্স ফেরত দেয়। <code>Published</code> struct-টি <code>State</code> trait ইমপ্লিমেন্ট করে, এবং <code>request_review</code> ও <code>approve</code> উভয় মেথডের জন্য, এটি নিজেকেই ফেরত দেয় কারণ পোস্টটি সেইসব ক্ষেত্রে <code>Published</code> state-এ থাকা উচিত।</p>
<p>এখন আমাদের <code>Post</code>-এর <code>content</code> মেথডটি আপডেট করতে হবে। আমরা চাই <code>content</code> থেকে ফেরত আসা মানটি <code>Post</code>-এর বর্তমান state-এর উপর নির্ভর করুক, তাই আমরা <code>Post</code>-কে তার <code>state</code>-এর উপর সংজ্ঞায়িত একটি <code>content</code> মেথডে কাজটা सौंप (delegate) দেব, যেমনটি লিস্টিং ১৮-১৭-তে দেখানো হয়েছে।</p>
<Listing number="18-17" file-name="src/lib.rs" caption="`Post`-এর `content` মেথডকে `State`-এর একটি `content` মেথডে কাজ सौंपার জন্য আপডেট করা">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
<span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
    // --snip--
<span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">trait State {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Published {}
</span><span class="boring">
</span><span class="boring">impl State for Published {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>যেহেতু লক্ষ্য হলো এই সমস্ত নিয়ম <code>State</code> ইমপ্লিমেন্টকারী struct-গুলোর ভিতরে রাখা, তাই আমরা <code>state</code>-এর মানের উপর একটি <code>content</code> মেথড কল করি এবং পোস্ট ইনস্ট্যান্সটি (অর্থাৎ <code>self</code>) একটি আর্গুমেন্ট হিসাবে পাস করি। তারপর আমরা <code>state</code> মানের উপর <code>content</code> মেথড ব্যবহার করে যে মান ফেরত আসে তা ফেরত দিই।</p>
<p>আমরা <code>Option</code>-এর উপর <code>as_ref</code> মেথড কল করি কারণ আমরা মানের মালিকানার পরিবর্তে <code>Option</code>-এর ভিতরের মানের একটি রেফারেন্স চাই। যেহেতু <code>state</code> একটি <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, যখন আমরা <code>as_ref</code> কল করি, তখন একটি <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> ফেরত আসে। যদি আমরা <code>as_ref</code> কল না করতাম, আমরা একটি ত্রুটি পেতাম কারণ আমরা ফাংশন প্যারামিটারের ধার করা <code>&amp;self</code> থেকে <code>state</code> মুভ করতে পারি না।</p>
<p>তারপর আমরা <code>unwrap</code> মেথড কল করি, যা আমরা জানি কখনও প্যানিক করবে না কারণ আমরা জানি <code>Post</code>-এর মেথডগুলো নিশ্চিত করে যে সেই মেথডগুলো শেষ হলে <code>state</code>-এ সর্বদা একটি <code>Some</code> মান থাকবে। এটি সেই случайগুলোর মধ্যে একটি যা আমরা ৯ অধ্যায়ে "<a href="ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">যেসব ক্ষেত্রে আপনার কাছে কম্পাইলারের চেয়ে বেশি তথ্য থাকে</a>" অংশে আলোচনা করেছি যখন আমরা জানি যে একটি <code>None</code> মান কখনও সম্ভব নয়, যদিও কম্পাইলার এটি বুঝতে সক্ষম নয়।</p>
<p>এই মুহুর্তে, যখন আমরা <code>&amp;Box&lt;dyn State&gt;</code>-এর উপর <code>content</code> কল করি, তখন <code>&amp;</code> এবং <code>Box</code>-এর উপর ডিরেফ কোয়ার্সন (deref coercion) কার্যকর হবে যাতে <code>content</code> মেথডটি শেষ পর্যন্ত <code>State</code> trait ইমপ্লিমেন্টকারী টাইপের উপর কল করা হয়। এর মানে হলো আমাদের <code>State</code> trait সংজ্ঞায় <code>content</code> যোগ করতে হবে, এবং সেখানেই আমরা কোন state আছে তার উপর নির্ভর করে কোন কন্টেন্ট ফেরত দিতে হবে তার লজিক রাখব, যেমনটি লিস্টিং ১৮-১৮-তে দেখানো হয়েছে।</p>
<Listing number="18-18" file-name="src/lib.rs" caption="`State` trait-এ `content` মেথড যোগ করা">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; Post {
</span><span class="boring">        Post {
</span><span class="boring">            state: Some(Box::new(Draft {})),
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        self.state.as_ref().unwrap().content(self)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn request_review(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.request_review())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn approve(&amp;mut self) {
</span><span class="boring">        if let Some(s) = self.state.take() {
</span><span class="boring">            self.state = Some(s.approve())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>trait State {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

// --snip--
<span class="boring">
</span><span class="boring">struct Draft {}
</span><span class="boring">
</span><span class="boring">impl State for Draft {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PendingReview {}
</span><span class="boring">
</span><span class="boring">impl State for PendingReview {
</span><span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(Published {})
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct Published {}

impl State for Published {
    // --snip--
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}</code></pre>
</Listing>
<p>আমরা <code>content</code> মেথডের জন্য একটি ডিফল্ট ইমপ্লিমেন্টেশন যোগ করি যা একটি খালি স্ট্রিং স্লাইস ফেরত দেয়। এর মানে আমাদের <code>Draft</code> এবং <code>PendingReview</code> struct-এ <code>content</code> ইমপ্লিমেন্ট করার প্রয়োজন নেই। <code>Published</code> struct <code>content</code> মেথডকে ওভাররাইড করবে এবং <code>post.content</code>-এর মান ফেরত দেবে। যদিও সুবিধাজনক, <code>State</code>-এর <code>content</code> মেথড <code>Post</code>-এর <code>content</code> নির্ধারণ করা <code>State</code> এবং <code>Post</code>-এর দায়িত্বের মধ্যেকার সীমানাকে অস্পষ্ট করে তুলছে।</p>
<p>লক্ষ্য করুন যে আমাদের এই মেথডে লাইফটাইম অ্যানোটেশন প্রয়োজন, যেমনটি আমরা ১০ অধ্যায়ে আলোচনা করেছি। আমরা একটি <code>post</code>-এর রেফারেন্স একটি আর্গুমেন্ট হিসাবে নিচ্ছি এবং সেই <code>post</code>-এর একটি অংশের রেফারেন্স ফেরত দিচ্ছি, তাই ফেরত দেওয়া রেফারেন্সের লাইফটাইম <code>post</code> আর্গুমেন্টের লাইফটাইমের সাথে সম্পর্কিত।</p>
<p>এবং আমরা শেষ করেছি—লিস্টিং ১৮-১১ এখন পুরোটাই কাজ করে! আমরা ব্লগ পোস্ট ওয়ার্কফ্লোর নিয়মাবলী দিয়ে স্টেট প্যাটার্ন ইমপ্লিমেন্ট করেছি। নিয়ম সম্পর্কিত লজিক <code>Post</code>-এ ছড়িয়ে ছিটিয়ে থাকার পরিবর্তে স্টেট অবজেক্টগুলোর মধ্যে থাকে।</p>
<blockquote>
<h3 id="কেন-একটি-enum-নয-why-not-an-enum"><a class="header" href="#কেন-একটি-enum-নয-why-not-an-enum">কেন একটি Enum নয়? (Why Not An Enum?)</a></h3>
<p>আপনি হয়তো ভাবছেন কেন আমরা বিভিন্ন সম্ভাব্য পোস্ট state-কে ভ্যারিয়েন্ট হিসাবে নিয়ে একটি <code>enum</code> ব্যবহার করিনি। এটি অবশ্যই একটি সম্ভাব্য সমাধান; চেষ্টা করে দেখুন এবং চূড়ান্ত ফলাফল তুলনা করে দেখুন কোনটি আপনার পছন্দ! একটি enum ব্যবহারের একটি অসুবিধা হলো, enum-এর মান পরীক্ষা করে এমন প্রতিটি জায়গায় প্রতিটি সম্ভাব্য ভ্যারিয়েন্ট পরিচালনা করার জন্য একটি <code>match</code> এক্সপ্রেশন বা অনুরূপ কিছুর প্রয়োজন হবে। এটি এই ট্রেইট অবজেক্ট সমাধানের চেয়ে বেশি পুনরাবৃত্তিমূলক (repetitive) হতে পারে।</p>
</blockquote>
<h4 id="সটেট-পযাটারনের-সুবিধা-অসুবিধা-trade-offs-of-the-state-pattern"><a class="header" href="#সটেট-পযাটারনের-সুবিধা-অসুবিধা-trade-offs-of-the-state-pattern">স্টেট প্যাটার্নের সুবিধা-অসুবিধা (Trade-offs of the State Pattern)</a></h4>
<p>আমরা দেখিয়েছি যে Rust অবজেক্ট-ওরিয়েন্টেড স্টেট প্যাটার্ন ইমপ্লিমেন্ট করতে সক্ষম, যাতে প্রতিটি state-এ একটি পোস্টের বিভিন্ন ধরণের আচরণকে এনক্যাপসুলেট করা যায়। <code>Post</code>-এর মেথডগুলো বিভিন্ন আচরণ সম্পর্কে কিছুই জানে না। আমরা যেভাবে কোডটি সাজিয়েছি, তাতে একটি পাবলিশড পোস্টের বিভিন্ন আচরণ জানার জন্য আমাদের কেবল একটি জায়গায় তাকাতে হবে: <code>Published</code> struct-এর উপর <code>State</code> trait-এর ইমপ্লিমেন্টেশন।</p>
<p>যদি আমরা একটি বিকল্প ইমপ্লিমেন্টেশন তৈরি করতাম যা স্টেট প্যাটার্ন ব্যবহার করে না, আমরা হয়তো <code>Post</code>-এর মেথডগুলোতে বা এমনকি <code>main</code> কোডেও <code>match</code> এক্সপ্রেশন ব্যবহার করতাম যা পোস্টের state পরীক্ষা করে এবং সেই জায়গাগুলোতে আচরণ পরিবর্তন করে। এর মানে হতো একটি পোস্ট পাবলিশড অবস্থায় থাকার সমস্ত প্রভাব বোঝার জন্য আমাদের বেশ কয়েকটি জায়গায় তাকাতে হতো।</p>
<p>স্টেট প্যাটার্নের সাথে, <code>Post</code> মেথড এবং যেখানে আমরা <code>Post</code> ব্যবহার করি সেখানে <code>match</code> এক্সপ্রেশনের প্রয়োজন হয় না, এবং একটি নতুন state যোগ করার জন্য, আমাদের কেবল একটি নতুন struct যোগ করতে হবে এবং সেই একটি struct-এর উপর trait মেথডগুলো এক জায়গায় ইমপ্লিমেন্ট করতে হবে।</p>
<p>স্টেট প্যাটার্ন ব্যবহার করে ইমপ্লিমেন্টেশনটি আরও কার্যকারিতা যোগ করার জন্য প্রসারিত করা সহজ। স্টেট প্যাটার্ন ব্যবহার করে কোড রক্ষণাবেক্ষণের সরলতা দেখতে, এই পরামর্শগুলোর কয়েকটি চেষ্টা করুন:</p>
<ul>
<li>একটি <code>reject</code> মেথড যোগ করুন যা পোস্টের state <code>PendingReview</code> থেকে <code>Draft</code>-এ ফিরিয়ে আনে।</li>
<li>state <code>Published</code>-এ পরিবর্তন করার আগে <code>approve</code>-এর দুটি কল প্রয়োজন করুন।</li>
<li>ব্যবহারকারীদের শুধুমাত্র <code>Draft</code> state-এ থাকা অবস্থায় টেক্সট কন্টেন্ট যোগ করার অনুমতি দিন। ইঙ্গিত: স্টেট অবজেক্টকে কন্টেন্ট সম্পর্কে কী পরিবর্তন হতে পারে তার জন্য দায়ী করুন, কিন্তু <code>Post</code> পরিবর্তন করার জন্য দায়ী নয়।</li>
</ul>
<p>স্টেট প্যাটার্নের একটি অসুবিধা হলো, যেহেতু state-গুলো state-গুলোর মধ্যে রূপান্তর ইমপ্লিমেন্ট করে, তাই কিছু state একে অপরের সাথে সংযুক্ত (coupled)। যদি আমরা <code>PendingReview</code> এবং <code>Published</code>-এর মধ্যে <code>Scheduled</code>-এর মতো আরেকটি state যোগ করি, তবে আমাদের <code>PendingReview</code>-এর কোড পরিবর্তন করে <code>Scheduled</code>-এ রূপান্তর করতে হবে। যদি একটি নতুন state যোগ করার সাথে <code>PendingReview</code>-কে পরিবর্তন করার প্রয়োজন না হতো তবে কম কাজ হতো, কিন্তু তার মানে হতো অন্য একটি ডিজাইন প্যাটার্নে স্যুইচ করা।</p>
<p>আরেকটি অসুবিধা হলো আমরা কিছু লজিক ডুপ্লিকেট করেছি। কিছু ডুপ্লিকেশন দূর করার জন্য, আমরা <code>State</code> trait-এ <code>request_review</code> এবং <code>approve</code> মেথডগুলোর জন্য ডিফল্ট ইমপ্লিমেন্টেশন তৈরি করার চেষ্টা করতে পারি যা <code>self</code> ফেরত দেয়। তবে, এটি কাজ করবে না: <code>State</code>-কে একটি ট্রেইট অবজেক্ট হিসাবে ব্যবহার করার সময়, trait জানে না যে সুনির্দিষ্ট <code>self</code> ঠিক কী হবে, তাই রিটার্ন টাইপ কম্পাইল টাইমে জানা যায় না। (এটি পূর্বে উল্লিখিত <code>dyn</code> কম্প্যাটিবিলিটি নিয়মগুলোর মধ্যে একটি।)</p>
<p>অন্যান্য ডুপ্লিকেশনের মধ্যে রয়েছে <code>Post</code>-এর উপর <code>request_review</code> এবং <code>approve</code> মেথডগুলোর অনুরূপ ইমপ্লিমেন্টেশন। উভয় মেথডই <code>Post</code>-এর <code>state</code> ফিল্ডের সাথে <code>Option::take</code> ব্যবহার করে, এবং যদি <code>state</code> <code>Some</code> হয়, তবে তারা র‍্যাপড (wrapped) ভ্যালুর একই মেথডের ইমপ্লিমেন্টেশনে কাজটা सौंप দেয় এবং <code>state</code> ফিল্ডের নতুন মানটি ফলাফলে সেট করে। যদি <code>Post</code>-এ এই প্যাটার্ন অনুসরণকারী অনেক মেথড থাকতো, তবে আমরা পুনরাবৃত্তি দূর করার জন্য একটি ম্যাক্রো সংজ্ঞায়িত করার কথা বিবেচনা করতে পারতাম (২০তম অধ্যায়ে "<a href="ch20-05-macros.html#macros">ম্যাক্রো</a>" দেখুন)।</p>
<p>অবজেক্ট-ওরিয়েন্টেড ল্যাঙ্গুয়েজের জন্য ঠিক যেভাবে স্টেট প্যাটার্ন সংজ্ঞায়িত করা হয়েছে সেভাবে ইমপ্লিমেন্ট করে, আমরা Rust-এর শক্তিশালী দিকগুলোর ততটা পূর্ণ সুবিধা নিচ্ছি না যতটা আমরা নিতে পারতাম। চলুন <code>blog</code> ক্রেটে কিছু পরিবর্তন দেখি যা অবৈধ state এবং রূপান্তরকে কম্পাইল-টাইম ত্রুটিতে পরিণত করতে পারে।</p>
<h3 id="state-এবং-আচরণকে-টাইপ-হিসাবে-এনকোড-করা-encoding-states-and-behavior-as-types"><a class="header" href="#state-এবং-আচরণকে-টাইপ-হিসাবে-এনকোড-করা-encoding-states-and-behavior-as-types">State এবং আচরণকে টাইপ হিসাবে এনকোড করা (Encoding States and Behavior as Types)</a></h3>
<p>আমরা আপনাকে দেখাব কীভাবে স্টেট প্যাটার্নটি নতুনভাবে চিন্তা করে একটি ভিন্ন ধরনের সুবিধা-অসুবিধা (trade-offs) পাওয়া যায়। state এবং রূপান্তরগুলোকে সম্পূর্ণরূপে এনক্যাপসুলেট করার পরিবর্তে যাতে বাইরের কোডের তাদের সম্পর্কে কোনো জ্ঞান না থাকে, আমরা state-গুলোকে বিভিন্ন টাইপে এনকোড করব। ফলস্বরূপ, Rust-এর টাইপ চেকিং সিস্টেম একটি কম্পাইলার ত্রুটি জারি করে এমন জায়গায় ড্রাফট পোস্ট ব্যবহার করার প্রচেষ্টা প্রতিরোধ করবে যেখানে কেবল পাবলিশড পোস্ট অনুমোদিত।</p>
<p>চলুন লিস্টিং ১৮-১১-এর <code>main</code>-এর প্রথম অংশটি বিবেচনা করি:</p>
<Listing file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span><span class="boring">
</span>fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());
<span class="boring">
</span><span class="boring">    post.request_review();
</span><span class="boring">    assert_eq!("", post.content());
</span><span class="boring">
</span><span class="boring">    post.approve();
</span><span class="boring">    assert_eq!("I ate a salad for lunch today", post.content());
</span>}</code></pre>
</Listing>
<p>আমরা এখনও <code>Post::new</code> ব্যবহার করে ড্রাফট state-এ নতুন পোস্ট তৈরি এবং পোস্টের কন্টেন্টে টেক্সট যোগ করার ক্ষমতা সক্ষম করি। কিন্তু একটি ড্রাফট পোস্টের উপর একটি <code>content</code> মেথড থাকার পরিবর্তে যা একটি খালি স্ট্রিং ফেরত দেয়, আমরা এমনভাবে তৈরি করব যাতে ড্রাফট পোস্টের <code>content</code> মেথডটি একেবারেই না থাকে। এভাবে, যদি আমরা একটি ড্রাফট পোস্টের কন্টেন্ট পাওয়ার চেষ্টা করি, আমরা একটি কম্পাইলার ত্রুটি পাব যা আমাদের বলবে যে মেথডটি বিদ্যমান নেই। ফলস্বরূপ, আমাদের জন্য প্রোডাকশনে ভুলবশত ড্রাফট পোস্টের কন্টেন্ট প্রদর্শন করা অসম্ভব হয়ে যাবে কারণ সেই কোড কম্পাইলই হবে না। লিস্টিং ১৮-১৯ একটি <code>Post</code> struct এবং একটি <code>DraftPost</code> struct-এর সংজ্ঞা এবং প্রতিটির উপর মেথড দেখায়।</p>
<Listing number="18-19" file-name="src/lib.rs" caption="একটি `content` মেথড সহ `Post` এবং `content` মেথড ছাড়া `DraftPost`">
<pre><code class="language-rust noplayground">pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}</code></pre>
</Listing>
<p><code>Post</code> এবং <code>DraftPost</code> উভয় struct-এরই একটি প্রাইভেট <code>content</code> ফিল্ড আছে যা ব্লগ পোস্টের টেক্সট সংরক্ষণ করে। struct-গুলোর আর <code>state</code> ফিল্ড নেই কারণ আমরা state-এর এনকোডিং struct-গুলোর টাইপে স্থানান্তরিত করছি। <code>Post</code> struct একটি পাবলিশড পোস্টকে প্রতিনিধিত্ব করবে, এবং এর একটি <code>content</code> মেথড আছে যা <code>content</code> ফেরত দেয়।</p>
<p>আমাদের এখনও একটি <code>Post::new</code> ফাংশন আছে, কিন্তু <code>Post</code>-এর একটি ইনস্ট্যান্স ফেরত দেওয়ার পরিবর্তে, এটি <code>DraftPost</code>-এর একটি ইনস্ট্যান্স ফেরত দেয়। যেহেতু <code>content</code> প্রাইভেট এবং <code>Post</code> ফেরত দেয় এমন কোনো ফাংশন নেই, তাই এই মুহূর্তে <code>Post</code>-এর একটি ইনস্ট্যান্স তৈরি করা সম্ভব নয়।</p>
<p><code>DraftPost</code> struct-এর একটি <code>add_text</code> মেথড আছে, তাই আমরা আগের মতোই <code>content</code>-এ টেক্সট যোগ করতে পারি, কিন্তু লক্ষ্য করুন যে <code>DraftPost</code>-এর কোনো <code>content</code> মেথড সংজ্ঞায়িত নেই! তাই এখন প্রোগ্রাম নিশ্চিত করে যে সমস্ত পোস্ট ড্রাফট পোস্ট হিসাবে শুরু হয়, এবং ড্রাফট পোস্টগুলোর কন্টেন্ট প্রদর্শনের জন্য উপলব্ধ থাকে না। এই সীমাবদ্ধতাগুলো এড়ানোর যেকোনো প্রচেষ্টা একটি কম্পাইলার ত্রুটির কারণ হবে।</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="implementing-transitions-as-transformations-into-different-types"></a></p>
<p>তাহলে আমরা কীভাবে একটি পাবলিশড পোস্ট পাব? আমরা এই নিয়মটি প্রয়োগ করতে চাই যে একটি ড্রাফট পোস্ট পাবলিশড হওয়ার আগে অবশ্যই রিভিউ এবং অনুমোদিত হতে হবে। পেন্ডিং রিভিউ state-এ থাকা একটি পোস্টেরও কোনো কন্টেন্ট প্রদর্শন করা উচিত নয়। চলুন এই সীমাবদ্ধতাগুলো ইমপ্লিমেন্ট করি একটি নতুন struct, <code>PendingReviewPost</code> যোগ করে, <code>DraftPost</code>-এর উপর <code>request_review</code> মেথড সংজ্ঞায়িত করে যা একটি <code>PendingReviewPost</code> ফেরত দেবে এবং <code>PendingReviewPost</code>-এর উপর একটি <code>approve</code> মেথড সংজ্ঞায়িত করে যা একটি <code>Post</code> ফেরত দেবে, যেমনটি লিস্টিং ১৮-২০-তে দেখানো হয়েছে।</p>
<Listing number="18-20" file-name="src/lib.rs" caption="একটি `PendingReviewPost` যা `DraftPost`-এর উপর `request_review` কল করে তৈরি হয় এবং একটি `approve` মেথড যা একটি `PendingReviewPost`-কে একটি পাবলিশড `Post`-এ পরিণত করে">
<pre><code class="language-rust noplayground"><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Post {
</span><span class="boring">    pub fn new() -&gt; DraftPost {
</span><span class="boring">        DraftPost {
</span><span class="boring">            content: String::new(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn content(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.content
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--
<span class="boring">    pub fn add_text(&amp;mut self, text: &amp;str) {
</span><span class="boring">        self.content.push_str(text);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}</code></pre>
</Listing>
<p><code>request_review</code> এবং <code>approve</code> মেথডগুলো <code>self</code>-এর মালিকানা নেয়, ফলে <code>DraftPost</code> এবং <code>PendingReviewPost</code> ইনস্ট্যান্সগুলো কনজিউম করে এবং সেগুলোকে যথাক্রমে একটি <code>PendingReviewPost</code> এবং একটি পাবলিশড <code>Post</code>-এ রূপান্তরিত করে। এভাবে, আমরা <code>request_review</code> কল করার পরে কোনো অবশিষ্ট <code>DraftPost</code> ইনস্ট্যান্স রাখব না, এবং এভাবেই চলতে থাকবে। <code>PendingReviewPost</code> struct-এর কোনো <code>content</code> মেথড সংজ্ঞায়িত নেই, তাই এর কন্টেন্ট পড়ার চেষ্টা করলে <code>DraftPost</code>-এর মতো একটি কম্পাইলার ত্রুটি হবে। যেহেতু একটি পাবলিশড <code>Post</code> ইনস্ট্যান্স পাওয়ার একমাত্র উপায় হলো <code>PendingReviewPost</code>-এর উপর <code>approve</code> মেথড কল করা, এবং <code>PendingReviewPost</code> পাওয়ার একমাত্র উপায় হলো <code>DraftPost</code>-এর উপর <code>request_review</code> মেথড কল করা, তাই আমরা এখন ব্লগ পোস্ট ওয়ার্কফ্লোটিকে টাইপ সিস্টেমে এনকোড করেছি।</p>
<p>কিন্তু আমাদের <code>main</code>-এও কিছু ছোট পরিবর্তন করতে হবে। <code>request_review</code> এবং <code>approve</code> মেথডগুলো যে struct-এর উপর কল করা হয় তা পরিবর্তন না করে নতুন ইনস্ট্যান্স ফেরত দেয়, তাই আমাদের ফেরত আসা ইনস্ট্যান্সগুলো সংরক্ষণ করার জন্য আরও <code>let post =</code> শ্যাডোইং অ্যাসাইনমেন্ট যোগ করতে হবে। আমরা ড্রাফট এবং পেন্ডিং রিভিউ পোস্টগুলোর কন্টেন্ট খালি স্ট্রিং হওয়ার ব্যাপারে অ্যাসারশনও রাখতে পারব না, আর আমাদের সেগুলোর প্রয়োজনও নেই: আমরা আর এমন কোড কম্পাইল করতে পারব না যা সেই state-গুলোতে পোস্টের কন্টেন্ট ব্যবহার করার চেষ্টা করে। <code>main</code>-এর আপডেট করা কোড লিস্টিং ১৮-২১-এ দেখানো হয়েছে।</p>
<Listing number="18-21" file-name="src/main.rs" caption="ব্লগ পোস্ট ওয়ার্কফ্লোর নতুন ইমপ্লিমেন্টেশন ব্যবহার করার জন্য `main`-এর পরিবর্তন">
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}</code></pre>
</Listing>
<p><code>post</code>-কে পুনরায় অ্যাসাইন করার জন্য <code>main</code>-এ আমাদের যে পরিবর্তনগুলো করতে হয়েছে তার মানে হলো এই ইমপ্লিমেন্টেশনটি আর ঠিক অবজেক্ট-ওরিয়েন্টেড স্টেট প্যাটার্ন অনুসরণ করে না: state-গুলোর মধ্যে রূপান্তর আর সম্পূর্ণরূপে <code>Post</code> ইমপ্লিমেন্টেশনের মধ্যে এনক্যাপসুলেট করা নেই। তবে, আমাদের লাভ হলো যে অবৈধ state-গুলো এখন টাইপ সিস্টেম এবং কম্পাইল টাইমে ঘটে যাওয়া টাইপ চেকিংয়ের কারণে অসম্ভব! এটি নিশ্চিত করে যে কিছু বাগ, যেমন একটি অপ্রকাশিত পোস্টের কন্টেন্ট প্রদর্শন, প্রোডাকশনে যাওয়ার আগেই আবিষ্কৃত হবে।</p>
<p>এই সেকশনের শুরুতে প্রস্তাবিত কাজগুলো লিস্টিং ১৮-২১-এর পরের <code>blog</code> ক্রেটের উপর চেষ্টা করে দেখুন এই ভার্সনের কোডের ডিজাইন সম্পর্কে আপনার কী মনে হয়। লক্ষ্য করুন যে কিছু কাজ এই ডিজাইনে ইতিমধ্যে সম্পন্ন হয়ে থাকতে পারে।</p>
<p>আমরা দেখেছি যে যদিও Rust অবজেক্ট-ওরিয়েন্টেড ডিজাইন প্যাটার্ন ইমপ্লিমেন্ট করতে সক্ষম, তবে Rust-এ অন্যান্য প্যাটার্নও উপলব্ধ আছে, যেমন টাইপ সিস্টেমে state এনকোড করা। এই প্যাটার্নগুলোর ভিন্ন ভিন্ন সুবিধা-অসুবিধা রয়েছে। যদিও আপনি অবজেক্ট-ওরিয়েন্টেড প্যাটার্নগুলোর সাথে খুব পরিচিত হতে পারেন, Rust-এর বৈশিষ্ট্যগুলোর সুবিধা নেওয়ার জন্য সমস্যাটি নতুনভাবে চিন্তা করা সুবিধা প্রদান করতে পারে, যেমন কম্পাইল টাইমে কিছু বাগ প্রতিরোধ করা। অবজেক্ট-ওরিয়েন্টেড প্যাটার্নগুলো Rust-এ সর্বদা সেরা সমাধান হবে না কারণ কিছু বৈশিষ্ট্য, যেমন মালিকানা (ownership), যা অবজেক্ট-ওরিয়েন্টেড ল্যাঙ্গুয়েজগুলোতে নেই।</p>
<h2 id="সারাংশ-summary"><a class="header" href="#সারাংশ-summary">সারাংশ (Summary)</a></h2>
<p>এই অধ্যায়টি পড়ার পরে আপনি Rust-কে একটি অবজেক্ট-ওরিয়েন্টেড ল্যাঙ্গুয়েজ মনে করেন কি না তা নির্বিশেষে, আপনি এখন জানেন যে আপনি Rust-এ কিছু অবজেক্ট-ওরিয়েন্টেড বৈশিষ্ট্য পেতে ট্রেইট অবজেক্ট ব্যবহার করতে পারেন। ডাইনামিক ডিসপ্যাচ আপনার কোডকে কিছুটা রানটাইম পারফরম্যান্সের বিনিময়ে কিছু নমনীয়তা দিতে পারে। আপনি এই নমনীয়তা ব্যবহার করে অবজেক্ট-ওরিয়েন্টেড প্যাটার্ন ইমপ্লিমেন্ট করতে পারেন যা আপনার কোডের রক্ষণাবেক্ষণে সহায়তা করতে পারে। Rust-এর অন্যান্য বৈশিষ্ট্যও রয়েছে, যেমন মালিকানা, যা অবজেক্ট-ওরিয়েন্টেড ল্যাঙ্গুয়েজগুলোতে নেই। একটি অবজেক্ট-ওরিয়েন্টেড প্যাটার্ন সর্বদা Rust-এর শক্তিশালী দিকগুলোর সুবিধা নেওয়ার সেরা উপায় হবে না, তবে এটি একটি উপলব্ধ বিকল্প।</p>
<p>এরপরে, আমরা প্যাটার্নগুলো দেখব, যা Rust-এর আরেকটি বৈশিষ্ট্য যা প্রচুর নমনীয়তা সক্ষম করে। আমরা বই জুড়ে সংক্ষেপে সেগুলোর দিকে নজর দিয়েছি কিন্তু এখনও তাদের সম্পূর্ণ ক্ষমতা দেখিনি। চলুন শুরু করা যাক!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch18-02-trait-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch19-00-patterns.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch18-02-trait-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch19-00-patterns.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
