<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RefCell&lt;T&gt; এবং ইন্টেরিয়র মিউটেবিলিটি প্যাটার্ন - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="refcellt-এবং-ইনটেরিয়র-মিউটেবিলিটি-পযাটারন-interior-mutability-pattern"><a class="header" href="#refcellt-এবং-ইনটেরিয়র-মিউটেবিলিটি-পযাটারন-interior-mutability-pattern"><code>RefCell&lt;T&gt;</code> এবং ইন্টেরিয়র মিউটেবিলিটি প্যাটার্ন (Interior Mutability Pattern)</a></h2>
<p><em>Interior mutability</em> রাস্টের একটি ডিজাইন প্যাটার্ন যা আপনাকে ডেটা পরিবর্তন করার অনুমতি দেয়, এমনকি যখন সেই ডেটার immutable reference থাকে; সাধারণত, borrowing-এর নিয়ম অনুযায়ী এই কাজটি নিষিদ্ধ। ডেটা পরিবর্তন করার জন্য, এই প্যাটার্নটি একটি ডেটা স্ট্রাকচারের ভিতরে <code>unsafe</code> কোড ব্যবহার করে রাস্টের স্বাভাবিক নিয়মাবলী, যা পরিবর্তন এবং borrowing নিয়ন্ত্রণ করে, সেগুলোকে কিছুটা বাঁকিয়ে দেয়। <code>unsafe</code> কোড কম্পাইলারকে নির্দেশ করে যে আমরা নিয়মগুলো ম্যানুয়ালি পরীক্ষা করছি, কম্পাইলারের উপর নির্ভর না করে; আমরা Chapter 20-এ <code>unsafe</code> কোড নিয়ে আরও আলোচনা করব।</p>
<p>আমরা শুধুমাত্র তখনই interior mutability প্যাটার্ন ব্যবহারকারী টাইপগুলো ব্যবহার করতে পারি যখন আমরা নিশ্চিত করতে পারি যে borrowing-এর নিয়মগুলো রানটাইমে অনুসরণ করা হবে, যদিও কম্পাইলার এর গ্যারান্টি দিতে পারে না। ব্যবহৃত <code>unsafe</code> কোডটি তখন একটি নিরাপদ API-এর মধ্যে মোড়ানো থাকে, এবং বাইরের টাইপটি তখনও immutable থাকে।</p>
<p>চলুন, <code>RefCell&lt;T&gt;</code> টাইপটি দেখে এই ধারণাটি অন্বেষেষণ করি, যা interior mutability প্যাটার্ন অনুসরণ করে।</p>
<h3 id="refcellt-দিযে-রানটাইমে-borrowing-এর-নিযম-পরযোগ-করা"><a class="header" href="#refcellt-দিযে-রানটাইমে-borrowing-এর-নিযম-পরযোগ-করা"><code>RefCell&lt;T&gt;</code> দিয়ে রানটাইমে Borrowing-এর নিয়ম প্রয়োগ করা</a></h3>
<p><code>Rc&lt;T&gt;</code>-এর মতো নয়, <code>RefCell&lt;T&gt;</code> টাইপটি তার ধারণ করা ডেটার উপর একক মালিকানা (single ownership) প্রতিনিধিত্ব করে। তাহলে <code>Box&lt;T&gt;</code>-এর মতো টাইপ থেকে <code>RefCell&lt;T&gt;</code> কীভাবে আলাদা? Chapter 4-এ শেখা borrowing-এর নিয়মগুলো মনে করুন:</p>
<ul>
<li>যেকোনো নির্দিষ্ট সময়ে, আপনার কাছে <em>হয়</em> একটি mutable reference অথবা যেকোনো সংখ্যক immutable reference থাকতে পারে (কিন্তু উভয়ই নয়)।</li>
<li>Reference সবসময় বৈধ (valid) হতে হবে।</li>
</ul>
<p>Reference এবং <code>Box&lt;T&gt;</code>-এর ক্ষেত্রে, borrowing-এর নিয়মের এই শর্তগুলো কম্পাইল টাইমে (compile time) প্রয়োগ করা হয়। <code>RefCell&lt;T&gt;</code>-এর ক্ষেত্রে, এই শর্তগুলো <em>রানটাইমে</em> (runtime) প্রয়োগ করা হয়। Reference-এর সাথে, আপনি যদি এই নিয়মগুলো ভঙ্গ করেন, তাহলে আপনি একটি কম্পাইলার এরর পাবেন। <code>RefCell&lt;T&gt;</code>-এর সাথে, আপনি যদি এই নিয়মগুলো ভঙ্গ করেন, আপনার প্রোগ্রামটি প্যানিক (panic) করবে এবং বন্ধ হয়ে যাবে।</p>
<p>কম্পাইল টাইমে borrowing-এর নিয়ম পরীক্ষা করার সুবিধা হলো যে এররগুলো ডেভেলপমেন্ট প্রক্রিয়ার শুরুতেই ধরা পড়ে, এবং রানটাইম পারফরম্যান্সের উপর কোনো প্রভাব পড়ে না কারণ সমস্ত বিশ্লেষণ আগে থেকেই সম্পন্ন হয়। এই কারণগুলোর জন্য, বেশিরভাগ ক্ষেত্রে কম্পাইল টাইমে borrowing-এর নিয়ম পরীক্ষা করাই সেরা পছন্দ, আর একারণেই এটি রাস্টের ডিফল্ট আচরণ।</p>
<p>এর পরিবর্তে রানটাইমে borrowing-এর নিয়ম পরীক্ষা করার সুবিধা হলো যে কিছু মেমরি-সেফ (memory-safe) পরিস্থিতি তখন অনুমোদিত হয়, যা কম্পাইল-টাইম চেক দ্বারা নিষিদ্ধ হতো। স্ট্যাটিক অ্যানালাইসিস (Static analysis), যেমন রাস্ট কম্পাইলার, স্বভাবতই রক্ষণশীল (conservative)। কোডের কিছু বৈশিষ্ট্য কোড বিশ্লেষণ করে সনাক্ত করা অসম্ভব: সবচেয়ে বিখ্যাত উদাহরণ হলো Halting Problem, যা এই বইয়ের আওতার বাইরে কিন্তু গবেষণার জন্য একটি আকর্ষণীয় বিষয়।</p>
<p>যেহেতু কিছু বিশ্লেষণ অসম্ভব, তাই যদি রাস্ট কম্পাইলার নিশ্চিত না হতে পারে যে কোডটি ownership-এর নিয়ম মেনে চলে, তবে এটি একটি সঠিক প্রোগ্রাম প্রত্যাখ্যান করতে পারে; এইভাবে, এটি রক্ষণশীল। যদি রাস্ট একটি ভুল প্রোগ্রাম গ্রহণ করত, ব্যবহারকারীরা রাস্টের দেওয়া গ্যারান্টির উপর বিশ্বাস রাখতে পারত না। তবে, যদি রাস্ট একটি সঠিক প্রোগ্রাম প্রত্যাখ্যান করে, প্রোগ্রামার অসুবিধায় পড়বে, কিন্তু কোনো বিপর্যয় ঘটবে না। <code>RefCell&lt;T&gt;</code> টাইপটি উপযোগী যখন আপনি নিশ্চিত যে আপনার কোড borrowing-এর নিয়ম অনুসরণ করে কিন্তু কম্পাইলার তা বুঝতে এবং গ্যারান্টি দিতে অক্ষম।</p>
<p><code>Rc&lt;T&gt;</code>-এর মতো, <code>RefCell&lt;T&gt;</code> শুধুমাত্র সিঙ্গেল-থ্রেডেড পরিস্থিতিতে ব্যবহারের জন্য এবং আপনি যদি এটি মাল্টি-থ্রেডেড কনটেক্সটে ব্যবহার করার চেষ্টা করেন তবে এটি আপনাকে একটি কম্পাইল-টাইম এরর দেবে। আমরা Chapter 16-এ একটি মাল্টি-থ্রেডেড প্রোগ্রামে <code>RefCell&lt;T&gt;</code>-এর কার্যকারিতা কীভাবে পাওয়া যায় সে সম্পর্কে কথা বলব।</p>
<p><code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, বা <code>RefCell&lt;T&gt;</code> বেছে নেওয়ার কারণগুলোর একটি সারসংক্ষেপ নিচে দেওয়া হলো:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> একই ডেটার একাধিক owner সক্ষম করে; <code>Box&lt;T&gt;</code> এবং <code>RefCell&lt;T&gt;</code>-এর একক owner থাকে।</li>
<li><code>Box&lt;T&gt;</code> কম্পাইল টাইমে চেক করা immutable বা mutable borrow-এর অনুমতি দেয়; <code>Rc&lt;T&gt;</code> শুধুমাত্র কম্পাইল টাইমে চেক করা immutable borrow-এর অনুমতি দেয়; <code>RefCell&lt;T&gt;</code> রানটাইমে চেক করা immutable বা mutable borrow-এর অনুমতি দেয়।</li>
<li>যেহেতু <code>RefCell&lt;T&gt;</code> রানটাইমে চেক করা mutable borrow-এর অনুমতি দেয়, তাই আপনি <code>RefCell&lt;T&gt;</code>-এর ভেতরের ভ্যালুটি পরিবর্তন করতে পারেন এমনকি যখন <code>RefCell&lt;T&gt;</code>-টি immutable থাকে।</li>
</ul>
<p>একটি immutable ভ্যালুর ভেতরের ভ্যালু পরিবর্তন করাই হলো <em>interior mutability</em> প্যাটার্ন। চলুন এমন একটি পরিস্থিতি দেখি যেখানে interior mutability উপযোগী এবং এটি কীভাবে সম্ভব তা পরীক্ষা করি।</p>
<h3 id="ইনটেরিয়র-মিউটেবিলিটি-একটি-immutable-ভযালুর-জনয-mutable-borrow"><a class="header" href="#ইনটেরিয়র-মিউটেবিলিটি-একটি-immutable-ভযালুর-জনয-mutable-borrow">ইন্টেরিয়র মিউটেবিলিটি: একটি Immutable ভ্যালুর জন্য Mutable Borrow</a></h3>
<p>Borrowing-এর নিয়মের একটি ফলাফল হলো যখন আপনার কাছে একটি immutable ভ্যালু থাকে, আপনি এটিকে mutable-ভাবে borrow করতে পারবেন না। উদাহরণস্বরূপ, এই কোডটি কম্পাইল হবে না:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}</code></pre>
<p>আপনি যদি এই কোডটি কম্পাইল করার চেষ্টা করতেন, আপনি নিম্নলিখিত এররটি পেতেন:</p>
<pre><code class="language-console">$ cargo run
   Compiling borrowing v0.1.0 (file:///projects/borrowing)
error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
 --&gt; src/main.rs:3:13
  |
3 |     let y = &amp;mut x;
  |             ^^^^^^ cannot borrow as mutable
  |
help: consider changing this to be mutable
  |
2 |     let mut x = 5;
  |         +++

For more information about this error, try `rustc --explain E0596`.
error: could not compile `borrowing` (bin "borrowing") due to 1 previous error
</code></pre>
<p>তবে, এমন পরিস্থিতি আছে যেখানে একটি ভ্যালুর জন্য তার মেথডগুলোতে নিজেকে পরিবর্তন করা উপযোগী হবে কিন্তু অন্য কোডের কাছে এটি immutable বলে মনে হবে। ভ্যালুর মেথডগুলোর বাইরের কোড ভ্যালুটি পরিবর্তন করতে পারবে না। <code>RefCell&lt;T&gt;</code> ব্যবহার করা interior mutability-র ক্ষমতা পাওয়ার একটি উপায়, কিন্তু <code>RefCell&lt;T&gt;</code> borrowing-এর নিয়মগুলো পুরোপুরি এড়িয়ে যায় না: কম্পাইলারের borrow checker এই interior mutability-কে অনুমতি দেয়, এবং borrowing-এর নিয়মগুলো রানটাইমে পরীক্ষা করা হয়। যদি আপনি নিয়ম লঙ্ঘন করেন, তাহলে আপনি কম্পাইলার এররের পরিবর্তে একটি <code>panic!</code> পাবেন।</p>
<p>চলুন একটি বাস্তব উদাহরণ দেখি যেখানে আমরা <code>RefCell&lt;T&gt;</code> ব্যবহার করে একটি immutable ভ্যালু পরিবর্তন করতে পারি এবং দেখি কেন এটি উপযোগী।</p>
<h4 id="ইনটেরিয়র-মিউটেবিলিটির-একটি-বযবহার-মক-অবজেকট-mock-objects"><a class="header" href="#ইনটেরিয়র-মিউটেবিলিটির-একটি-বযবহার-মক-অবজেকট-mock-objects">ইন্টেরিয়র মিউটেবিলিটির একটি ব্যবহার: মক অবজেক্ট (Mock Objects)</a></h4>
<p>কখনও কখনও টেস্টিংয়ের সময় একজন প্রোগ্রামার একটি নির্দিষ্ট আচরণ পর্যবেক্ষণ করতে এবং এটি সঠিকভাবে ইমপ্লিমেন্ট করা হয়েছে কিনা তা নিশ্চিত করতে অন্য একটি টাইপের জায়গায় একটি টাইপ ব্যবহার করেন। এই placeholder টাইপটিকে বলা হয় <em>test double</em>। এটিকে ফিল্মমেকিং-এর স্টান্ট ডাবলের মতো ভাবুন, যেখানে একজন ব্যক্তি একটি বিশেষভাবে কঠিন দৃশ্যের জন্য একজন অভিনেতার পরিবর্তে কাজ করে। আমরা যখন টেস্ট চালাই তখন টেস্ট ডাবলগুলো অন্য টাইপের জন্য দাঁড়িয়ে থাকে। <em>Mock objects</em> হলো বিশেষ ধরনের টেস্ট ডাবল যা একটি টেস্টের সময় কী ঘটে তা রেকর্ড করে যাতে আপনি assert করতে পারেন যে সঠিক কাজগুলো হয়েছে।</p>
<p>অন্যান্য ভাষায় যেমন অবজেক্ট আছে, রাস্ট-এ সেই অর্থে অবজেক্ট নেই, এবং রাস্টের স্ট্যান্ডার্ড লাইব্রেরিতে অন্য কিছু ভাষার মতো মক অবজেক্ট কার্যকারিতা বিল্ট-ইন নেই। তবে, আপনি অবশ্যই একটি struct তৈরি করতে পারেন যা একটি মক অবজেক্টের মতো একই উদ্দেশ্যে কাজ করবে।</p>
<p>এখানে আমরা যে পরিস্থিতিটি পরীক্ষা করব: আমরা একটি লাইব্রেরি তৈরি করব যা একটি সর্বোচ্চ মানের (maximum value) বিপরীতে একটি মান ট্র্যাক করে এবং বর্তমান মানটি সর্বোচ্চ মানের কতটা কাছাকাছি তার উপর ভিত্তি করে বার্তা পাঠায়। এই লাইব্রেরিটি একজন ব্যবহারকারীর API কল করার কোটা ট্র্যাক করতে ব্যবহার করা যেতে পারে, উদাহরণস্বরূপ।</p>
<p>আমাদের লাইব্রেরি শুধুমাত্র একটি মান সর্বোচ্চ মানের কতটা কাছাকাছি তা ট্র্যাক করার কার্যকারিতা এবং কোন সময়ে কী বার্তা হওয়া উচিত তা সরবরাহ করবে। আমাদের লাইব্রেরি ব্যবহারকারী অ্যাপ্লিকেশনগুলো থেকে বার্তা পাঠানোর ব্যবস্থা সরবরাহ করার আশা করা হবে: অ্যাপ্লিকেশনটি অ্যাপ্লিকেশনে একটি বার্তা রাখতে পারে, একটি ইমেল পাঠাতে পারে, একটি টেক্সট বার্তা পাঠাতে পারে, বা অন্য কিছু করতে পারে। লাইব্রেরিকে সেই বিস্তারিত জানার প্রয়োজন নেই। এটির যা প্রয়োজন তা হলো এমন কিছু যা আমরা <code>Messenger</code> নামে একটি ট্রেইট সরবরাহ করব তা ইমপ্লিমেন্ট করে। Listing 15-20 লাইব্রেরি কোডটি দেখায়।</p>
<Listing number="15-20" file-name="src/lib.rs" caption="একটি লাইব্রেরি যা একটি মান সর্বোচ্চ মানের কতটা কাছাকাছি তা ট্র্যাক করে এবং মান নির্দিষ্ট স্তরে থাকলে সতর্ক করে">
<pre><code class="language-rust noplayground">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
</Listing>
<p>এই কোডের একটি গুরুত্বপূর্ণ অংশ হলো <code>Messenger</code> ট্রেইটের <code>send</code> নামে একটি মেথড আছে যা <code>self</code>-এর একটি immutable reference এবং বার্তার টেক্সট নেয়। এই ট্রেইটটি হলো সেই ইন্টারফেস যা আমাদের মক অবজেক্টকে ইমপ্লিমেন্ট করতে হবে যাতে মকটি একটি আসল অবজেক্টের মতো একইভাবে ব্যবহার করা যায়। অন্য গুরুত্বপূর্ণ অংশ হলো আমরা <code>LimitTracker</code>-এর <code>set_value</code> মেথডের আচরণ পরীক্ষা করতে চাই। আমরা <code>value</code> প্যারামিটারের জন্য যা পাস করি তা পরিবর্তন করতে পারি, কিন্তু <code>set_value</code> আমাদের assert করার জন্য কিছু রিটার্ন করে না। আমরা বলতে চাই যে যদি আমরা <code>Messenger</code> ট্রেইট ইমপ্লিমেন্ট করে এমন কিছু এবং <code>max</code>-এর জন্য একটি নির্দিষ্ট মান দিয়ে একটি <code>LimitTracker</code> তৈরি করি, যখন আমরা <code>value</code>-এর জন্য বিভিন্ন সংখ্যা পাস করি তখন মেসেঞ্জারকে উপযুক্ত বার্তা পাঠাতে বলা হয়।</p>
<p>আমাদের একটি মক অবজেক্ট দরকার যা, <code>send</code> কল করার সময় ইমেল বা টেক্সট বার্তা পাঠানোর পরিবর্তে, শুধুমাত্র তাকে যে বার্তাগুলো পাঠাতে বলা হয়েছে সেগুলো ট্র্যাক করবে। আমরা মক অবজেক্টের একটি নতুন ইনস্ট্যান্স তৈরি করতে পারি, মক অবজেক্ট ব্যবহার করে এমন একটি <code>LimitTracker</code> তৈরি করতে পারি, <code>LimitTracker</code>-এর <code>set_value</code> মেথড কল করতে পারি, এবং তারপর পরীক্ষা করতে পারি যে মক অবজেক্টে আমাদের প্রত্যাশিত বার্তাগুলো আছে কিনা। Listing 15-21 একটি মক অবজেক্ট ইমপ্লিমেন্ট করার একটি প্রচেষ্টা দেখায়, কিন্তু borrow checker এটি অনুমোদন করবে না।</p>
<Listing number="15-21" file-name="src/lib.rs" caption="একটি `MockMessenger` ইমপ্লিমেন্ট করার প্রচেষ্টা যা borrow checker দ্বারা অনুমোদিত নয়">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: vec![],
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}</code></pre>
</Listing>
<p>এই টেস্ট কোডটি একটি <code>MockMessenger</code> struct সংজ্ঞায়িত করে যার <code>sent_messages</code> নামে একটি ফিল্ড আছে যেখানে <code>Vec&lt;String&gt;</code> মানের একটি ভেক্টর রয়েছে যা তাকে পাঠানো বার্তাগুলো ট্র্যাক করার জন্য। আমরা একটি <code>new</code> নামের associated function-ও সংজ্ঞায়িত করি যাতে খালি বার্তা তালিকা দিয়ে নতুন <code>MockMessenger</code> মান তৈরি করা সুবিধাজনক হয়। তারপর আমরা <code>MockMessenger</code>-এর জন্য <code>Messenger</code> ট্রেইট ইমপ্লিমেন্ট করি যাতে আমরা একটি <code>MockMessenger</code>-কে একটি <code>LimitTracker</code>-কে দিতে পারি। <code>send</code> মেথডের সংজ্ঞায়, আমরা প্যারামিটার হিসাবে পাস করা বার্তাটি নিই এবং এটিকে <code>MockMessenger</code>-এর <code>sent_messages</code> তালিকায় সংরক্ষণ করি।</p>
<p>টেস্টে, আমরা পরীক্ষা করছি যে <code>LimitTracker</code>-কে <code>value</code> এমন কিছুতে সেট করতে বলা হলে কী হয় যা <code>max</code> মানের ৭৫ শতাংশের বেশি। প্রথমে আমরা একটি নতুন <code>MockMessenger</code> তৈরি করি, যা একটি খালি বার্তা তালিকা দিয়ে শুরু হবে। তারপর আমরা একটি নতুন <code>LimitTracker</code> তৈরি করি এবং এটিকে নতুন <code>MockMessenger</code>-এর একটি রেফারেন্স এবং <code>100</code>-এর একটি <code>max</code> মান দিই। আমরা <code>LimitTracker</code>-এর <code>set_value</code> মেথডটি <code>80</code> মান দিয়ে কল করি, যা ১০০-এর ৭৫ শতাংশের বেশি। তারপর আমরা assert করি যে <code>MockMessenger</code> যে বার্তাগুলোর তালিকা ট্র্যাক করছে তাতে এখন একটি বার্তা থাকা উচিত।</p>
<p>তবে, এই টেস্টে একটি সমস্যা আছে, যেমনটি এখানে দেখানো হয়েছে:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference
  --&gt; src/lib.rs:58:13
   |
58 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable
   |
help: consider changing this to be a mutable reference in the `impl` method and the `trait` definition
   |
2  ~     fn send(&amp;mut self, msg: &amp;str);
3  | }
...
56 |     impl Messenger for MockMessenger {
57 ~         fn send(&amp;mut self, message: &amp;str) {
   |

For more information about this error, try `rustc --explain E0596`.
error: could not compile `limit-tracker` (lib test) due to 1 previous error
</code></pre>
<p>আমরা <code>MockMessenger</code>-কে বার্তাগুলোর ট্র্যাক রাখার জন্য মডিফাই করতে পারি না কারণ <code>send</code> মেথডটি <code>self</code>-এর একটি immutable reference নেয়। আমরা এরর টেক্সট থেকে <code>&amp;mut self</code> ব্যবহার করার পরামর্শটিও নিতে পারি না। আমরা শুধুমাত্র টেস্টিংয়ের জন্য <code>Messenger</code> ট্রেইট পরিবর্তন করতে চাই না। পরিবর্তে, আমাদের বিদ্যমান ডিজাইনের সাথে আমাদের টেস্ট কোড সঠিকভাবে কাজ করার একটি উপায় খুঁজে বের করতে হবে।</p>
<p>এটি এমন একটি পরিস্থিতি যেখানে ইন্টেরিয়র মিউটেবিলিটি সাহায্য করতে পারে! আমরা <code>sent_messages</code>-কে একটি <code>RefCell&lt;T&gt;</code>-এর মধ্যে সংরক্ষণ করব, এবং তারপর <code>send</code> মেথড <code>sent_messages</code> পরিবর্তন করতে সক্ষম হবে যাতে আমরা যে বার্তাগুলো দেখেছি তা সংরক্ষণ করতে পারে। Listing 15-22 দেখাচ্ছে এটি কেমন দেখায়।</p>
<Listing number="15-22" file-name="src/lib.rs" caption="`RefCell<T>` ব্যবহার করে একটি ভেতরের ভ্যালু পরিবর্তন করা যখন বাইরের ভ্যালুটি immutable হিসাবে বিবেচিত হয়">
<pre><code class="language-rust noplayground"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
</Listing>
<p><code>sent_messages</code> ফিল্ডটি এখন <code>Vec&lt;String&gt;</code>-এর পরিবর্তে <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> টাইপের। <code>new</code> ফাংশনে, আমরা খালি ভেক্টরের চারপাশে একটি নতুন <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> ইনস্ট্যান্স তৈরি করি।</p>
<p><code>send</code> মেথডের ইমপ্লিমেন্টেশনের জন্য, প্রথম প্যারামিটারটি এখনও <code>self</code>-এর একটি immutable borrow, যা ট্রেইট সংজ্ঞার সাথে মেলে। আমরা <code>self.sent_messages</code>-এর <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>-এর উপর <code>borrow_mut</code> কল করি যাতে <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>-এর ভেতরের ভ্যালু, যা হলো ভেক্টর, তার একটি mutable reference পেতে পারি। তারপর আমরা ভেক্টরের mutable reference-এর উপর <code>push</code> কল করতে পারি যাতে টেস্টের সময় পাঠানো বার্তাগুলো ট্র্যাক রাখা যায়।</p>
<p>শেষ যে পরিবর্তনটি আমাদের করতে হবে তা হলো assertion-এ: ভেতরের ভেক্টরে কতগুলো আইটেম আছে তা দেখতে, আমরা <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>-এর উপর <code>borrow</code> কল করি যাতে ভেক্টরের একটি immutable reference পেতে পারি।</p>
<p>এখন যেহেতু আপনি <code>RefCell&lt;T&gt;</code> কীভাবে ব্যবহার করতে হয় তা দেখেছেন, আসুন আমরা দেখি এটি কীভাবে কাজ করে!</p>
<h4 id="refcellt-এর-মাধযমে-রানটাইমে-borrow-টরযাক-রাখা"><a class="header" href="#refcellt-এর-মাধযমে-রানটাইমে-borrow-টরযাক-রাখা"><code>RefCell&lt;T&gt;</code> এর মাধ্যমে রানটাইমে Borrow ট্র্যাক রাখা</a></h4>
<p>Immutable এবং mutable reference তৈরি করার সময়, আমরা যথাক্রমে <code>&amp;</code> এবং <code>&amp;mut</code> সিনট্যাক্স ব্যবহার করি। <code>RefCell&lt;T&gt;</code>-এর সাথে, আমরা <code>borrow</code> এবং <code>borrow_mut</code> মেথড ব্যবহার করি, যা <code>RefCell&lt;T&gt;</code>-এর নিরাপদ API-এর অংশ। <code>borrow</code> মেথডটি স্মার্ট পয়েন্টার টাইপ <code>Ref&lt;T&gt;</code> রিটার্ন করে, এবং <code>borrow_mut</code> স্মার্ট পয়েন্টার টাইপ <code>RefMut&lt;T&gt;</code> রিটার্ন করে। উভয় টাইপই <code>Deref</code> ইমপ্লিমেন্ট করে, তাই আমরা তাদের সাধারণ reference-এর মতো ব্যবহার করতে পারি।</p>
<p><code>RefCell&lt;T&gt;</code> ট্র্যাক রাখে যে বর্তমানে কতগুলো <code>Ref&lt;T&gt;</code> এবং <code>RefMut&lt;T&gt;</code> স্মার্ট পয়েন্টার সক্রিয় আছে। প্রতিবার যখন আমরা <code>borrow</code> কল করি, <code>RefCell&lt;T&gt;</code> তার সক্রিয় immutable borrow-এর সংখ্যা বাড়িয়ে দেয়। যখন একটি <code>Ref&lt;T&gt;</code> ভ্যালু স্কোপের বাইরে চলে যায়, immutable borrow-এর সংখ্যা ১ কমে যায়। ঠিক কম্পাইল-টাইম borrowing নিয়মের মতোই, <code>RefCell&lt;T&gt;</code> আমাদের যেকোনো সময়ে অনেকগুলো immutable borrow অথবা একটি mutable borrow রাখার অনুমতি দেয়।</p>
<p>যদি আমরা এই নিয়মগুলো লঙ্ঘন করার চেষ্টা করি, তাহলে reference-এর ক্ষেত্রে যেমন কম্পাইলার এরর পেতাম, তার পরিবর্তে <code>RefCell&lt;T&gt;</code>-এর ইমপ্লিমেন্টেশন রানটাইমে প্যানিক করবে। Listing 15-23 Listing 15-22-এর <code>send</code>-এর ইমপ্লিমেন্টেশনের একটি পরিবর্তন দেখায়। আমরা ইচ্ছাকৃতভাবে একই স্কোপের জন্য দুটি সক্রিয় mutable borrow তৈরি করার চেষ্টা করছি যাতে দেখানো যায় যে <code>RefCell&lt;T&gt;</code> আমাদের রানটাইমে এটি করা থেকে বিরত রাখে।</p>
<Listing number="15-23" file-name="src/lib.rs" caption="`RefCell<T>` যে প্যানিক করবে তা দেখতে একই স্কোপে দুটি mutable reference তৈরি করা">
<pre><code class="language-rust ignore panics"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">where
</span><span class="boring">    T: Messenger,
</span><span class="boring">{
</span><span class="boring">    pub fn new(messenger: &amp;'a T, max: usize) -&gt; LimitTracker&lt;'a, T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send("Error: You are over your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Urgent warning: You've used up over 90% of your quota!");
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger
</span><span class="boring">                .send("Warning: You've used up over 75% of your quota!");
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">    struct MockMessenger {
</span><span class="boring">        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    impl MockMessenger {
</span><span class="boring">        fn new() -&gt; MockMessenger {
</span><span class="boring">            MockMessenger {
</span><span class="boring">                sent_messages: RefCell::new(vec![]),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            let mut one_borrow = self.sent_messages.borrow_mut();
            let mut two_borrow = self.sent_messages.borrow_mut();

            one_borrow.push(String::from(message));
            two_borrow.push(String::from(message));
        }
    }
<span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_sends_an_over_75_percent_warning_message() {
</span><span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">
</span><span class="boring">        limit_tracker.set_value(80);
</span><span class="boring">
</span><span class="boring">        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</Listing>
<p>আমরা <code>borrow_mut</code> থেকে রিটার্ন করা <code>RefMut&lt;T&gt;</code> স্মার্ট পয়েন্টারের জন্য <code>one_borrow</code> নামে একটি ভ্যারিয়েবল তৈরি করি। তারপর আমরা <code>two_borrow</code> ভ্যারিয়েবলে একইভাবে আরেকটি mutable borrow তৈরি করি। এটি একই স্কোপে দুটি mutable reference তৈরি করে, যা অনুমোদিত নয়। যখন আমরা আমাদের লাইব্রেরির জন্য টেস্ট চালাই, Listing 15-23-এর কোড কোনো এরর ছাড়াই কম্পাইল হবে, কিন্তু টেস্টটি ফেইল করবে:</p>
<pre><code class="language-console">$ cargo test
   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.91s
     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)

running 1 test
test tests::it_sends_an_over_75_percent_warning_message ... FAILED

failures:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----

thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at src/lib.rs:60:53:
already borrowed: BorrowMutError
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::it_sends_an_over_75_percent_warning_message

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

error: test failed, to rerun pass `--lib`
</code></pre>
<p>লক্ষ্য করুন যে কোডটি <code>already borrowed: BorrowMutError</code> বার্তা দিয়ে প্যানিক করেছে। এভাবেই <code>RefCell&lt;T&gt;</code> রানটাইমে borrowing নিয়মের লঙ্ঘন সামাল দেয়।</p>
<p>কম্পাইল টাইমের পরিবর্তে রানটাইমে borrowing এরর ধরার সিদ্ধান্ত নেওয়ার মানে হলো, যেমনটি আমরা এখানে করেছি, আপনি সম্ভবত ডেভেলপমেন্ট প্রক্রিয়ার পরে আপনার কোডের ভুল খুঁজে পাবেন: সম্ভবত আপনার কোড প্রোডাকশনে স্থাপন না হওয়া পর্যন্ত নয়। এছাড়াও, রানটাইমে borrow ট্র্যাক রাখার ফলে আপনার কোডে একটি ছোট রানটাইম পারফরম্যান্স পেনাল্টি হবে। তবে, <code>RefCell&lt;T&gt;</code> ব্যবহার করে এমন একটি মক অবজেক্ট লেখা সম্ভব যা নিজেকে পরিবর্তন করে তার দেখা বার্তাগুলোর ট্র্যাক রাখতে পারে যখন আপনি এটি এমন একটি কনটেক্সটে ব্যবহার করছেন যেখানে শুধুমাত্র immutable ভ্যালু অনুমোদিত। আপনি নিয়মিত reference-এর চেয়ে বেশি কার্যকারিতা পেতে <code>RefCell&lt;T&gt;</code> ব্যবহার করতে পারেন, এর ট্রেড-অফ থাকা সত্ত্বেও।</p>
<h3 id="rct-এবং-refcellt-একতরিত-করে-একাধিক-মালিকানাধীন-mutable-ডেটার-অনুমতি-দেওযা"><a class="header" href="#rct-এবং-refcellt-একতরিত-করে-একাধিক-মালিকানাধীন-mutable-ডেটার-অনুমতি-দেওযা"><code>Rc&lt;T&gt;</code> এবং <code>RefCell&lt;T&gt;</code> একত্রিত করে একাধিক মালিকানাধীন Mutable ডেটার অনুমতি দেওয়া</a></h3>
<p><code>RefCell&lt;T&gt;</code> ব্যবহার করার একটি সাধারণ উপায় হলো <code>Rc&lt;T&gt;</code>-এর সাথে সংমিশ্রণ। মনে করুন <code>Rc&lt;T&gt;</code> আপনাকে কিছু ডেটার একাধিক owner रखने দেয়, কিন্তু এটি শুধুমাত্র সেই ডেটার immutable অ্যাক্সেস দেয়। যদি আপনার কাছে একটি <code>Rc&lt;T&gt;</code> থাকে যা একটি <code>RefCell&lt;T&gt;</code> ধারণ করে, আপনি এমন একটি ভ্যালু পেতে পারেন যার একাধিক owner থাকতে পারে <em>এবং</em> যা আপনি পরিবর্তন করতে পারেন!</p>
<p>উদাহরণস্বরূপ, Listing 15-18-এর cons list উদাহরণটি মনে করুন যেখানে আমরা <code>Rc&lt;T&gt;</code> ব্যবহার করে একাধিক লিস্টকে অন্য একটি লিস্টের মালিকানা শেয়ার করার অনুমতি দিয়েছিলাম। যেহেতু <code>Rc&lt;T&gt;</code> শুধুমাত্র immutable ভ্যালু ধারণ করে, তাই আমরা একবার লিস্ট তৈরি করার পরে লিস্টের কোনো ভ্যালু পরিবর্তন করতে পারি না। চলুন লিস্টের ভ্যালুগুলো পরিবর্তন করার ক্ষমতার জন্য <code>RefCell&lt;T&gt;</code> যোগ করি। Listing 15-24 দেখাচ্ছে যে <code>Cons</code> সংজ্ঞায় একটি <code>RefCell&lt;T&gt;</code> ব্যবহার করে, আমরা সমস্ত লিস্টে সংরক্ষিত ভ্যালু পরিবর্তন করতে পারি।</p>
<Listing number="15-24" file-name="src/main.rs" caption="`Rc<RefCell<i32>>` ব্যবহার করে এমন একটি `List` তৈরি করা যা আমরা পরিবর্তন করতে পারি">
<pre><pre class="playground"><code class="language-rust edition2024">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!("a after = {a:?}");
    println!("b after = {b:?}");
    println!("c after = {c:?}");
}</code></pre></pre>
</Listing>
<p>আমরা <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code>-এর একটি ইনস্ট্যান্স তৈরি করে <code>value</code> নামের একটি ভেরিয়েবলে সংরক্ষণ করি যাতে আমরা পরে সরাসরি এটি অ্যাক্সেস করতে পারি। তারপর আমরা <code>a</code>-তে একটি <code>List</code> তৈরি করি যার <code>Cons</code> ভ্যারিয়েন্ট <code>value</code> ধারণ করে। আমাদের <code>value</code> ক্লোন করতে হবে যাতে <code>a</code> এবং <code>value</code> উভয়েই ভেতরের <code>5</code> ভ্যালুর মালিকানা পায়, <code>value</code> থেকে <code>a</code>-তে মালিকানা হস্তান্তর না করে বা <code>a</code>-কে <code>value</code> থেকে borrow করতে না হয়।</p>
<p>আমরা <code>a</code> লিস্টটিকে একটি <code>Rc&lt;T&gt;</code>-তে মুড়িয়ে দিই যাতে যখন আমরা <code>b</code> এবং <code>c</code> লিস্ট তৈরি করি, তারা উভয়েই <code>a</code>-কে নির্দেশ করতে পারে, যা আমরা Listing 15-18-এ করেছিলাম।</p>
<p><code>a</code>, <code>b</code>, এবং <code>c</code>-তে লিস্ট তৈরি করার পরে, আমরা <code>value</code>-এর ভ্যালুতে 10 যোগ করতে চাই। আমরা <code>value</code>-এর উপর <code>borrow_mut</code> কল করে এটি করি, যা Chapter 5-এর ["Where’s the <code>-&gt;</code> Operator?"][wheres-the---operator]-এ আলোচনা করা স্বয়ংক্রিয় dereferencing ফিচার ব্যবহার করে <code>Rc&lt;T&gt;</code>-কে ভেতরের <code>RefCell&lt;T&gt;</code> ভ্যালুতে dereference করে। <code>borrow_mut</code> মেথডটি একটি <code>RefMut&lt;T&gt;</code> স্মার্ট পয়েন্টার রিটার্ন করে, এবং আমরা এর উপর dereference অপারেটর ব্যবহার করে ভেতরের ভ্যালু পরিবর্তন করি।</p>
<p>যখন আমরা <code>a</code>, <code>b</code>, এবং <code>c</code> প্রিন্ট করি, আমরা দেখতে পাই যে তাদের সকলেরই <code>5</code>-এর পরিবর্তে পরিবর্তিত মান <code>15</code> রয়েছে:</p>
<pre><code class="language-console">$ cargo run
   Compiling cons-list v0.1.0 (file:///projects/cons-list)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.63s
     Running `target/debug/cons-list`
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>এই কৌশলটি বেশ চমৎকার! <code>RefCell&lt;T&gt;</code> ব্যবহার করে, আমাদের কাছে একটি বাহ্যিকভাবে immutable <code>List</code> ভ্যালু আছে। কিন্তু আমরা <code>RefCell&lt;T&gt;</code>-এর মেথডগুলো ব্যবহার করতে পারি যা তার ইন্টেরিয়র মিউটেবিলিটিতে অ্যাক্সেস দেয় যাতে প্রয়োজনে আমরা আমাদের ডেটা পরিবর্তন করতে পারি। রানটাইমে borrowing নিয়মের চেক আমাদের ডেটা রেস থেকে রক্ষা করে, এবং আমাদের ডেটা স্ট্রাকচারে এই নমনীয়তার জন্য কখনও কখনও কিছুটা গতি বিসর্জন দেওয়া সার্থক। মনে রাখবেন <code>RefCell&lt;T&gt;</code> মাল্টি-থ্রেডেড কোডের জন্য কাজ করে না! <code>Mutex&lt;T&gt;</code> হলো <code>RefCell&lt;T&gt;</code>-এর থ্রেড-সেফ সংস্করণ, এবং আমরা Chapter 16-এ <code>Mutex&lt;T&gt;</code> নিয়ে আলোচনা করব।</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch15-04-rc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch15-04-rc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch15-06-reference-cycles.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
