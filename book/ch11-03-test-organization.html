<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>টেস্ট অর্গানাইজেশন - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="টেসট-অরগানাইজেশন"><a class="header" href="#টেসট-অরগানাইজেশন">টেস্ট অর্গানাইজেশন</a></h2>
<p>এই অধ্যায়ের শুরুতে যেমনটি উল্লেখ করা হয়েছে, টেস্টিং একটি জটিল বিষয় এবং বিভিন্ন মানুষ বিভিন্ন পরিভাষা ও সংগঠন ব্যবহার করে। Rust কমিউনিটি টেস্টগুলোকে প্রধানত দুটি ভাগে ভাগ করে: ইউনিট টেস্ট (unit tests) এবং ইন্টিগ্রেশন টেস্ট (integration tests)। <em>ইউনিট টেস্ট</em> ছোট এবং বেশি ফোকাসড হয়, যা একবারে একটি মডিউলকে আলাদাভাবে পরীক্ষা করে এবং প্রাইভেট ইন্টারফেসও (private interfaces) পরীক্ষা করতে পারে। <em>ইন্টিগ্রেশন টেস্ট</em> আপনার লাইব্রেরির সম্পূর্ণ বাইরে থাকে এবং আপনার কোডকে অন্য যেকোনো এক্সটার্নাল কোডের মতোই ব্যবহার করে, শুধুমাত্র পাবলিক ইন্টারফেস ব্যবহার করে এবং প্রতিটি টেস্টে একাধিক মডিউল পরীক্ষা করতে পারে।</p>
<p>আপনার লাইব্রেরির অংশগুলো আলাদাভাবে এবং একসঙ্গে প্রত্যাশা অনুযায়ী কাজ করছে কিনা তা নিশ্চিত করার জন্য উভয় প্রকারের টেস্ট লেখাই গুরুত্বপূর্ণ।</p>
<h3 id="ইউনিট-টেসট"><a class="header" href="#ইউনিট-টেসট">ইউনিট টেস্ট</a></h3>
<p>ইউনিট টেস্টের উদ্দেশ্য হলো কোডের প্রতিটি ইউনিটকে বাকি কোড থেকে বিচ্ছিন্নভাবে পরীক্ষা করা, যাতে কোডের কোথায় প্রত্যাশা অনুযায়ী কাজ করছে এবং কোথায় করছে না তা দ্রুত চিহ্নিত করা যায়। আপনি ইউনিট টেস্টগুলোকে <em>src</em> ডিরেক্টরিতে প্রতিটি ফাইলের মধ্যে রাখবেন, যে কোডটি তারা পরীক্ষা করছে তার সাথে। প্রচলিত নিয়ম হলো, টেস্ট ফাংশনগুলো রাখার জন্য প্রতিটি ফাইলে <code>tests</code> নামে একটি মডিউল তৈরি করা এবং মডিউলটিকে <code>cfg(test)</code> দিয়ে অ্যানোটেট করা।</p>
<h4 id="tests-মডিউল-এবং-cfgtest"><a class="header" href="#tests-মডিউল-এবং-cfgtest">tests মডিউল এবং <code>#[cfg(test)]</code></a></h4>
<p><code>tests</code> মডিউলের উপর <code>#[cfg(test)]</code> অ্যানোটেশনটি Rust-কে বলে যে শুধুমাত্র <code>cargo test</code> চালানোর সময় টেস্ট কোড কম্পাইল এবং রান করতে হবে, <code>cargo build</code> চালানোর সময় নয়। এটি কম্পাইলের সময় বাঁচায় যখন আপনি কেবল লাইব্রেরি তৈরি করতে চান এবং ফলে তৈরি হওয়া কম্পাইল্ড আর্টিফ্যাক্টে জায়গা বাঁচায় কারণ টেস্টগুলো অন্তর্ভুক্ত থাকে না। আপনি দেখবেন যে ইন্টিগ্রেশন টেস্টগুলো একটি ভিন্ন ডিরেক্টরিতে যাওয়ায় তাদের <code>#[cfg(test)]</code> অ্যানোটেশনের প্রয়োজন হয় না। তবে, যেহেতু ইউনিট টেস্টগুলো কোডের সাথে একই ফাইলে থাকে, তাই কম্পাইল্ড ফলাফলে সেগুলো অন্তর্ভুক্ত করা উচিত নয় তা নির্দিষ্ট করতে আপনি <code>#[cfg(test)]</code> ব্যবহার করবেন।</p>
<p>স্মরণ করুন, এই অধ্যায়ের প্রথম বিভাগে যখন আমরা নতুন <code>adder</code> প্রজেক্ট তৈরি করেছিলাম, Cargo আমাদের জন্য এই কোডটি তৈরি করেছিল:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust noplayground">pub fn add(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
<p>স্বয়ংক্রিয়ভাবে জেনারেট হওয়া <code>tests</code> মডিউলে, <code>cfg</code> অ্যাট্রিবিউটটি <em>configuration</em> (কনফিগারেশন) বোঝায় এবং Rust-কে বলে যে নিম্নলিখিত আইটেমটি শুধুমাত্র একটি নির্দিষ্ট কনফিগারেশন অপশন দেওয়া থাকলেই অন্তর্ভুক্ত করা উচিত। এক্ষেত্রে, কনফিগারেশন অপশনটি হলো <code>test</code>, যা Rust দ্বারা টেস্ট কম্পাইল এবং চালানোর জন্য সরবরাহ করা হয়। <code>cfg</code> অ্যাট্রিবিউট ব্যবহার করে, Cargo আমাদের টেস্ট কোড শুধুমাত্র তখনই কম্পাইল করে যখন আমরা <code>cargo test</code> দিয়ে সক্রিয়ভাবে টেস্ট চালাই। এর মধ্যে <code>#[test]</code> দিয়ে অ্যানোটেট করা ফাংশনগুলো ছাড়াও এই মডিউলের মধ্যে থাকা যেকোনো সাহায্যকারী ফাংশন অন্তর্ভুক্ত থাকে।</p>
<h4 id="পরাইভেট-ফাংশন-টেসট-করা"><a class="header" href="#পরাইভেট-ফাংশন-টেসট-করা">প্রাইভেট ফাংশন টেস্ট করা</a></h4>
<p>টেস্টিং কমিউনিটিতে প্রাইভেট ফাংশন সরাসরি পরীক্ষা করা উচিত কিনা তা নিয়ে বিতর্ক রয়েছে, এবং অন্যান্য ভাষা প্রাইভেট ফাংশন পরীক্ষা করা কঠিন বা অসম্ভব করে তোলে। আপনি যে টেস্টিং মতাদর্শই অনুসরণ করুন না কেন, Rust-এর প্রাইভেসি নিয়ম আপনাকে প্রাইভেট ফাংশন পরীক্ষা করার অনুমতি দেয়। তালিকা ১১-১২-এর কোডটি বিবেচনা করুন যেখানে <code>internal_adder</code> নামে একটি প্রাইভেট ফাংশন রয়েছে।</p>
<Listing number="11-12" file-name="src/lib.rs" caption="একটি প্রাইভেট ফাংশন টেস্ট করা">
<pre><code class="language-rust noplayground">pub fn add_two(a: u64) -&gt; u64 {
    internal_adder(a, 2)
}

fn internal_adder(left: u64, right: u64) -&gt; u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        let result = internal_adder(2, 2);
        assert_eq!(result, 4);
    }
}</code></pre>
</Listing>
<p>লক্ষ্য করুন যে <code>internal_adder</code> ফাংশনটি <code>pub</code> হিসাবে চিহ্নিত নয়। টেস্টগুলো কেবল Rust কোড, এবং <code>tests</code> মডিউলটি কেবল আরেকটি মডিউল। যেমনটি আমরা ["Paths for Referring to an Item in the Module Tree"][paths]<!-- ignore -->-তে আলোচনা করেছি, চাইল্ড মডিউলের আইটেমগুলো তাদের পূর্বপুরুষ মডিউলের আইটেমগুলো ব্যবহার করতে পারে। এই টেস্টে, আমরা <code>use super::*</code> দিয়ে <code>tests</code> মডিউলের প্যারেন্টের সমস্ত আইটেমকে স্কোপে নিয়ে আসি এবং তারপর টেস্টটি <code>internal_adder</code> কল করতে পারে। আপনি যদি মনে করেন যে প্রাইভেট ফাংশন পরীক্ষা করা উচিত নয়, তবে Rust-এ এমন কিছুই নেই যা আপনাকে তা করতে বাধ্য করবে।</p>
<h3 id="ইনটিগরেশন-টেসট"><a class="header" href="#ইনটিগরেশন-টেসট">ইন্টিগ্রেশন টেস্ট</a></h3>
<p>Rust-এ, ইন্টিগ্রেশন টেস্টগুলো আপনার লাইব্রেরির সম্পূর্ণ বাইরে থাকে। তারা আপনার লাইব্রেরিটি অন্য যেকোনো কোডের মতোই ব্যবহার করে, যার মানে তারা কেবল সেই ফাংশনগুলোকেই কল করতে পারে যা আপনার লাইব্রেরির পাবলিক API-এর অংশ। তাদের উদ্দেশ্য হলো আপনার লাইব্রেরির অনেকগুলো অংশ একসাথে সঠিকভাবে কাজ করছে কিনা তা পরীক্ষা করা। যে কোডের ইউনিটগুলো একা একা সঠিকভাবে কাজ করে, সেগুলো ইন্টিগ্রেট করার সময় সমস্যা হতে পারে, তাই ইন্টিগ্রেটেড কোডের টেস্ট কভারেজও গুরুত্বপূর্ণ। ইন্টিগ্রেশন টেস্ট তৈরি করতে, আপনাকে প্রথমে একটি <em>tests</em> ডিরেক্টরি তৈরি করতে হবে।</p>
<h4 id="tests-ডিরেকটরি"><a class="header" href="#tests-ডিরেকটরি">tests ডিরেক্টরি</a></h4>
<p>আমরা আমাদের প্রজেক্ট ডিরেক্টরির টপ লেভেলে, <em>src</em> এর পাশে একটি <em>tests</em> ডিরেক্টরি তৈরি করি। Cargo জানে যে এই ডিরেক্টরিতে ইন্টিগ্রেশন টেস্ট ফাইল খুঁজতে হবে। আমরা তখন যত খুশি টেস্ট ফাইল তৈরি করতে পারি, এবং Cargo প্রতিটি ফাইলকে একটি স্বতন্ত্র ক্রেট (crate) হিসাবে কম্পাইল করবে।</p>
<p>চলুন একটি ইন্টিগ্রেশন টেস্ট তৈরি করি। তালিকা ১১-১২-এর কোডটি এখনও <em>src/lib.rs</em> ফাইলে থাকা অবস্থায়, একটি <em>tests</em> ডিরেক্টরি তৈরি করুন এবং <em>tests/integration_test.rs</em> নামে একটি নতুন ফাইল তৈরি করুন। আপনার ডিরেক্টরি কাঠামোটি এমন হওয়া উচিত:</p>
<pre><code class="language-text">adder
├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    └── integration_test.rs
</code></pre>
<p>তালিকা ১১-১৩-এর কোডটি <em>tests/integration_test.rs</em> ফাইলে প্রবেশ করান।</p>
<Listing number="11-13" file-name="tests/integration_test.rs" caption="`adder` ক্রেটের একটি ফাংশনের ইন্টিগ্রেশন টেস্ট">
<pre><code class="language-rust ignore">use adder::add_two;

#[test]
fn it_adds_two() {
    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
</Listing>
<p><em>tests</em> ডিরেক্টরির প্রতিটি ফাইল একটি পৃথক ক্রেট, তাই আমাদের প্রতিটি টেস্ট ক্রেটের স্কোপে আমাদের লাইব্রেরি আনতে হবে। এই কারণে আমরা কোডের শীর্ষে <code>use adder;</code> যোগ করি, যা ইউনিট টেস্টে আমাদের প্রয়োজন হয়নি।</p>
<p>আমাদের <em>tests/integration_test.rs</em>-এর কোনো কোডকে <code>#[cfg(test)]</code> দিয়ে অ্যানোটেট করার প্রয়োজন নেই। Cargo <em>tests</em> ডিরেক্টরিকে বিশেষভাবে বিবেচনা করে এবং এই ডিরেক্টরির ফাইলগুলো শুধুমাত্র <code>cargo test</code> চালানোর সময় কম্পাইল করে। এখন <code>cargo test</code> চালান:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.31s
     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>আউটপুটের তিনটি অংশে ইউনিট টেস্ট, ইন্টিগ্রেশন টেস্ট এবং ডক টেস্ট অন্তর্ভুক্ত রয়েছে। উল্লেখ্য, যদি কোনো একটি বিভাগের কোনো টেস্ট ফেইল করে, তাহলে পরবর্তী বিভাগগুলো চালানো হবে না। উদাহরণস্বরূপ, যদি একটি ইউনিট টেস্ট ফেইল করে, তাহলে ইন্টিগ্রেশন এবং ডক টেস্টের জন্য কোনো আউটপুট থাকবে না কারণ সেই টেস্টগুলো শুধুমাত্র তখনই চালানো হবে যদি সমস্ত ইউনিট টেস্ট পাস করে।</p>
<p>ইউনিট টেস্টের জন্য প্রথম বিভাগটি আমরা যা দেখে আসছি তার মতোই: প্রতিটি ইউনিট টেস্টের জন্য একটি লাইন (একটি <code>internal</code> নামের যা আমরা তালিকা ১১-১২-এ যোগ করেছি) এবং তারপর ইউনিট টেস্টের জন্য একটি সারাংশ লাইন।</p>
<p>ইন্টিগ্রেশন টেস্ট বিভাগটি <code>Running tests/integration_test.rs</code> লাইন দিয়ে শুরু হয়। এরপর, সেই ইন্টিগ্রেশন টেস্টের প্রতিটি টেস্ট ফাংশনের জন্য একটি লাইন এবং <code>Doc-tests adder</code> বিভাগ শুরু হওয়ার ঠিক আগে ইন্টিগ্রেশন টেস্টের ফলাফলের জন্য একটি সারাংশ লাইন রয়েছে।</p>
<p>প্রতিটি ইন্টিগ্রেশন টেস্ট ফাইলের নিজস্ব বিভাগ রয়েছে, তাই আমরা যদি <em>tests</em> ডিরেক্টরিতে আরও ফাইল যোগ করি, তাহলে আরও ইন্টিগ্রেশন টেস্ট বিভাগ থাকবে।</p>
<p>আমরা এখনও <code>cargo test</code>-এর আর্গুমেন্ট হিসাবে টেস্ট ফাংশনের নাম উল্লেখ করে একটি নির্দিষ্ট ইন্টিগ্রেশন টেস্ট ফাংশন চালাতে পারি। একটি নির্দিষ্ট ইন্টিগ্রেশন টেস্ট ফাইলের সমস্ত টেস্ট চালানোর জন্য, <code>cargo test</code>-এর <code>--test</code> আর্গুমেন্ট এবং তারপরে ফাইলের নাম ব্যবহার করুন:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.64s
     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>এই কমান্ডটি শুধুমাত্র <em>tests/integration_test.rs</em> ফাইলের টেস্টগুলো চালায়।</p>
<h4 id="ইনটিগরেশন-টেসটে-সাবমডিউল"><a class="header" href="#ইনটিগরেশন-টেসটে-সাবমডিউল">ইন্টিগ্রেশন টেস্টে সাবমডিউল</a></h4>
<p>আপনি যখন আরও ইন্টিগ্রেশন টেস্ট যোগ করবেন, তখন সেগুলোকে সংগঠিত করতে সাহায্য করার জন্য আপনি <em>tests</em> ডিরেক্টরিতে আরও ফাইল তৈরি করতে চাইতে পারেন; উদাহরণস্বরূপ, আপনি যে কার্যকারিতা পরীক্ষা করছেন তার উপর ভিত্তি করে টেস্ট ফাংশনগুলোকে গ্রুপ করতে পারেন। আগে যেমন উল্লেখ করা হয়েছে, <em>tests</em> ডিরেক্টরির প্রতিটি ফাইল তার নিজস্ব পৃথক ক্রেট হিসাবে কম্পাইল করা হয়, যা পৃথক স্কোপ তৈরি করার জন্য দরকারী যাতে শেষ ব্যবহারকারীরা আপনার ক্রেট কীভাবে ব্যবহার করবে তার আরও কাছাকাছি অনুকরণ করা যায়। যাইহোক, এর মানে হল <em>tests</em> ডিরেক্টরির ফাইলগুলো <em>src</em>-এর ফাইলগুলোর মতো একই আচরণ শেয়ার করে না, যেমনটি আপনি অধ্যায় ৭-এ শিখেছিলেন কিভাবে কোডকে মডিউল এবং ফাইলে বিভক্ত করতে হয়।</p>
<p><em>tests</em> ডিরেক্টরির ফাইলগুলোর ভিন্ন আচরণ সবচেয়ে বেশি লক্ষণীয় হয় যখন আপনার কাছে একাধিক ইন্টিগ্রেশন টেস্ট ফাইলে ব্যবহার করার জন্য একসেট সাহায্যকারী ফাংশন থাকে এবং আপনি সেগুলোকে একটি সাধারণ মডিউলে বের করে আনার জন্য অধ্যায় ৭-এর ["Separating Modules into Different Files"][separating-modules-into-files]<!-- ignore --> বিভাগের ধাপগুলো অনুসরণ করার চেষ্টা করেন। উদাহরণস্বরূপ, যদি আমরা <em>tests/common.rs</em> তৈরি করি এবং এতে <code>setup</code> নামে একটি ফাংশন রাখি, আমরা <code>setup</code>-এ কিছু কোড যোগ করতে পারি যা আমরা একাধিক টেস্ট ফাইলের একাধিক টেস্ট ফাংশন থেকে কল করতে চাই:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><code class="language-rust noplayground">pub fn setup() {
    // setup code specific to your library's tests would go here
}</code></pre>
<p>যখন আমরা আবার টেস্টগুলো চালাই, আমরা টেস্ট আউটপুটে <em>common.rs</em> ফাইলের জন্য একটি নতুন বিভাগ দেখতে পাব, যদিও এই ফাইলে কোনো টেস্ট ফাংশন নেই এবং আমরা <code>setup</code> ফাংশনটি কোথাও থেকে কলও করিনি:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.89s
     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

</code></pre>
<p>টেস্ট ফলাফলে <code>common</code> এর জন্য <code>running 0 tests</code> প্রদর্শিত হওয়াটা আমরা চাইনি। আমরা কেবল অন্য ইন্টিগ্রেশন টেস্ট ফাইলগুলোর সাথে কিছু কোড শেয়ার করতে চেয়েছিলাম। টেস্ট আউটপুটে <code>common</code> আসা এড়াতে, <em>tests/common.rs</em> তৈরি করার পরিবর্তে, আমরা <em>tests/common/mod.rs</em> তৈরি করব। প্রজেক্ট ডিরেক্টরি এখন এমন দেখাচ্ছে:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── src
│   └── lib.rs
└── tests
    ├── common
    │   └── mod.rs
    └── integration_test.rs
</code></pre>
<p>এটি পুরনো নামকরণের নিয়ম যা Rust বোঝে এবং যা আমরা অধ্যায় ৭-এর ["Alternate File Paths"][alt-paths]<!-- ignore -->-এ উল্লেখ করেছি। ফাইলটিকে এইভাবে নামকরণ করা Rust-কে বলে যে <code>common</code> মডিউলটিকে একটি ইন্টিগ্রেশন টেস্ট ফাইল হিসাবে বিবেচনা না করতে। যখন আমরা <code>setup</code> ফাংশনের কোডটি <em>tests/common/mod.rs</em>-এ নিয়ে যাই এবং <em>tests/common.rs</em> ফাইলটি মুছে ফেলি, তখন টেস্ট আউটপুটের বিভাগটি আর প্রদর্শিত হবে না। <em>tests</em> ডিরেক্টরির সাবডিরেক্টরির ফাইলগুলো পৃথক ক্রেট হিসাবে কম্পাইল হয় না বা টেস্ট আউটপুটে তাদের বিভাগ থাকে না।</p>
<p>আমরা <em>tests/common/mod.rs</em> তৈরি করার পরে, আমরা এটিকে যেকোনো ইন্টিগ্রেশন টেস্ট ফাইল থেকে একটি মডিউল হিসাবে ব্যবহার করতে পারি। এখানে <em>tests/integration_test.rs</em>-এর <code>it_adds_two</code> টেস্ট থেকে <code>setup</code> ফাংশন কল করার একটি উদাহরণ দেওয়া হলো:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder::add_two;

mod common;

#[test]
fn it_adds_two() {
    common::setup();

    let result = add_two(2);
    assert_eq!(result, 4);
}</code></pre>
<p>লক্ষ্য করুন যে <code>mod common;</code> ডিক্লারেশনটি আমরা তালিকা ৭-২১-এ দেখানো মডিউল ডিক্লারেশনের মতোই। তারপর, টেস্ট ফাংশনে, আমরা <code>common::setup()</code> ফাংশন কল করতে পারি।</p>
<h4 id="বাইনারি-করেটের-জনয-ইনটিগরেশন-টেসট"><a class="header" href="#বাইনারি-করেটের-জনয-ইনটিগরেশন-টেসট">বাইনারি ক্রেটের জন্য ইন্টিগ্রেশন টেস্ট</a></h4>
<p>যদি আমাদের প্রজেক্টটি একটি বাইনারি ক্রেট হয় যাতে শুধুমাত্র একটি <em>src/main.rs</em> ফাইল থাকে এবং কোনো <em>src/lib.rs</em> ফাইল না থাকে, আমরা <em>tests</em> ডিরেক্টরিতে ইন্টিগ্রেশন টেস্ট তৈরি করতে এবং <em>src/main.rs</em> ফাইলে সংজ্ঞায়িত ফাংশনগুলোকে একটি <code>use</code> স্টেটমেন্ট দিয়ে স্কোপে আনতে পারি না। শুধুমাত্র লাইব্রেরি ক্রেটগুলো ফাংশন এক্সপোজ করে যা অন্যান্য ক্রেট ব্যবহার করতে পারে; বাইনারি ক্রেটগুলো নিজে থেকে চালানোর জন্য তৈরি।</p>
<p>এটি একটি কারণ যে কারণে Rust প্রজেক্ট যেগুলো একটি বাইনারি সরবরাহ করে, সেগুলোতে একটি সহজবোধ্য <em>src/main.rs</em> ফাইল থাকে যা <em>src/lib.rs</em> ফাইলে থাকা লজিককে কল করে। সেই কাঠামো ব্যবহার করে, ইন্টিগ্রেশন টেস্টগুলো <code>use</code> দিয়ে লাইব্রেরি ক্রেট পরীক্ষা করতে পারে যাতে গুরুত্বপূর্ণ কার্যকারিতা উপলব্ধ করা যায়। যদি গুরুত্বপূর্ণ কার্যকারিতা কাজ করে, তাহলে <em>src/main.rs</em> ফাইলের অল্প পরিমাণ কোডও কাজ করবে, এবং সেই অল্প পরিমাণ কোড পরীক্ষা করার প্রয়োজন নেই।</p>
<h2 id="সারসংকষেপ"><a class="header" href="#সারসংকষেপ">সারসংক্ষেপ</a></h2>
<p>Rust-এর টেস্টিং ফিচারগুলো কোড কীভাবে কাজ করা উচিত তা নির্দিষ্ট করার একটি উপায় সরবরাহ করে যাতে আপনি পরিবর্তন করার পরেও এটি আপনার প্রত্যাশা অনুযায়ী কাজ করে তা নিশ্চিত করা যায়। ইউনিট টেস্টগুলো একটি লাইব্রেরির বিভিন্ন অংশকে আলাদাভাবে পরীক্ষা করে এবং প্রাইভেট ইমপ্লিমেন্টেশন ডিটেইলস পরীক্ষা করতে পারে। ইন্টিগ্রেশন টেস্টগুলো পরীক্ষা করে যে লাইব্রেরির অনেকগুলো অংশ একসাথে সঠিকভাবে কাজ করছে কিনা, এবং তারা লাইব্রেরির পাবলিক API ব্যবহার করে কোডটি সেভাবেই পরীক্ষা করে যেভাবে এক্সটার্নাল কোড এটি ব্যবহার করবে। যদিও Rust-এর টাইপ সিস্টেম এবং ওনারশিপ নিয়ম কিছু ধরণের বাগ প্রতিরোধ করতে সাহায্য করে, আপনার কোড কীভাবে আচরণ করবে বলে আশা করা হচ্ছে সে সম্পর্কিত লজিক বাগ কমাতে টেস্টগুলো এখনও গুরুত্বপূর্ণ।</p>
<p>চলুন এই অধ্যায়ে এবং পূর্ববর্তী অধ্যায়গুলোতে শেখা জ্ঞান একত্রিত করে একটি প্রজেক্টে কাজ করা যাক</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-02-running-tests.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch12-00-an-io-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-02-running-tests.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch12-00-an-io-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
