<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>অ্যাসিঙ্ক দিয়ে কনকারেন্সি প্রয়োগ - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="async-দিয়ে-কনকারেনসি-পরয়োগ"><a class="header" href="#async-দিয়ে-কনকারেনসি-পরয়োগ">Async দিয়ে কনকারেন্সি প্রয়োগ</a></h2>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="concurrency-with-async"></a></p>
<p>এই বিভাগে, আমরা চ্যাপ্টার ১৬-তে থ্রেড (thread) দিয়ে সমাধান করা কিছু কনকারেন্সি চ্যালেঞ্জের জন্য async প্রয়োগ করব। যেহেতু আমরা সেখানে অনেক মূল ধারণা নিয়ে ইতিমধ্যে আলোচনা করেছি, তাই এই বিভাগে আমরা থ্রেড এবং future-এর মধ্যে কী কী পার্থক্য রয়েছে তার উপর মনোযোগ দেব।</p>
<p>অনেক ক্ষেত্রে, async ব্যবহার করে কনকারেন্সির সাথে কাজ করার জন্য API-গুলো থ্রেড ব্যবহারের জন্য থাকা API-গুলোর মতোই। অন্য ক্ষেত্রে, সেগুলো বেশ ভিন্ন হয়ে যায়। এমনকি যখন API-গুলো থ্রেড এবং async-এর মধ্যে দেখতে একই রকম <em>মনে হয়</em>, তখনও তাদের আচরণ প্রায়শই ভিন্ন হয়—এবং তাদের পারফরম্যান্স বৈশিষ্ট্যগুলি প্রায় সবসময়ই ভিন্ন থাকে।</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="counting"></a></p>
<h3 id="spawn_task-দিয়ে-নতুন-টাসক-তৈরি-করা"><a class="header" href="#spawn_task-দিয়ে-নতুন-টাসক-তৈরি-করা"><code>spawn_task</code> দিয়ে নতুন টাস্ক তৈরি করা</a></h3>
<p><a href="ch16-01-threads.html#creating-a-new-thread-with-spawn">Creating a New Thread with Spawn</a><!-- ignore -->-এ আমরা প্রথম যে অপারেশনটি নিয়ে কাজ করেছিলাম তা হলো দুটি পৃথক থ্রেডে গণনা করা। আসুন async ব্যবহার করে একই কাজ করি। <code>trpl</code> crate একটি <code>spawn_task</code> ফাংশন সরবরাহ করে যা দেখতে <code>thread::spawn</code> API-এর মতোই, এবং একটি <code>sleep</code> ফাংশন যা <code>thread::sleep</code> API-এর একটি async সংস্করণ। আমরা এই দুটিকে একসাথে ব্যবহার করে গণনার উদাহরণটি বাস্তবায়ন করতে পারি, যেমনটি লিস্টিং ১৭-৬-এ দেখানো হয়েছে।</p>
<Listing number="17-6" caption="মূল টাস্ক যখন অন্য কিছু প্রিন্ট করছে তখন একটি জিনিস প্রিন্ট করার জন্য একটি নতুন টাস্ক তৈরি করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::time::Duration;

fn main() {
    trpl::run(async {
        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }
    });
}</code></pre></pre>
</Listing>
<p>আমাদের সূচনা বিন্দু হিসাবে, আমরা আমাদের <code>main</code> ফাংশনটি <code>trpl::run</code> দিয়ে সেট আপ করি যাতে আমাদের টপ-লেভেল ফাংশনটি async হতে পারে।</p>
<blockquote>
<p>দ্রষ্টব্য: এই অধ্যায়ের এই পয়েন্ট থেকে, প্রতিটি উদাহরণে <code>main</code>-এ <code>trpl::run</code> সহ এই একই র‍্যাপিং কোড অন্তর্ভুক্ত থাকবে, তাই আমরা প্রায়শই এটি এড়িয়ে যাব যেমনটি আমরা <code>main</code>-এর ক্ষেত্রে করি। আপনার কোডে এটি অন্তর্ভুক্ত করতে ভুলবেন না!</p>
</blockquote>
<p>তারপর আমরা সেই ব্লকের মধ্যে দুটি লুপ লিখি, প্রতিটিতে একটি <code>trpl::sleep</code> কল রয়েছে, যা পরবর্তী বার্তা পাঠানোর আগে আধা সেকেন্ড (৫০০ মিলিসেকেন্ড) অপেক্ষা করে। আমরা একটি লুপ <code>trpl::spawn_task</code>-এর বডিতে এবং অন্যটি একটি টপ-লেভেল <code>for</code> লুপে রাখি। আমরা <code>sleep</code> কলগুলোর পরে একটি <code>await</code> যোগ করি।</p>
<p>এই কোডটি থ্রেড-ভিত্তিক ইমপ্লিমেন্টেশনের মতোই আচরণ করে—যার মধ্যে এই ঘটনাটিও অন্তর্ভুক্ত যে আপনি যখন এটি চালাবেন তখন আপনার নিজের টার্মিনালে বার্তাগুলি একটি ভিন্ন ক্রমে উপস্থিত হতে পারে:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!```

এই সংস্করণটি প্রধান async ব্লকের বডিতে `for` লুপ শেষ হওয়ার সাথে সাথেই থেমে যায়, কারণ `spawn_task` দ্বারা তৈরি করা টাস্কটি `main` ফাংশন শেষ হলে বন্ধ হয়ে যায়। আপনি যদি এটিকে টাস্কের সমাপ্তি পর্যন্ত চালাতে চান, তবে প্রথম টাস্কটি সম্পূর্ণ হওয়ার জন্য অপেক্ষা করতে আপনাকে একটি জয়েন হ্যান্ডেল ব্যবহার করতে হবে। থ্রেডের সাথে, আমরা থ্রেডটি চলা শেষ না হওয়া পর্যন্ত "ব্লক" করার জন্য `join` মেথড ব্যবহার করেছি। লিস্টিং ১৭-৭-এ, আমরা একই কাজ করার জন্য `await` ব্যবহার করতে পারি, কারণ টাস্ক হ্যান্ডেল নিজেই একটি future। এর `Output` টাইপ একটি `Result`, তাই আমরা এটিকে await করার পরে `unwrap` করি।

&lt;Listing number="17-7" caption="একটি টাস্ককে সমাপ্তি পর্যন্ত চালানোর জন্য একটি জয়েন হ্যান্ডেলের সাথে `await` ব্যবহার করা" file-name="src/main.rs"&gt;

```rust
# extern crate trpl; // required for mdbook test
# 
# use std::time::Duration;
# 
# fn main() {
#     trpl::run(async {
        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(500)).await;
        }

        handle.await.unwrap();
#     });
# }
</code></pre>
</Listing>
<p>এই আপডেট করা সংস্করণটি <em>উভয়</em> লুপ শেষ না হওয়া পর্যন্ত চলে।</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>এখন পর্যন্ত, মনে হচ্ছে async এবং থ্রেড আমাদের একই মৌলিক ফলাফল দেয়, শুধু ভিন্ন সিনট্যাক্স দিয়ে: জয়েন হ্যান্ডেলে <code>join</code> কল করার পরিবর্তে <code>await</code> ব্যবহার করা, এবং <code>sleep</code> কলগুলিকে await করা।</p>
<p>বড় পার্থক্য হলো এই কাজটি করার জন্য আমাদের অন্য একটি অপারেটিং সিস্টেম থ্রেড তৈরি করার প্রয়োজন হয়নি। আসলে, আমাদের এখানে একটি টাস্কও তৈরি করার প্রয়োজন নেই। যেহেতু async ব্লকগুলি নামহীন future-এ কম্পাইল হয়, আমরা প্রতিটি লুপকে একটি async ব্লকে রাখতে পারি এবং রানটাইমকে <code>trpl::join</code> ফাংশন ব্যবহার করে সেগুলিকে সম্পূর্ণ করতে দিতে পারি।</p>
<p><a href="ch16-01-threads.html#waiting-for-all-threads-to-finish-using-join-handles">Waiting for All Threads to Finishing Using <code>join</code> Handles</a><!-- ignore --> বিভাগে, আমরা দেখিয়েছিলাম কীভাবে <code>std::thread::spawn</code> কল করার সময় রিটার্ন করা <code>JoinHandle</code> টাইপের উপর <code>join</code> মেথড ব্যবহার করতে হয়। <code>trpl::join</code> ফাংশনটি একই রকম, কিন্তু future-এর জন্য। যখন আপনি এটিকে দুটি future দেন, তখন এটি একটি নতুন future তৈরি করে যার আউটপুট হলো একটি টাপল (tuple) যা আপনার পাস করা প্রতিটি future-এর আউটপুট ধারণ করে যখন তারা <em>উভয়ই</em> সম্পূর্ণ হয়। সুতরাং, লিস্টিং ১৭-৮-এ, আমরা <code>fut1</code> এবং <code>fut2</code> উভয়ই শেষ হওয়ার জন্য অপেক্ষা করতে <code>trpl::join</code> ব্যবহার করি। আমরা <code>fut1</code> এবং <code>fut2</code>-কে await করি <em>না</em>, বরং <code>trpl::join</code> দ্বারা উৎপাদিত নতুন future-কে await করি। আমরা আউটপুট উপেক্ষা করি, কারণ এটি কেবল দুটি ইউনিট মান ধারণকারী একটি টাপল।</p>
<Listing number="17-8" caption="দুটি নামহীন future-কে await করার জন্য `trpl::join` ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>যখন আমরা এটি চালাই, আমরা দেখি উভয় future-ই সম্পূর্ণভাবে চলে:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>এখন, আপনি প্রতিবার ঠিক একই ক্রম দেখতে পাবেন, যা আমরা থ্রেডের সাথে যা দেখেছিলাম তার থেকে খুব ভিন্ন। এর কারণ হলো <code>trpl::join</code> ফাংশনটি <em>ফেয়ার</em> (fair), যার অর্থ এটি প্রতিটি future-কে সমানভাবে পরীক্ষা করে, তাদের মধ্যে পর্যায়ক্রমে পরিবর্তন করে, এবং অন্যটি প্রস্তুত থাকলে একটিকে এগিয়ে যেতে দেয় না। থ্রেডের সাথে, অপারেটিং সিস্টেম সিদ্ধান্ত নেয় কোন থ্রেডটি পরীক্ষা করতে হবে এবং এটিকে কতক্ষণ চালাতে দিতে হবে। async রাস্টের সাথে, রানটাইম সিদ্ধান্ত নেয় কোন টাস্কটি পরীক্ষা করতে হবে। (বাস্তবে, বিশদ বিবরণগুলি জটিল হয়ে যায় কারণ একটি async রানটাইম কনকারেন্সি পরিচালনার অংশ হিসাবে পর্দার আড়ালে অপারেটিং সিস্টেম থ্রেড ব্যবহার করতে পারে, তাই ফেয়ারনেস নিশ্চিত করা একটি রানটাইমের জন্য আরও বেশি কাজ হতে পারে—তবে এটি এখনও সম্ভব!) রানটাইমগুলিকে যেকোনো প্রদত্ত অপারেশনের জন্য ফেয়ারনেসের গ্যারান্টি দিতে হয় না, এবং তারা প্রায়শই আপনাকে ফেয়ারনেস চান কি না তা বেছে নিতে বিভিন্ন API অফার করে।</p>
<p>ফিউচার await করার এই ভিন্নতাগুলো চেষ্টা করে দেখুন এবং দেখুন তারা কী করে:</p>
<ul>
<li>যেকোনো একটি বা উভয় লুপের চারপাশ থেকে async ব্লকটি সরিয়ে ফেলুন।</li>
<li>প্রতিটি async ব্লক সংজ্ঞায়িত করার সাথে সাথেই await করুন।</li>
<li>কেবলমাত্র প্রথম লুপটিকে একটি async ব্লকে র‍্যাপ করুন, এবং দ্বিতীয় লুপের বডির পরে ফলাফলস্বরূপ future-টিকে await করুন।</li>
</ul>
<p>একটি অতিরিক্ত চ্যালেঞ্জের জন্য, দেখুন আপনি প্রতিটি ক্ষেত্রে কোড চালানোর <em>আগে</em> আউটপুট কী হবে তা বের করতে পারেন কিনা!</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="message-passing"></a></p>
<h3 id="মেসেজ-পাসিং-বযবহার-করে-দুটি-টাসকে-গণনা-করা"><a class="header" href="#মেসেজ-পাসিং-বযবহার-করে-দুটি-টাসকে-গণনা-করা">মেসেজ পাসিং ব্যবহার করে দুটি টাস্কে গণনা করা</a></h3>
<p>Future-এর মধ্যে ডেটা শেয়ার করাও পরিচিত মনে হবে: আমরা আবার মেসেজ পাসিং ব্যবহার করব, কিন্তু এবার async সংস্করণ টাইপ এবং ফাংশনের সাথে। আমরা <a href="ch16-02-message-passing.html">Using Message Passing to Transfer Data Between Threads</a><!-- ignore -->-এ যে পথ নিয়েছিলাম তার থেকে কিছুটা ভিন্ন পথ নেব যাতে থ্রেড-ভিত্তিক এবং future-ভিত্তিক কনকারেন্সির মধ্যে কিছু মূল পার্থক্য তুলে ধরা যায়। লিস্টিং ১৭-৯-এ, আমরা কেবল একটি async ব্লক দিয়ে শুরু করব—একটি পৃথক থ্রেড তৈরি করার মতো করে একটি পৃথক টাস্ক তৈরি <em>না করে</em>।</p>
<Listing number="17-9" caption="একটি async চ্যানেল তৈরি করা এবং দুটি অংশ `tx` এবং `rx`-কে অ্যাসাইন করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("received '{received}'");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>এখানে, আমরা <code>trpl::channel</code> ব্যবহার করি, যা চ্যাপ্টার ১৬-তে আমরা থ্রেডের সাথে ব্যবহার করা মাল্টিপল-প্রডিউসার, সিঙ্গেল-কনজিউমার চ্যানেল API-এর একটি async সংস্করণ। API-এর async সংস্করণটি থ্রেড-ভিত্তিক সংস্করণ থেকে সামান্য ভিন্ন: এটি একটি অপরিবর্তনীয় রিসিভার <code>rx</code>-এর পরিবর্তে একটি পরিবর্তনযোগ্য রিসিভার ব্যবহার করে, এবং এর <code>recv</code> মেথড সরাসরি মান তৈরি করার পরিবর্তে একটি future তৈরি করে যা আমাদের await করতে হবে। এখন আমরা সেন্ডার থেকে রিসিভারে মেসেজ পাঠাতে পারি। লক্ষ্য করুন যে আমাদের একটি পৃথক থ্রেড বা এমনকি একটি টাস্কও তৈরি করতে হবে না; আমাদের কেবল <code>rx.recv</code> কলটি await করতে হবে।</p>
<p><code>std::mpsc::channel</code>-এর সিঙ্ক্রোনাস <code>Receiver::recv</code> মেথডটি একটি মেসেজ না পাওয়া পর্যন্ত ব্লক করে। <code>trpl::Receiver::recv</code> মেথডটি তা করে না, কারণ এটি async। ব্লক করার পরিবর্তে, এটি রানটাইমের কাছে নিয়ন্ত্রণ ফিরিয়ে দেয় যতক্ষণ না একটি মেসেজ পাওয়া যায় বা চ্যানেলের সেন্ড সাইড বন্ধ হয়ে যায়। এর বিপরীতে, আমরা <code>send</code> কলটি await করি না, কারণ এটি ব্লক করে না। এটির প্রয়োজন নেই, কারণ আমরা যে চ্যানেলে পাঠাচ্ছি তা আনবাউন্ডেড (unbounded)।</p>
<blockquote>
<p>দ্রষ্টব্য: যেহেতু এই সমস্ত async কোড একটি <code>trpl::run</code> কলের মধ্যে একটি async ব্লকে চলে, তাই এর মধ্যে সবকিছুই ব্লকিং এড়াতে পারে। যাইহোক, এর <em>বাইরের</em> কোডটি <code>run</code> ফাংশন রিটার্ন করার উপর ব্লক করবে। এটাই <code>trpl::run</code> ফাংশনের মূল উদ্দেশ্য: এটি আপনাকে <em>বেছে নিতে</em> দেয় কোথায় কিছু async কোডের সেটের উপর ব্লক করতে হবে, এবং এইভাবে সিঙ্ক এবং async কোডের মধ্যে কোথায় রূপান্তর করতে হবে। বেশিরভাগ async রানটাইমে, <code>run</code>-এর নাম আসলে ঠিক এই কারণেই <code>block_on</code>।</p>
</blockquote>
<p>এই উদাহরণ সম্পর্কে দুটি জিনিস লক্ষ্য করুন। প্রথমত, বার্তাটি সাথে সাথেই পৌঁছে যাবে। দ্বিতীয়ত, যদিও আমরা এখানে একটি future ব্যবহার করি, এখনও কোনো কনকারেন্সি নেই। লিস্টিংয়ের সবকিছু ক্রমানুসারে ঘটে, ঠিক যেমনটি হতো যদি কোনো future জড়িত না থাকত।</p>
<p>আসুন প্রথম অংশটি মোকাবেলা করি একটি সিরিজের বার্তা পাঠিয়ে এবং তাদের মধ্যে <code>sleep</code> করে, যেমনটি লিস্টিং ১৭-১০-এ দেখানো হয়েছে।</p>
<!-- We cannot test this one because it never stops! -->
<Listing number="17-10" caption="async চ্যানেলের মাধ্যমে একাধিক মেসেজ পাঠানো এবং গ্রহণ করা এবং প্রতিটি মেসেজের মধ্যে একটি `await` সহ `sleep` করা" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_millis(500)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>বার্তা পাঠানোর পাশাপাশি, আমাদের সেগুলি গ্রহণ করতে হবে। এই ক্ষেত্রে, যেহেতু আমরা জানি কতগুলি বার্তা আসছে, আমরা চারবার <code>rx.recv().await</code> কল করে এটি ম্যানুয়ালি করতে পারতাম। তবে বাস্তব জগতে, আমরা সাধারণত কিছু <em>অজানা</em> সংখ্যক বার্তার জন্য অপেক্ষা করব, তাই আমাদের আর কোনো বার্তা নেই তা নির্ধারণ না করা পর্যন্ত অপেক্ষা করতে হবে।</p>
<p>লিস্টিং ১৬-১০-এ, আমরা একটি সিঙ্ক্রোনাস চ্যানেল থেকে প্রাপ্ত সমস্ত আইটেম প্রসেস করার জন্য একটি <code>for</code> লুপ ব্যবহার করেছি। তবে রাস্টের কাছে এখনও আইটেমের একটি <em>অ্যাসিঙ্ক্রোনাস</em> সিরিজের উপর <code>for</code> লুপ লেখার কোনো উপায় নেই, তাই আমাদের এমন একটি লুপ ব্যবহার করতে হবে যা আমরা আগে দেখিনি: <code>while let</code> কন্ডিশনাল লুপ। এটি হলো <code>if let</code> কনস্ট্রাক্টের লুপ সংস্করণ যা আমরা <a href="ch06-03-if-let.html">Concise Control Flow with <code>if let</code> and <code>let else</code></a><!-- ignore --> বিভাগে দেখেছি। লুপটি ততক্ষণ চলতে থাকবে যতক্ষণ এর নির্দিষ্ট করা প্যাটার্নটি মানের সাথে মিলতে থাকবে।</p>
<p><code>rx.recv</code> কল একটি future তৈরি করে, যা আমরা await করি। রানটাইম future-টিকে প্রস্তুত না হওয়া পর্যন্ত পজ (pause) করবে। একবার একটি বার্তা এসে গেলে, future-টি যতবার একটি বার্তা আসবে ততবার <code>Some(message)</code>-এ রিজলভ হবে। যখন চ্যানেলটি বন্ধ হয়ে যাবে, কোনো বার্তা এসেছে কি না নির্বিশেষে, future-টি পরিবর্তে <code>None</code> রিজলভ করবে এটি নির্দেশ করার জন্য যে আর কোনো মান নেই এবং তাই আমাদের পোলিং বন্ধ করা উচিত—অর্থাৎ, await করা বন্ধ করা উচিত।</p>
<p><code>while let</code> লুপ এই সবকিছুকে একত্রিত করে। যদি <code>rx.recv().await</code> কল করার ফলাফল <code>Some(message)</code> হয়, আমরা বার্তাটিতে অ্যাক্সেস পাই এবং আমরা এটি লুপের বডিতে ব্যবহার করতে পারি, যেমনটি আমরা <code>if let</code>-এর সাথে করতে পারতাম। যদি ফলাফলটি <code>None</code> হয়, লুপটি শেষ হয়ে যায়। প্রতিবার লুপটি সম্পূর্ণ হলে, এটি আবার await পয়েন্টে আঘাত করে, তাই রানটাইম এটিকে আবার পজ করে যতক্ষণ না অন্য একটি বার্তা আসে।</p>
<p>কোডটি এখন সফলভাবে সমস্ত বার্তা পাঠায় এবং গ্রহণ করে। দুর্ভাগ্যবশত, এখনও কয়েকটি সমস্যা রয়েছে। একটি হলো, বার্তাগুলি আধা-সেকেন্ডের ব্যবধানে আসে না। প্রোগ্রাম শুরু করার ২ সেকেন্ড (২,০০০ মিলিসেকেন্ড) পরে সেগুলি একবারে আসে। আরেকটি হলো, এই প্রোগ্রামটি কখনও শেষ হয় না! পরিবর্তে, এটি নতুন বার্তার জন্য চিরকাল অপেক্ষা করে। আপনাকে <span class="keystroke">ctrl-c</span> ব্যবহার করে এটি বন্ধ করতে হবে।</p>
<p>আসুন প্রথমে পরীক্ষা করে দেখি কেন বার্তাগুলি পুরো বিলম্বের পরে একবারে আসে, প্রতিটিটির মধ্যে বিলম্ব সহ আসার পরিবর্তে। একটি নির্দিষ্ট async ব্লকের মধ্যে, কোডে <code>await</code> কিওয়ার্ডগুলি যে ক্রমে উপস্থিত হয়, প্রোগ্রাম চলার সময় সেগুলি সেই ক্রমেই কার্যকর হয়।</p>
<p>লিস্টিং ১৭-১০-এ কেবল একটি async ব্লক রয়েছে, তাই এর মধ্যে সবকিছু রৈখিকভাবে (linearly) চলে। এখনও কোনো কনকারেন্সি নেই। সমস্ত <code>tx.send</code> কল ঘটে, যার মধ্যে সমস্ত <code>trpl::sleep</code> কল এবং তাদের সংশ্লিষ্ট await পয়েন্টগুলি মিশে থাকে। শুধুমাত্র তারপরেই <code>while let</code> লুপ <code>recv</code> কলগুলির কোনো <code>await</code> পয়েন্টের মধ্য দিয়ে যেতে পারে।</p>
<p>আমরা যে আচরণটি চাই তা পেতে, যেখানে প্রতিটি বার্তার মধ্যে <code>sleep</code> বিলম্ব ঘটে, আমাদের <code>tx</code> এবং <code>rx</code> অপারেশনগুলিকে তাদের নিজস্ব async ব্লকে রাখতে হবে, যেমনটি লিস্টিং ১৭-১১-এ দেখানো হয়েছে। তারপরে রানটাইম <code>trpl::join</code> ব্যবহার করে সেগুলির প্রতিটি আলাদাভাবে চালাতে পারে, ঠিক গণনার উদাহরণের মতো। আবারও, আমরা <code>trpl::join</code> কল করার ফলাফল await করি, পৃথক future-গুলিকে নয়। যদি আমরা পৃথক future-গুলিকে ক্রমানুসারে await করতাম, আমরা কেবল একটি ক্রমিক প্রবাহে ফিরে আসতাম—ঠিক যা আমরা <em>না</em> করার চেষ্টা করছি।</p>
<!-- We cannot test this one because it never stops! -->
<Listing number="17-11" caption="`send` এবং `recv`-কে তাদের নিজস্ব `async` ব্লকে আলাদা করা এবং সেই ব্লকগুলির জন্য future-গুলিকে await করা" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>লিস্টিং ১৭-১১-এর আপডেট করা কোড দিয়ে, বার্তাগুলি ২ সেকেন্ড পরে একবারে আসার পরিবর্তে ৫০০-মিলিসেকেন্ডের ব্যবধানে প্রিন্ট হয়।</p>
<p>প্রোগ্রামটি এখনও কখনও শেষ হয় না, কারণ <code>while let</code> লুপটি <code>trpl::join</code>-এর সাথে যেভাবে ইন্টারঅ্যাক্ট করে তার জন্য:</p>
<ul>
<li><code>trpl::join</code> থেকে রিটার্ন করা future-টি তখনই সম্পূর্ণ হয় যখন এটিতে পাস করা <em>উভয়</em> future সম্পূর্ণ হয়।</li>
<li><code>tx</code> future-টি <code>vals</code>-এর শেষ বার্তাটি পাঠানোর পরে স্লিপ করা শেষ হলে সম্পূর্ণ হয়।</li>
<li><code>rx</code> future-টি <code>while let</code> লুপ শেষ না হওয়া পর্যন্ত সম্পূর্ণ হবে না।</li>
<li><code>while let</code> লুপটি <code>rx.recv</code> await করা <code>None</code> তৈরি না করা পর্যন্ত শেষ হবে না।</li>
<li><code>rx.recv</code> await করা তখনই <code>None</code> রিটার্ন করবে যখন চ্যানেলের অন্য প্রান্তটি বন্ধ হয়ে যাবে।</li>
<li>চ্যানেলটি তখনই বন্ধ হবে যদি আমরা <code>rx.close</code> কল করি বা যখন সেন্ডার সাইড, <code>tx</code>, ড্রপ (drop) হয়ে যায়।</li>
<li>আমরা কোথাও <code>rx.close</code> কল করি না, এবং <code>tx</code> ড্রপ হবে না যতক্ষণ না <code>trpl::run</code>-কে পাস করা সবচেয়ে বাইরের async ব্লকটি শেষ হয়।</li>
<li>ব্লকটি শেষ হতে পারে না কারণ এটি <code>trpl::join</code> সম্পূর্ণ হওয়ার উপর ব্লক হয়ে আছে, যা আমাদের এই তালিকার শীর্ষে ফিরিয়ে নিয়ে যায়।</li>
</ul>
<p>আমরা <code>rx.close</code> কল করে ম্যানুয়ালি <code>rx</code> বন্ধ করতে পারতাম, কিন্তু এর খুব একটা মানে হয় না। একটি নির্বিচারে সংখ্যক বার্তা পরিচালনা করার পরে থামলে প্রোগ্রামটি বন্ধ হয়ে যাবে, কিন্তু আমরা বার্তা মিস করতে পারি। আমাদের নিশ্চিত করার জন্য অন্য কোনো উপায় প্রয়োজন যাতে <code>tx</code> ফাংশনটির শেষ হওয়ার <em>আগে</em> ড্রপ হয়ে যায়।</p>
<p>এখন, আমরা যে async ব্লকে বার্তা পাঠাই তা কেবল <code>tx</code> ধার (borrow) করে কারণ একটি বার্তা পাঠানোর জন্য মালিকানার (ownership) প্রয়োজন হয় না, কিন্তু যদি আমরা <code>tx</code>-কে সেই async ব্লকের মধ্যে মুভ (move) করতে পারতাম, তবে সেই ব্লকটি শেষ হয়ে গেলে এটি ড্রপ হয়ে যেত। চ্যাপ্টার ১৩-এর <a href="ch13-01-closures.html#capturing-references-or-moving-ownership">Capturing References or Moving Ownership</a><!-- ignore --> বিভাগে, আপনি শিখেছেন কীভাবে ক্লোজারের সাথে <code>move</code> কিওয়ার্ড ব্যবহার করতে হয়, এবং, চ্যাপ্টার ১৬-এর <a href="ch16-01-threads.html#using-move-closures-with-threads">Using <code>move</code> Closures with Threads</a><!-- ignore --> বিভাগে আলোচনা করা হয়েছে, থ্রেডের সাথে কাজ করার সময় আমাদের প্রায়শই ক্লোজারের মধ্যে ডেটা মুভ করতে হয়। একই মৌলিক গতিবিদ্যা async ব্লকগুলিতেও প্রযোজ্য, তাই <code>move</code> কিওয়ার্ড async ব্লকগুলির সাথে ঠিক সেভাবেই কাজ করে যেমনটি ক্লোজারের সাথে করে।</p>
<p>লিস্টিং ১৭-১২-এ, আমরা বার্তা পাঠানোর জন্য ব্যবহৃত ব্লকটিকে <code>async</code> থেকে <code>async move</code>-এ পরিবর্তন করি। যখন আমরা কোডের <em>এই</em> সংস্করণটি চালাই, তখন শেষ বার্তাটি পাঠানো এবং গ্রহণ করার পরে এটি সুন্দরভাবে বন্ধ হয়ে যায়।</p>
<Listing number="17-12" caption="লিস্টিং ১৭-১১ থেকে কোডের একটি পরিমার্জিত সংস্করণ যা সম্পূর্ণ হলে সঠিকভাবে বন্ধ হয়ে যায়" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>এই async চ্যানেলটিও একটি মাল্টিপল-প্রডিউসার চ্যানেল, তাই আমরা যদি একাধিক future থেকে বার্তা পাঠাতে চাই তবে <code>tx</code>-এর উপর <code>clone</code> কল করতে পারি, যেমনটি লিস্টিং ১৭-১৩-এ দেখানো হয়েছে।</p>
<Listing number="17-13" caption="async ব্লকগুলির সাথে একাধিক প্রডিউসার ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_millis(500)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_millis(1500)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>প্রথমে, আমরা <code>tx</code> ক্লোন করি, প্রথম async ব্লকের বাইরে <code>tx1</code> তৈরি করি। আমরা <code>tx1</code>-কে সেই ব্লকের মধ্যে মুভ করি ঠিক যেমনটি আমরা আগে <code>tx</code>-এর সাথে করেছি। তারপরে, পরে, আমরা মূল <code>tx</code>-কে একটি <em>নতুন</em> async ব্লকে মুভ করি, যেখানে আমরা সামান্য ধীর গতিতে আরও বার্তা পাঠাই। আমরা ঘটনাচক্রে এই নতুন async ব্লকটি বার্তা গ্রহণের জন্য async ব্লকের পরে রাখি, তবে এটি এর আগেও থাকতে পারত। মূল বিষয় হলো future-গুলি কোন ক্রমে await করা হয়, কোন ক্রমে সেগুলি তৈরি করা হয় তা নয়।</p>
<p>বার্তা পাঠানোর জন্য উভয় async ব্লককেই <code>async move</code> ব্লক হতে হবে যাতে <code>tx</code> এবং <code>tx1</code> উভয়ই সেই ব্লকগুলি শেষ হলে ড্রপ হয়ে যায়। অন্যথায়, আমরা সেই একই অসীম লুপে ফিরে যাব যা দিয়ে আমরা শুরু করেছিলাম। অবশেষে, আমরা অতিরিক্ত future-টি পরিচালনা করার জন্য <code>trpl::join</code> থেকে <code>trpl::join3</code>-এ স্যুইচ করি।</p>
<p>এখন আমরা উভয় সেন্ডিং future থেকে সমস্ত বার্তা দেখতে পাই, এবং যেহেতু সেন্ডিং future-গুলি পাঠানোর পরে সামান্য ভিন্ন বিলম্ব ব্যবহার করে, বার্তাগুলিও সেই ভিন্ন ব্যবধানে গৃহীত হয়।</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'the'
received 'messages'
received 'future'
received 'for'
received 'you'
</code></pre>
<p>এটি একটি ভালো শুরু, কিন্তু এটি আমাদের কেবল কয়েকটি future-এর মধ্যে সীমাবদ্ধ রাখে: <code>join</code>-এর সাথে দুটি, বা <code>join3</code>-এর সাথে তিনটি। আসুন দেখি আমরা কীভাবে আরও future-এর সাথে কাজ করতে পারি।</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-03-more-futures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-01-futures-and-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-03-more-futures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
