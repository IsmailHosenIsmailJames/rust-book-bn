<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>যেকোনো সংখ্যক ফিউচার নিয়ে কাজ করা - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="যেকোনো-সংখযক-ফিউচারের-সাথে-কাজ-করা"><a class="header" href="#যেকোনো-সংখযক-ফিউচারের-সাথে-কাজ-করা">যেকোনো সংখ্যক ফিউচারের সাথে কাজ করা</a></h2>
<p>পূর্ববর্তী বিভাগে যখন আমরা দুটি ফিউচার থেকে তিনটি ফিউচারে স্যুইচ করেছি, তখন আমাদের <code>join</code> থেকে <code>join3</code> ব্যবহার করতে হয়েছিল। আমরা যতবার ফিউচারের সংখ্যা পরিবর্তন করব, ততবার একটি ভিন্ন ফাংশন কল করতে হলে তা বিরক্তিকর হতো। আনন্দের বিষয়, আমাদের কাছে <code>join</code>-এর একটি ম্যাক্রো ফর্ম রয়েছে যেখানে আমরা ইচ্ছামত আর্গুমেন্ট পাস করতে পারি। এটি ফিউচারগুলোকে await করার কাজও নিজেই করে। সুতরাং, আমরা লিস্টিং 17-13 থেকে কোডটি <code>join3</code>-এর পরিবর্তে <code>join!</code> ব্যবহার করে পুনরায় লিখতে পারি, যেমনটি লিস্টিং 17-14-এ দেখানো হয়েছে।</p>
<Listing number="17-14" caption="একাধিক ফিউচারের জন্য অপেক্ষা করতে `join!` ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        trpl::join!(tx1_fut, tx_fut, rx_fut);
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>এটি অবশ্যই <code>join</code> এবং <code>join3</code> এবং <code>join4</code> ইত্যাদির মধ্যে অদলবদল করার চেয়ে একটি উন্নতি! যাইহোক, এমনকি এই ম্যাক্রো ফর্মটি কেবল তখনই কাজ করে যখন আমরা আগে থেকে ফিউচারের সংখ্যা জানি। কিন্তু বাস্তব-জগতের রাস্ট কোডে, ফিউচারগুলোকে একটি কালেকশনে পুশ করা এবং তারপরে তাদের কিছু বা সমস্ত ফিউচার সম্পূর্ণ হওয়ার জন্য অপেক্ষা করা একটি সাধারণ প্যাটার্ন।</p>
<p>কোনো কালেকশনের সমস্ত ফিউচার পরীক্ষা করার জন্য, আমাদের সেগুলোর সবগুলোর উপর ইটারেট করতে হবে এবং জয়েন করতে হবে। <code>trpl::join_all</code> ফাংশনটি যেকোনো টাইপ গ্রহণ করে যা <code>Iterator</code> ট্রেইট ইমপ্লিমেন্ট করে, যা আপনি চ্যাপ্টার ১৩-এর <a href="ch13-02-iterators.html#the-iterator-trait-and-the-next-method">The Iterator Trait and the <code>next</code> Method</a><!-- ignore -->-এ শিখেছেন, তাই এটি ঠিক কাজের জিনিস বলে মনে হচ্ছে। আসুন আমাদের ফিউচারগুলোকে একটি ভেক্টরে রাখি এবং <code>join!</code>-কে <code>join_all</code> দিয়ে প্রতিস্থাপন করার চেষ্টা করি যেমনটি লিস্টিং 17-15-এ দেখানো হয়েছে।</p>
<Listing  number="17-15" caption="একটি ভেক্টরে নামহীন ফিউচার সংরক্ষণ করা এবং `join_all` কল করা">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures = vec![tx1_fut, rx_fut, tx_fut];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>দুর্ভাগ্যবশত, এই কোডটি কম্পাইল হয় না। পরিবর্তে, আমরা এই ত্রুটিটি পাই:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-15/
cargo build
copy just the compiler error
-->
<pre><code class="language-text">error[E0308]: mismatched types
  --&gt; src/main.rs:45:37
   |
10 |         let tx1_fut = async move {
   |                       ---------- the expected `async` block
...
24 |         let rx_fut = async {
   |                      ----- the found `async` block
...
45 |         let futures = vec![tx1_fut, rx_fut, tx_fut];
   |                                     ^^^^^^ expected `async` block, found a different `async` block
   |
   = note: expected `async` block `{async block@src/main.rs:10:23: 10:33}`
              found `async` block `{async block@src/main.rs:24:22: 24:27}`
   = note: no two async blocks, even if identical, have the same type
   = help: consider pinning your async block and casting it to a trait object
</code></pre>
<p>এটি আশ্চর্যজনক হতে পারে। সর্বোপরি, কোনো async ব্লকই কিছু রিটার্ন করে না, তাই প্রতিটি একটি <code>Future&lt;Output = ()&gt;</code> তৈরি করে। মনে রাখবেন যে <code>Future</code> একটি ট্রেইট, এবং কম্পাইলার প্রতিটি async ব্লকের জন্য একটি অনন্য enum তৈরি করে। আপনি একটি <code>Vec</code>-এ দুটি ভিন্ন হাতে লেখা struct রাখতে পারবেন না, এবং একই নিয়ম কম্পাইলার দ্বারা জেনারেট করা বিভিন্ন enum-এর ক্ষেত্রেও প্রযোজ্য।</p>
<p>এটি কাজ করানোর জন্য, আমাদের <em>ট্রেইট অবজেক্ট</em> ব্যবহার করতে হবে, ঠিক যেমনটি আমরা চ্যাপ্টার ১২-এর <a href="ch12-03-improving-error-handling-and-modularity.html">“Returning Errors from the run function”</a><!-- ignore -->-এ করেছিলাম। (আমরা চ্যাপ্টার ১৮-এ ট্রেইট অবজেক্ট নিয়ে বিস্তারিত আলোচনা করব।) ট্রেইট অবজেক্ট ব্যবহার করে আমরা এই টাইপগুলো দ্বারা উৎপাদিত প্রতিটি নামহীন ফিউচারকে একই টাইপ হিসাবে বিবেচনা করতে পারি, কারণ সেগুলির সবগুলোই <code>Future</code> ট্রেইট ইমপ্লিমেন্ট করে।</p>
<blockquote>
<p>দ্রষ্টব্য: চ্যাপ্টার ৮-এর <a href="ch08-01-vectors.html#using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Values</a><!-- ignore -->-এ, আমরা একটি <code>Vec</code>-এ একাধিক টাইপ অন্তর্ভুক্ত করার আরেকটি উপায় নিয়ে আলোচনা করেছি: ভেক্টরে উপস্থিত হতে পারে এমন প্রতিটি টাইপকে উপস্থাপন করার জন্য একটি enum ব্যবহার করা। তবে, আমরা এখানে তা করতে পারি না। একটি কারণ হলো, আমাদের বিভিন্ন টাইপের নামকরণ করার কোনো উপায় নেই, কারণ সেগুলি নামহীন। আরেকটি কারণ হলো, আমরা একটি ভেক্টর এবং <code>join_all</code> ব্যবহার করার মূল কারণটি ছিল ফিউচারের একটি ডাইনামিক কালেকশনের সাথে কাজ করতে পারা যেখানে আমরা কেবল তাদের একই আউটপুট টাইপ থাকা নিয়েই চিন্তা করি।</p>
</blockquote>
<p>আমরা লিস্টিং 17-16-এ দেখানো হিসাবে <code>vec!</code>-এর প্রতিটি ফিউচারকে একটি <code>Box::new</code>-এ র‍্যাপ করে শুরু করি।</p>
<Listing number="17-16" caption="একটি `Vec`-এ ফিউচারের টাইপগুলি সারিবদ্ধ করতে `Box::new` ব্যবহার করা" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];

        trpl::join_all(futures).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>দুর্ভাগ্যবশত, এই কোডটি এখনও কম্পাইল হয় না। আসলে, আমরা দ্বিতীয় এবং তৃতীয় <code>Box::new</code> কল উভয়ের জন্য আগের মতোই একই মৌলিক ত্রুটি পাই, সেইসাথে <code>Unpin</code> ট্রেইট উল্লেখ করে নতুন ত্রুটিও পাই। আমরা এক মুহূর্তের মধ্যে <code>Unpin</code> ত্রুটিগুলিতে ফিরে আসব। প্রথমে, আসুন <code>futures</code> ভেরিয়েবলের টাইপটি স্পষ্টভাবে উল্লেখ করে <code>Box::new</code> কলগুলিতে টাইপের ত্রুটিগুলি ঠিক করি (দেখুন লিস্টিং 17-17)।</p>
<Listing number="17-17" caption="একটি সুস্পষ্ট টাইপ ডিক্লারেশন ব্যবহার করে বাকি টাইপ মিসম্যাচ ত্রুটিগুলি ঠিক করা" file-name="src/main.rs">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![Box::new(tx1_fut), Box::new(rx_fut), Box::new(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>এই টাইপ ডিক্লারেশনটি একটু জটিল, তাই আসুন এটি ধাপে ধাপে দেখি:</p>
<ol>
<li>সবচেয়ে ভেতরের টাইপটি হলো ফিউচার নিজেই। আমরা স্পষ্টভাবে উল্লেখ করি যে ফিউচারের আউটপুট হলো ইউনিট টাইপ <code>()</code> যা <code>Future&lt;Output = ()&gt;</code> লিখে করা হয়েছে।</li>
<li>তারপর আমরা ট্রেইটটিকে ডাইনামিক হিসাবে চিহ্নিত করতে <code>dyn</code> দিয়ে টীকাবদ্ধ (annotate) করি।</li>
<li>পুরো ট্রেইট রেফারেন্সটি একটি <code>Box</code>-এ মোড়ানো হয়।</li>
<li>অবশেষে, আমরা স্পষ্টভাবে বলি যে <code>futures</code> হলো একটি <code>Vec</code> যা এই আইটেমগুলি ধারণ করে।</li>
</ol>
<p>এটি ইতিমধ্যেই একটি বড় পার্থক্য তৈরি করেছে। এখন যখন আমরা কম্পাইলার চালাই, আমরা কেবল <code>Unpin</code> উল্লেখ করা ত্রুটিগুলি পাই। যদিও তিনটি ত্রুটি আছে, তাদের বিষয়বস্তু খুব অনুরূপ।</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-17
cargo build
# copy *only* the errors
# fix the paths
-->
<pre><code class="language-text">error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
   --&gt; src/main.rs:49:24
    |
49  |         trpl::join_all(futures).await;
    |         -------------- ^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
    |         |
    |         required by a bound introduced by this call
    |
    = note: consider using the `pin!` macro
            consider using `Box::pin` if you need to access the pinned value outside of the current scope
    = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `join_all`
   --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:105:14
    |
102 | pub fn join_all&lt;I&gt;(iter: I) -&gt; JoinAll&lt;I::Item&gt;
    |        -------- required by a bound in this function
...
105 |     I::Item: Future,
    |              ^^^^^^ required by this bound in `join_all`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:9
   |
49 |         trpl::join_all(futures).await;
   |         ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

error[E0277]: `dyn Future&lt;Output = ()&gt;` cannot be unpinned
  --&gt; src/main.rs:49:33
   |
49 |         trpl::join_all(futures).await;
   |                                 ^^^^^ the trait `Unpin` is not implemented for `dyn Future&lt;Output = ()&gt;`
   |
   = note: consider using the `pin!` macro
           consider using `Box::pin` if you need to access the pinned value outside of the current scope
   = note: required for `Box&lt;dyn Future&lt;Output = ()&gt;&gt;` to implement `Future`
note: required by a bound in `futures_util::future::join_all::JoinAll`
  --&gt; file:///home/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/futures-util-0.3.30/src/future/join_all.rs:29:8
   |
27 | pub struct JoinAll&lt;F&gt;
   |            ------- required by a bound in this struct
28 | where
29 |     F: Future,
   |        ^^^^^^ required by this bound in `JoinAll`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `async_await` (bin "async_await") due to 3 previous errors
</code></pre>
<p>এটি হজম করার জন্য <em>অনেক</em> কিছু, তাই আসুন এটি ভেঙে দেখি। বার্তার প্রথম অংশটি আমাদের বলে যে প্রথম async ব্লকটি (<code>src/main.rs:8:23: 20:10</code>) <code>Unpin</code> ট্রেইট ইমপ্লিমেন্ট করে না এবং এটি সমাধান করার জন্য <code>pin!</code> বা <code>Box::pin</code> ব্যবহার করার পরামর্শ দেয়। অধ্যায়ের পরে, আমরা <code>Pin</code> এবং <code>Unpin</code> সম্পর্কে আরও কিছু বিশদ বিবরণে যাব। তবে এই মুহূর্তে, আমরা কেবল আটকে যাওয়া অবস্থা থেকে বের হতে কম্পাইলারের পরামর্শ অনুসরণ করতে পারি। লিস্টিং 17-18-এ, আমরা <code>std::pin</code> থেকে <code>Pin</code> ইমপোর্ট করে শুরু করি। এরপরে আমরা <code>futures</code>-এর জন্য টাইপ অ্যানোটেশন আপডেট করি, প্রতিটি <code>Box</code>-কে একটি <code>Pin</code> দিয়ে র‍্যাপ করে। অবশেষে, আমরা ফিউচারগুলিকে পিন করার জন্য <code>Box::pin</code> ব্যবহার করি।</p>
<Listing number="17-18" caption="`Vec` টাইপ চেক করার জন্য `Pin` এবং `Box::pin` ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::pin::Pin;

// -- snip --

<span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span><span class="boring">        let tx1_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let tx_fut = async move {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let futures: Vec&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt;&gt;&gt;&gt; =
            vec![Box::pin(tx1_fut), Box::pin(rx_fut), Box::pin(tx_fut)];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>যদি আমরা এটি কম্পাইল করে চালাই, আমরা অবশেষে সেই আউটপুট পাব যা আমরা আশা করেছিলাম:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">received 'hi'
received 'more'
received 'from'
received 'messages'
received 'the'
received 'for'
received 'future'
received 'you'
</code></pre>
<p>যাক বাবা!</p>
<p>এখানে আরও কিছু অন্বেষণ করার আছে। একটি বিষয় হলো, <code>Pin&lt;Box&lt;T&gt;&gt;</code> ব্যবহার করা এই ফিউচারগুলিকে <code>Box</code> দিয়ে হিপে রাখার কারণে সামান্য পরিমাণ ওভারহেড যোগ করে—এবং আমরা এটি কেবল টাইপগুলি মেলানোর জন্যই করছি। আমাদের আসলে <em>প্রয়োজন</em> নেই হিপ অ্যালোকেশনের, সর্বোপরি: এই ফিউচারগুলি এই নির্দিষ্ট ফাংশনের জন্য স্থানীয়। যেমন আগে উল্লেখ করা হয়েছে, <code>Pin</code> নিজেই একটি র‍্যাপার টাইপ, তাই আমরা <code>Vec</code>-এ একটি একক টাইপ থাকার সুবিধা পেতে পারি—যা ছিল <code>Box</code> ব্যবহার করার মূল কারণ—হিপ অ্যালোকেশন ছাড়াই। আমরা প্রতিটি ফিউচারের সাথে সরাসরি <code>Pin</code> ব্যবহার করতে পারি, <code>std::pin::pin</code> ম্যাক্রো ব্যবহার করে।</p>
<p>যাইহোক, আমাদের এখনও পিন করা রেফারেন্সের টাইপ সম্পর্কে সুস্পষ্ট হতে হবে; অন্যথায়, রাস্ট এখনও জানবে না যে এগুলিকে ডাইনামিক ট্রেইট অবজেক্ট হিসাবে ব্যাখ্যা করতে হবে, যা <code>Vec</code>-এ আমাদের প্রয়োজন। তাই আমরা <code>std::pin</code> থেকে আমাদের ইমপোর্টের তালিকায় <code>pin</code> যোগ করি। তারপরে আমরা প্রতিটি ফিউচারকে <code>pin!</code> করতে পারি যখন আমরা এটি সংজ্ঞায়িত করি এবং <code>futures</code>-কে ডাইনামিক ফিউচার টাইপের পিন করা মিউটেবল রেফারেন্স ধারণকারী একটি <code>Vec</code> হিসাবে সংজ্ঞায়িত করি, যেমনটি লিস্টিং 17-19-এ দেখানো হয়েছে।</p>
<Listing number="17-19" caption="অপ্রয়োজনীয় হিপ অ্যালোকেশন এড়াতে সরাসরি `pin!` ম্যাক্রো সহ `Pin` ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span>use std::pin::{Pin, pin};

// -- snip --

<span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx1 = tx.clone();
</span>        let tx1_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx1.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let rx_fut = pin!(async {
            // --snip--
<span class="boring">            while let Some(value) = rx.recv().await {
</span><span class="boring">                println!("received '{value}'");
</span><span class="boring">            }
</span>        });

        let tx_fut = pin!(async move {
            // --snip--
<span class="boring">            let vals = vec![
</span><span class="boring">                String::from("more"),
</span><span class="boring">                String::from("messages"),
</span><span class="boring">                String::from("for"),
</span><span class="boring">                String::from("you"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span>        });

        let futures: Vec&lt;Pin&lt;&amp;mut dyn Future&lt;Output = ()&gt;&gt;&gt; =
            vec![tx1_fut, rx_fut, tx_fut];
<span class="boring">
</span><span class="boring">        trpl::join_all(futures).await;
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>আমরা এই পর্যন্ত এসেছি এই সত্যটিকে উপেক্ষা করে যে আমাদের বিভিন্ন <code>Output</code> টাইপ থাকতে পারে। উদাহরণস্বরূপ, লিস্টিং 17-20-এ, <code>a</code>-এর জন্য নামহীন ফিউচারটি <code>Future&lt;Output = u32&gt;</code> ইমপ্লিমেন্ট করে, <code>b</code>-এর জন্য নামহীন ফিউচারটি <code>Future&lt;Output = &amp;str&gt;</code> ইমপ্লিমেন্ট করে, এবং <code>c</code>-এর জন্য নামহীন ফিউচারটি <code>Future&lt;Output = bool&gt;</code> ইমপ্লিমেন্ট করে।</p>
<Listing number="17-20" caption="স্বতন্ত্র টাইপ সহ তিনটি ফিউচার" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async { 1u32 };
        let b = async { "Hello!" };
        let c = async { true };

        let (a_result, b_result, c_result) = trpl::join!(a, b, c);
        println!("{a_result}, {b_result}, {c_result}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>আমরা তাদের await করার জন্য <code>trpl::join!</code> ব্যবহার করতে পারি, কারণ এটি আমাদের একাধিক ফিউচার টাইপ পাস করার অনুমতি দেয় এবং সেই টাইপগুলির একটি টাপল তৈরি করে। আমরা <code>trpl::join_all</code> ব্যবহার করতে <em>পারি না</em>, কারণ এটির জন্য পাস করা সমস্ত ফিউচারের একই টাইপ থাকা প্রয়োজন। মনে রাখবেন, সেই ত্রুটিটিই আমাদের <code>Pin</code>-এর সাথে এই অ্যাডভেঞ্চার শুরু করিয়েছিল!</p>
<p>এটি একটি মৌলিক ট্রেড-অফ: আমরা হয় <code>join_all</code>-এর সাথে একটি ডাইনামিক সংখ্যক ফিউচারের সাথে ডিল করতে পারি, যতক্ষণ না তাদের সবার একই টাইপ থাকে, অথবা আমরা <code>join</code> ফাংশন বা <code>join!</code> ম্যাক্রোর সাথে একটি নির্দিষ্ট সংখ্যক ফিউচারের সাথে ডিল করতে পারি, এমনকি তাদের বিভিন্ন টাইপ থাকলেও। এটি একই পরিস্থিতি যা আমরা রাস্টে অন্য কোনো টাইপের সাথে কাজ করার সময় সম্মুখীন হতাম। ফিউচারগুলি বিশেষ কিছু নয়, যদিও আমাদের তাদের সাথে কাজ করার জন্য কিছু চমৎকার সিনট্যাক্স আছে, এবং এটি একটি ভালো জিনিস।</p>
<h3 id="ফিউচার-রেসিং"><a class="header" href="#ফিউচার-রেসিং">ফিউচার রেসিং</a></h3>
<p>যখন আমরা <code>join</code> পরিবারের ফাংশন এবং ম্যাক্রোগুলোর সাথে ফিউচারগুলিকে "জয়েন" করি, তখন আমাদের এগিয়ে যাওয়ার আগে সেগুলির <em>সবগুলো</em> শেষ হওয়ার প্রয়োজন হয়। তবে কখনও কখনও, এগিয়ে যাওয়ার আগে আমাদের একটি সেট থেকে কেবল <em>কিছু</em> ফিউচার শেষ হলেই চলে— অনেকটা একটি ফিউচারকে অন্যটির বিরুদ্ধে রেস করানোর মতো।</p>
<p>লিস্টিং 17-21-এ, আমরা আবারও <code>trpl::race</code> ব্যবহার করে দুটি ফিউচার, <code>slow</code> এবং <code>fast</code>-কে একে অপরের বিরুদ্ধে চালাই।</p>
<Listing number="17-21" caption="যে ফিউচারটি প্রথমে শেষ হয় তার ফলাফল পেতে `race` ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            println!("'slow' started.");
            trpl::sleep(Duration::from_millis(100)).await;
            println!("'slow' finished.");
        };

        let fast = async {
            println!("'fast' started.");
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'fast' finished.");
        };

        trpl::race(slow, fast).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>প্রতিটি ফিউচার যখন চলতে শুরু করে তখন একটি বার্তা প্রিন্ট করে, <code>sleep</code> কল করে এবং await করে কিছু সময়ের জন্য পজ করে, এবং তারপরে যখন এটি শেষ হয় তখন আরেকটি বার্তা প্রিন্ট করে। তারপরে আমরা <code>slow</code> এবং <code>fast</code> উভয়কেই <code>trpl::race</code>-এ পাস করি এবং তাদের মধ্যে একটি শেষ হওয়ার জন্য অপেক্ষা করি। (এখানের ফলাফল খুব আশ্চর্যজনক নয়: <code>fast</code> জেতে।) যখন আমরা <a href="ch17-01-futures-and-syntax.html#our-first-async-program">“Our First Async Program”</a><!-- ignore -->-এ <code>race</code> ব্যবহার করেছিলাম তার থেকে ভিন্ন, আমরা এখানে এটি রিটার্ন করা <code>Either</code> ইন্সট্যান্সটিকে উপেক্ষা করি, কারণ সমস্ত আকর্ষণীয় আচরণ async ব্লকগুলির বডিতে ঘটে।</p>
<p>লক্ষ্য করুন যে আপনি যদি <code>race</code>-এর আর্গুমেন্টের ক্রম উল্টে দেন, তবে "started" বার্তাগুলির ক্রম পরিবর্তিত হয়, যদিও <code>fast</code> ফিউচারটি সবসময় প্রথমে সম্পন্ন হয়। এর কারণ হলো এই নির্দিষ্ট <code>race</code> ফাংশনের ইমপ্লিমেন্টেশনটি ফেয়ার (fair) নয়। এটি সর্বদা আর্গুমেন্ট হিসাবে পাস করা ফিউচারগুলিকে যে ক্রমে পাস করা হয় সেই ক্রমে চালায়। অন্যান্য ইমপ্লিমেন্টেশনগুলি <em>ফেয়ার</em> এবং এলোমেলোভাবে বেছে নেবে কোন ফিউচারটি প্রথমে পোল (poll) করতে হবে। <code>race</code>-এর যে ইমপ্লিমেন্টেশন আমরা ব্যবহার করছি তা ফেয়ার হোক বা না হোক, <em>একটি</em> ফিউচার অন্য টাস্ক শুরু করার আগে তার বডিতে প্রথম <code>await</code> পর্যন্ত চলবে।</p>
<p><a href="ch17-01-futures-and-syntax.html#our-first-async-program">Our First Async Program</a><!-- ignore --> থেকে স্মরণ করুন যে প্রতিটি await পয়েন্টে, রাস্ট একটি রানটাইমকে টাস্কটি পজ করার এবং অন্য একটিতে স্যুইচ করার সুযোগ দেয় যদি await করা ফিউচারটি প্রস্তুত না থাকে। এর বিপরীতটিও সত্য: রাস্ট <em>কেবলমাত্র</em> একটি await পয়েন্টে async ব্লকগুলি পজ করে এবং একটি রানটাইমের কাছে নিয়ন্ত্রণ ফিরিয়ে দেয়। await পয়েন্টগুলির মধ্যে সবকিছুই সিঙ্ক্রোনাস।</p>
<p>এর মানে হলো যদি আপনি একটি await পয়েন্ট ছাড়াই একটি async ব্লকে অনেক কাজ করেন, তবে সেই ফিউচারটি অন্য কোনো ফিউচারকে অগ্রগতি করতে বাধা দেবে। আপনি কখনও কখনও এটিকে একটি ফিউচার অন্য ফিউচারকে <em>স্টার্ভিং</em> (starving) হিসাবে উল্লেখ করতে শুনতে পারেন। কিছু ক্ষেত্রে, এটি একটি বড় ব্যাপার নাও হতে পারে। যাইহোক, যদি আপনি কোনো ধরনের ব্যয়বহুল সেটআপ বা দীর্ঘ সময় ধরে চলা কাজ করছেন, বা যদি আপনার একটি ফিউচার থাকে যা অনির্দিষ্টকালের জন্য কোনো নির্দিষ্ট কাজ করতে থাকবে, তবে আপনাকে কখন এবং কোথায় রানটাইমের কাছে নিয়ন্ত্রণ ফিরিয়ে দিতে হবে তা নিয়ে ভাবতে হবে।</p>
<p>একইভাবে, যদি আপনার দীর্ঘ সময় ধরে চলা ব্লকিং অপারেশন থাকে, তবে async প্রোগ্রামের বিভিন্ন অংশ একে অপরের সাথে কীভাবে সম্পর্কিত হবে তার উপায় সরবরাহ করার জন্য একটি দরকারী টুল হতে পারে।</p>
<p>কিন্তু সেই ক্ষেত্রে আপনি <em>কীভাবে</em> রানটাইমের কাছে নিয়ন্ত্রণ ফিরিয়ে দেবেন?</p>
<!-- Old headings. Do not remove or links may break. -->
<p><a id="yielding"></a></p>
<h3 id="রানটাইমকে-নিযনতরণ-ছেডে-দেওযা-yielding-control"><a class="header" href="#রানটাইমকে-নিযনতরণ-ছেডে-দেওযা-yielding-control">রানটাইমকে নিয়ন্ত্রণ ছেড়ে দেওয়া (Yielding Control)</a></h3>
<p>আসুন একটি দীর্ঘ সময় ধরে চলা অপারেশন সিমুলেট করি। লিস্টিং 17-22 একটি <code>slow</code> ফাংশন উপস্থাপন করে।</p>
<Listing number="17-22" caption="ধীর গতির অপারেশন সিমুলেট করতে `thread::sleep` ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        // We will call `slow` here later
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>fn slow(name: &amp;str, ms: u64) {
    thread::sleep(Duration::from_millis(ms));
    println!("'{name}' ran for {ms}ms");
}</code></pre></pre>
</Listing>
<p>এই কোডটি <code>trpl::sleep</code>-এর পরিবর্তে <code>std::thread::sleep</code> ব্যবহার করে যাতে <code>slow</code> কল করা বর্তমান থ্রেডটিকে কিছু সংখ্যক মিলিসেকেন্ডের জন্য ব্লক করে। আমরা <code>slow</code>-কে বাস্তব-বিশ্বের অপারেশনগুলির বিকল্প হিসাবে ব্যবহার করতে পারি যা দীর্ঘ সময় ধরে চলে এবং ব্লকিং।</p>
<p>লিস্টিং 17-23-এ, আমরা একজোড়া ফিউচারে এই ধরনের CPU-বাউন্ড কাজ অনুকরণ করতে <code>slow</code> ব্যবহার করি।</p>
<Listing number="17-23" caption="ধীর গতির অপারেশন সিমুলেট করতে `thread::sleep` ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            slow("a", 10);
            slow("a", 20);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            slow("b", 10);
            slow("b", 15);
            slow("b", 350);
            trpl::sleep(Duration::from_millis(50)).await;
            println!("'b' finished.");
        };

        trpl::race(a, b).await;
<span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>শুরু করার জন্য, প্রতিটি ফিউচার কেবল একগুচ্ছ ধীর অপারেশন করার <em>পরেই</em> রানটাইমের কাছে নিয়ন্ত্রণ ফিরিয়ে দেয়। আপনি যদি এই কোডটি চালান, আপনি এই আউটপুট দেখতে পাবেন:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-23/
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'a' ran for 10ms
'a' ran for 20ms
'b' started.
'b' ran for 75ms
'b' ran for 10ms
'b' ran for 15ms
'b' ran for 350ms
'a' finished.
</code></pre>
<p>আমাদের আগের উদাহরণের মতো, <code>a</code> শেষ হওয়ার সাথে সাথেই <code>race</code> শেষ হয়। তবে, দুটি ফিউচারের মধ্যে কোনো ইন্টারলিভিং নেই। <code>a</code> ফিউচারটি <code>trpl::sleep</code> কল await না হওয়া পর্যন্ত তার সমস্ত কাজ করে, তারপর <code>b</code> ফিউচারটি তার নিজের <code>trpl::sleep</code> কল await না হওয়া পর্যন্ত তার সমস্ত কাজ করে, এবং অবশেষে <code>a</code> ফিউচারটি সম্পন্ন হয়। উভয় ফিউচারকে তাদের ধীর কাজগুলির মধ্যে অগ্রগতি করার অনুমতি দিতে, আমাদের await পয়েন্ট প্রয়োজন যাতে আমরা রানটাইমের কাছে নিয়ন্ত্রণ ফিরিয়ে দিতে পারি। এর মানে হলো আমাদের এমন কিছু দরকার যা আমরা await করতে পারি!</p>
<p>আমরা ইতিমধ্যে লিস্টিং 17-23-এ এই ধরনের হ্যান্ডঅফ দেখতে পাচ্ছি: যদি আমরা <code>a</code> ফিউচারের শেষে <code>trpl::sleep</code> সরিয়ে ফেলি, তবে এটি <code>b</code> ফিউচারটি <em>একেবারেই</em> না চলেই সম্পন্ন হবে। আসুন অপারেশনগুলিকে অগ্রগতিতে স্যুইচ করার জন্য একটি সূচনা বিন্দু হিসাবে <code>sleep</code> ফাংশনটি ব্যবহার করার চেষ্টা করি, যেমনটি লিস্টিং 17-24-এ দেখানো হয়েছে।</p>
<Listing number="17-24" caption="অপারেশনগুলিকে অগ্রগতিতে স্যুইচ করার জন্য `sleep` ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ms = Duration::from_millis(1);

        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::sleep(one_ms).await;
            slow("a", 10);
            trpl::sleep(one_ms).await;
            slow("a", 20);
            trpl::sleep(one_ms).await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::sleep(one_ms).await;
            slow("b", 10);
            trpl::sleep(one_ms).await;
            slow("b", 15);
            trpl::sleep(one_ms).await;
            slow("b", 350);
            trpl::sleep(one_ms).await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>লিস্টিং 17-24-এ, আমরা <code>slow</code>-এর প্রতিটি কলের মধ্যে await পয়েন্ট সহ <code>trpl::sleep</code> কল যোগ করি। এখন দুটি ফিউচারের কাজ ইন্টারলিভড (interleaved) বা মিশ্রিত:</p>
<!-- manual-regeneration
cd listings/ch17-async-await/listing-17-24
cargo run
copy just the output
-->
<pre><code class="language-text">'a' started.
'a' ran for 30ms
'b' started.
'b' ran for 75ms
'a' ran for 10ms
'b' ran for 10ms
'a' ran for 20ms
'b' ran for 15ms
'a' finished.
</code></pre>
<p><code>a</code> ফিউচারটি <code>b</code>-কে নিয়ন্ত্রণ হস্তান্তর করার আগে এখনও কিছুক্ষণ চলে, কারণ এটি <code>trpl::sleep</code> কল করার আগেই <code>slow</code> কল করে, কিন্তু তারপরে ফিউচারগুলি প্রতিবার যখন তাদের মধ্যে একটি await পয়েন্টে পৌঁছায় তখন অদলবদল করে। এই ক্ষেত্রে, আমরা <code>slow</code>-এর প্রতিটি কলের পরে এটি করেছি, কিন্তু আমরা কাজটি আমাদের জন্য সবচেয়ে অর্থপূর্ণ উপায়ে ভাগ করতে পারতাম।</p>
<p>তবে আমরা এখানে সত্যিই <em>স্লিপ</em> করতে চাই না: আমরা যত দ্রুত সম্ভব অগ্রগতি করতে চাই। আমাদের কেবল রানটাইমের কাছে নিয়ন্ত্রণ ফিরিয়ে দিতে হবে। আমরা এটি সরাসরি করতে পারি, <code>yield_now</code> ফাংশন ব্যবহার করে। লিস্টিং 17-25-এ, আমরা সেই সমস্ত <code>sleep</code> কলগুলিকে <code>yield_now</code> দিয়ে প্রতিস্থাপন করি।</p>
<Listing number="17-25" caption="অপারেশনগুলিকে অগ্রগতিতে স্যুইচ করার জন্য `yield_now` ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{thread, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let a = async {
            println!("'a' started.");
            slow("a", 30);
            trpl::yield_now().await;
            slow("a", 10);
            trpl::yield_now().await;
            slow("a", 20);
            trpl::yield_now().await;
            println!("'a' finished.");
        };

        let b = async {
            println!("'b' started.");
            slow("b", 75);
            trpl::yield_now().await;
            slow("b", 10);
            trpl::yield_now().await;
            slow("b", 15);
            trpl::yield_now().await;
            slow("b", 350);
            trpl::yield_now().await;
            println!("'b' finished.");
        };
<span class="boring">
</span><span class="boring">        trpl::race(a, b).await;
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn slow(name: &amp;str, ms: u64) {
</span><span class="boring">    thread::sleep(Duration::from_millis(ms));
</span><span class="boring">    println!("'{name}' ran for {ms}ms");
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>এই কোডটি প্রকৃত উদ্দেশ্য সম্পর্কে আরও স্পষ্ট এবং <code>sleep</code> ব্যবহার করার চেয়ে উল্লেখযোগ্যভাবে দ্রুত হতে পারে, কারণ <code>sleep</code> দ্বারা ব্যবহৃত টাইমারগুলির মতো টাইমারগুলির প্রায়শই তারা কতটা সূক্ষ্ম হতে পারে তার উপর সীমাবদ্ধতা থাকে। আমরা যে <code>sleep</code>-এর সংস্করণটি ব্যবহার করছি, উদাহরণস্বরূপ, এটি সর্বদা কমপক্ষে এক মিলিসেকেন্ডের জন্য ঘুমাবে, এমনকি যদি আমরা এটিকে এক ন্যানোসেকেন্ডের একটি <code>Duration</code> পাস করি। আবারও, আধুনিক কম্পিউটারগুলি <em>দ্রুত</em>: তারা এক মিলিসেকেন্ডে অনেক কিছু করতে পারে!</p>
<p>আপনি লিস্টিং 17-26-এর মতো একটি ছোট বেঞ্চমার্ক সেট আপ করে এটি নিজেই দেখতে পারেন। (এটি পারফরম্যান্স পরীক্ষা করার জন্য একটি বিশেষ কঠোর উপায় নয়, তবে এটি এখানে পার্থক্য দেখানোর জন্য যথেষ্ট।)</p>
<Listing number="17-26" caption="`sleep` এবং `yield_now`-এর পারফরম্যান্স তুলনা করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let one_ns = Duration::from_nanos(1);
        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::sleep(one_ns).await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'sleep' version finished after {} seconds.",
            time.as_secs_f32()
        );

        let start = Instant::now();
        async {
            for _ in 1..1000 {
                trpl::yield_now().await;
            }
        }
        .await;
        let time = Instant::now() - start;
        println!(
            "'yield' version finished after {} seconds.",
            time.as_secs_f32()
        );
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
</Listing>
<p>এখানে, আমরা সমস্ত স্ট্যাটাস প্রিন্টিং এড়িয়ে যাই, <code>trpl::sleep</code>-কে এক-ন্যানোসেকেন্ড <code>Duration</code> পাস করি, এবং প্রতিটি ফিউচারকে নিজে চলতে দিই, ফিউচারগুলির মধ্যে কোনো স্যুইচিং ছাড়াই। তারপরে আমরা ১,০০০ ইটারেশন চালাই এবং দেখি <code>trpl::sleep</code> ব্যবহারকারী ফিউচারটি <code>trpl::yield_now</code> ব্যবহারকারী ফিউচারের তুলনায় কত সময় নেয়।</p>
<p><code>yield_now</code> সহ সংস্করণটি <em>অনেক</em> দ্রুত!</p>
<p>এর মানে হলো যে async এমনকি কম্পিউট-বাউন্ড টাস্কগুলির জন্যও উপযোগী হতে পারে, আপনার প্রোগ্রাম আর কী করছে তার উপর নির্ভর করে, কারণ এটি প্রোগ্রামের বিভিন্ন অংশের মধ্যে সম্পর্ক কাঠামোবদ্ধ করার জন্য একটি দরকারী টুল সরবরাহ করে। এটি <em>কো-অপারেটিভ মাল্টিটাস্কিং</em> (cooperative multitasking)-এর একটি রূপ, যেখানে প্রতিটি ফিউচারের await পয়েন্টের মাধ্যমে কখন নিয়ন্ত্রণ হস্তান্তর করবে তা নির্ধারণ করার ক্ষমতা রয়েছে। তাই প্রতিটি ফিউচারেরও খুব বেশিক্ষণ ব্লক করা এড়ানোর দায়িত্ব রয়েছে। কিছু রাস্ট-ভিত্তিক এমবেডেড অপারেটিং সিস্টেমে, এটিই <em>একমাত্র</em> ধরনের মাল্টিটাস্কিং!</p>
<p>বাস্তব-জগতের কোডে, আপনি সাধারণত প্রতিটি লাইনে await পয়েন্টগুলির সাথে ফাংশন কলগুলিকে অদলবদল করবেন না, অবশ্যই। যদিও এইভাবে নিয়ন্ত্রণ হস্তান্তর করা তুলনামূলকভাবে সস্তা, এটি বিনামূল্যে নয়। অনেক ক্ষেত্রে, একটি কম্পিউট-বাউন্ড টাস্ককে ভাঙার চেষ্টা করলে এটি উল্লেখযোগ্যভাবে ধীর হতে পারে, তাই কখনও কখনও <em>সামগ্রিক</em> পারফরম্যান্সের জন্য একটি অপারেশনকে সংক্ষিপ্তভাবে ব্লক করতে দেওয়া ভালো। আপনার কোডের প্রকৃত পারফরম্যান্সের বাধাগুলি কী তা দেখতে সর্বদা পরিমাপ করুন। তবে, যদি আপনি এমন অনেক কাজ সিরিয়ালে হতে দেখেন যা আপনি কনকারেন্টলি হওয়ার আশা করেছিলেন, তবে অন্তর্নিহিত গতিশীলতাটি মনে রাখা গুরুত্বপূর্ণ!</p>
<h3 id="আমাদের-নিজসব-অযাসিঙকরোনাস-অযাবসটরযাকশন-তৈরি-করা"><a class="header" href="#আমাদের-নিজসব-অযাসিঙকরোনাস-অযাবসটরযাকশন-তৈরি-করা">আমাদের নিজস্ব অ্যাসিঙ্ক্রোনাস অ্যাবস্ট্র্যাকশন তৈরি করা</a></h3>
<p>আমরা নতুন প্যাটার্ন তৈরি করতে ফিউচারগুলিকে একসাথে কম্পোজও করতে পারি। উদাহরণস্বরূপ, আমরা আমাদের কাছে ইতিমধ্যে থাকা async বিল্ডিং ব্লকগুলি দিয়ে একটি <code>timeout</code> ফাংশন তৈরি করতে পারি। যখন আমরা শেষ করব, ফলাফলটি আরেকটি বিল্ডিং ব্লক হবে যা আমরা আরও async অ্যাবস্ট্র্যাকশন তৈরি করতে ব্যবহার করতে পারি।</p>
<p>লিস্টিং 17-27 দেখায় যে আমরা এই <code>timeout</code> একটি ধীর ফিউচারের সাথে কীভাবে কাজ করবে বলে আশা করব।</p>
<Listing number="17-27" caption="একটি সময়সীমা সহ একটি ধীর অপারেশন চালানোর জন্য আমাদের কল্পিত `timeout` ব্যবহার করা" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span>        let slow = async {
            trpl::sleep(Duration::from_millis(100)).await;
            "I finished!"
        };

        match timeout(slow, Duration::from_millis(10)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre>
</Listing>
<p>আসুন এটি ইমপ্লিমেন্ট করি! শুরু করার জন্য, আসুন <code>timeout</code>-এর API সম্পর্কে চিন্তা করি:</p>
<ul>
<li>এটি নিজে একটি async ফাংশন হতে হবে যাতে আমরা এটিকে await করতে পারি।</li>
<li>এর প্রথম প্যারামিটারটি চালানোর জন্য একটি ফিউচার হওয়া উচিত। আমরা এটিকে যেকোনো ফিউচারের সাথে কাজ করার অনুমতি দেওয়ার জন্য জেনেরিক করতে পারি।</li>
<li>এর দ্বিতীয় প্যারামিটারটি হবে অপেক্ষা করার সর্বোচ্চ সময়। যদি আমরা একটি <code>Duration</code> ব্যবহার করি, তবে এটি <code>trpl::sleep</code>-এ পাস করা সহজ হবে।</li>
<li>এটি একটি <code>Result</code> রিটার্ন করা উচিত। যদি ফিউচারটি সফলভাবে সম্পন্ন হয়, <code>Result</code>টি <code>Ok</code> হবে ফিউচার দ্বারা উৎপাদিত মান সহ। যদি টাইমআউটটি আগে শেষ হয়ে যায়, <code>Result</code>টি <code>Err</code> হবে টাইমআউটটি যে সময় অপেক্ষা করেছে সেই সময়কাল সহ।</li>
</ul>
<p>লিস্টিং 17-28 এই ডিক্লারেশনটি দেখায়।</p>
<!-- This is not tested because it intentionally does not compile. -->
<Listing number="17-28" caption="`timeout`-এর সিগনেচার সংজ্ঞায়িত করা" file-name="src/main.rs">
<pre><code class="language-rust ignore"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let slow = async {
</span><span class="boring">            trpl::sleep(Duration::from_secs(5)).await;
</span><span class="boring">            "Finally finished"
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        match timeout(slow, Duration::from_secs(2)).await {
</span><span class="boring">            Ok(message) =&gt; println!("Succeeded with '{message}'"),
</span><span class="boring">            Err(duration) =&gt; {
</span><span class="boring">                println!("Failed after {} seconds", duration.as_secs())
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span>async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    // Here is where our implementation will go!
}</code></pre>
</Listing>
<p>এটি টাইপের জন্য আমাদের লক্ষ্য পূরণ করে। এখন আসুন আমাদের প্রয়োজনীয় <em>আচরণ</em> সম্পর্কে চিন্তা করি: আমরা পাস করা ফিউচারটিকে সময়কালের বিরুদ্ধে রেস করতে চাই। আমরা সময়কাল থেকে একটি টাইমার ফিউচার তৈরি করতে <code>trpl::sleep</code> ব্যবহার করতে পারি, এবং সেই টাইমারটিকে কলারের পাস করা ফিউচারের সাথে চালানোর জন্য <code>trpl::race</code> ব্যবহার করতে পারি।</p>
<p>আমরা আরও জানি যে <code>race</code> ফেয়ার নয়, আর্গুমেন্টগুলিকে যে ক্রমে পাস করা হয় সেই ক্রমে পোল করে। সুতরাং, আমরা <code>future_to_try</code>-কে প্রথমে <code>race</code>-এ পাস করি যাতে <code>max_time</code> খুব কম সময় হলেও এটি সম্পন্ন হওয়ার সুযোগ পায়। যদি <code>future_to_try</code> প্রথমে শেষ হয়, <code>race</code> <code>future_to_try</code>-এর আউটপুট সহ <code>Left</code> রিটার্ন করবে। যদি <code>timer</code> প্রথমে শেষ হয়, <code>race</code> টাইমারের আউটপুট <code>()</code> সহ <code>Right</code> রিটার্ন করবে।</p>
<p>লিস্টিং 17-29-এ, আমরা <code>trpl::race</code> await করার ফলাফলের উপর ম্যাচ করি।</p>
<Listing number="17-29" caption="`race` এবং `sleep` দিয়ে `timeout` সংজ্ঞায়িত করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>use trpl::Either;

// --snip--

fn main() {
    trpl::run(async {
        let slow = async {
            trpl::sleep(Duration::from_secs(5)).await;
            "Finally finished"
        };

        match timeout(slow, Duration::from_secs(2)).await {
            Ok(message) =&gt; println!("Succeeded with '{message}'"),
            Err(duration) =&gt; {
                println!("Failed after {} seconds", duration.as_secs())
            }
        }
    });
}

async fn timeout&lt;F: Future&gt;(
    future_to_try: F,
    max_time: Duration,
) -&gt; Result&lt;F::Output, Duration&gt; {
    match trpl::race(future_to_try, trpl::sleep(max_time)).await {
        Either::Left(output) =&gt; Ok(output),
        Either::Right(_) =&gt; Err(max_time),
    }
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>যদি <code>future_to_try</code> সফল হয় এবং আমরা একটি <code>Left(output)</code> পাই, আমরা <code>Ok(output)</code> রিটার্ন করি। যদি স্লিপ টাইমারটি পরিবর্তে শেষ হয়ে যায় এবং আমরা একটি <code>Right(())</code> পাই, আমরা <code>_</code> দিয়ে <code>()</code> উপেক্ষা করি এবং পরিবর্তে <code>Err(max_time)</code> রিটার্ন করি।</p>
<p>এর সাথে, আমাদের কাছে দুটি অন্য async হেল্পার দিয়ে তৈরি একটি কার্যকরী <code>timeout</code> আছে। যদি আমরা আমাদের কোড চালাই, এটি টাইমআউটের পরে ব্যর্থতার মোড প্রিন্ট করবে:</p>
<pre><code class="language-text">Failed after 2 seconds
</code></pre>
<p>যেহেতু ফিউচারগুলি অন্য ফিউচারের সাথে কম্পোজ করে, আপনি ছোট async বিল্ডিং ব্লক ব্যবহার করে সত্যিই শক্তিশালী টুল তৈরি করতে পারেন। উদাহরণস্বরূপ, আপনি রিট্রাইয়ের সাথে টাইমআউট একত্রিত করতে এই একই পদ্ধতি ব্যবহার করতে পারেন, এবং পরিবর্তে সেগুলি নেটওয়ার্ক কলের মতো অপারেশনের সাথে ব্যবহার করতে পারেন (অধ্যায়ের শুরুর উদাহরণগুলির মধ্যে একটি)।</p>
<p>বাস্তবে, আপনি সাধারণত সরাসরি <code>async</code> এবং <code>await</code>-এর সাথে কাজ করবেন, এবং দ্বিতীয়ত <code>join</code>, <code>join_all</code>, <code>race</code>, এবং আরও অনেক ফাংশন এবং ম্যাক্রোর সাথে কাজ করবেন। আপনাকে শুধুমাত্র সেই API-গুলির সাথে ফিউচার ব্যবহার করার জন্য মাঝে মাঝে <code>pin</code>-এর প্রয়োজন হবে।</p>
<p>আমরা এখন একই সময়ে একাধিক ফিউচারের সাথে কাজ করার বেশ কয়েকটি উপায় দেখেছি। এরপরে, আমরা দেখব কীভাবে আমরা সময়ের সাথে সাথে <em>স্ট্রিম</em> (streams) দিয়ে একটি ক্রমানুসারে একাধিক ফিউচারের সাথে কাজ করতে পারি। তবে, প্রথমে আপনার বিবেচনা করার মতো আরও কয়েকটি বিষয় এখানে রয়েছে:</p>
<ul>
<li>
<p>কোনো গ্রুপের সমস্ত ফিউচার শেষ হওয়ার জন্য অপেক্ষা করতে আমরা <code>join_all</code>-এর সাথে একটি <code>Vec</code> ব্যবহার করেছি। আপনি কীভাবে একটি <code>Vec</code> ব্যবহার করে ফিউচারের একটি গ্রুপকে ক্রমানুসারে প্রসেস করতে পারেন? এটি করার ট্রেড-অফগুলি কী কী?</p>
</li>
<li>
<p><code>futures</code> ক্রেট থেকে <code>futures::stream::FuturesUnordered</code> টাইপটি দেখুন। এটি ব্যবহার করা একটি <code>Vec</code> ব্যবহার করার থেকে কীভাবে ভিন্ন হবে? (ক্রেটের <code>stream</code> অংশ থেকে এটি এসেছে এই সত্যটি নিয়ে চিন্তা করবেন না; এটি যেকোনো ফিউচারের কালেকশনের সাথে ঠিকঠাক কাজ করে।)</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-02-concurrency-with-async.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-04-streams.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-02-concurrency-with-async.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-04-streams.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
