<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>স্ট্রিং দিয়ে UTF-8 এনকোডেড টেক্সট সংরক্ষণ - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="সটরিং-বযবহার-করে-utf-8-এনকোডেড-টেকসট-সটোর-করা"><a class="header" href="#সটরিং-বযবহার-করে-utf-8-এনকোডেড-টেকসট-সটোর-করা">স্ট্রিং ব্যবহার করে UTF-8 এনকোডেড টেক্সট স্টোর করা</a></h2>
<p>আমরা অধ্যায় ৪-এ স্ট্রিং নিয়ে আলোচনা করেছি, কিন্তু এখন আমরা এটি আরও গভীরভাবে দেখব। নতুন Rust ব্যবহারকারীরা সাধারণত তিনটি কারণে স্ট্রিং নিয়ে সমস্যায় পড়েন: সম্ভাব্য error তুলে ধরার ক্ষেত্রে Rust-এর প্রবণতা, স্ট্রিং ডেটা স্ট্রাকচারটি যতটা সহজ ভাবা হয় তার চেয়ে বেশি জটিল হওয়া, এবং UTF-8। এই কারণগুলো একত্রিত হয়ে এমন পরিস্থিতি তৈরি করে যা অন্যান্য প্রোগ্রামিং ল্যাঙ্গুয়েজ থেকে আসা ডেভেলপারদের জন্য কঠিন মনে হতে পারে।</p>
<p>আমরা collections-এর প্রেক্ষাপটে স্ট্রিং নিয়ে আলোচনা করছি কারণ স্ট্রিং মূলত বাইটের (bytes) একটি collection হিসাবে প্রয়োগ করা হয়, এবং এর সাথে কিছু অতিরিক্ত মেথড থাকে যা সেই বাইটগুলোকে টেক্সট হিসাবে ব্যাখ্যা করার সময় দরকারি কার্যকারিতা প্রদান করে। এই বিভাগে, আমরা <code>String</code>-এর সেইসব অপারেশন নিয়ে কথা বলব যা প্রতিটি collection টাইপের মধ্যেই রয়েছে, যেমন তৈরি করা, আপডেট করা এবং পড়া। এছাড়াও আমরা আলোচনা করব <code>String</code> অন্যান্য collection থেকে কোন কোন ক্ষেত্রে আলাদা, বিশেষ করে মানুষ এবং কম্পিউটার যেভাবে <code>String</code> ডেটাকে ব্যাখ্যা করে তার পার্থক্যের কারণে <code>String</code>-এ ইনডেক্সিং (indexing) করাটা বেশ জটিল।</p>
<h3 id="সটরিং-কী"><a class="header" href="#সটরিং-কী">স্ট্রিং কী?</a></h3>
<p>প্রথমে আমরা <em>স্ট্রিং</em> বলতে কী বুঝি তা নির্ধারণ করব। Rust-এর কোর ল্যাঙ্গুয়েজে শুধুমাত্র একটি স্ট্রিং টাইপ আছে, যা হলো স্ট্রিং স্লাইস <code>str</code>, এবং এটি সাধারণত এর ধার করা (borrowed) রূপ <code>&amp;str</code>-এ দেখা যায়। অধ্যায় ৪-এ, আমরা <em>স্ট্রিং স্লাইস</em> নিয়ে কথা বলেছিলাম, যা অন্য কোথাও স্টোর করা UTF-8 এনকোডেড স্ট্রিং ডেটার রেফারেন্স। উদাহরণস্বরূপ, স্ট্রিং লিটারেল (string literals) প্রোগ্রামের বাইনারিতে স্টোর করা হয় এবং তাই সেগুলি স্ট্রিং স্লাইস।</p>
<p><code>String</code> টাইপটি Rust-এর standard library দ্বারা সরবরাহ করা হয়, এটি কোর ল্যাঙ্গুয়েজে কোড করা নেই। এটি একটি পরিবর্তনশীল (growable), পরিবর্তনযোগ্য (mutable), নিজস্ব (owned), এবং UTF-8 এনকোডেড স্ট্রিং টাইপ। যখন Rust ব্যবহারকারীরা "স্ট্রিং" বলেন, তখন তারা <code>String</code> বা স্ট্রিং স্লাইস <code>&amp;str</code> উভয়কেই বোঝাতে পারেন, শুধু একটিকে নয়। যদিও এই বিভাগটি মূলত <code>String</code> সম্পর্কিত, উভয় টাইপই Rust-এর standard library-তে ব্যাপকভাবে ব্যবহৃত হয় এবং <code>String</code> ও স্ট্রিং স্লাইস উভয়ই UTF-8 এনকোডেড।</p>
<h3 id="নতুন-সটরিং-তৈরি-করা"><a class="header" href="#নতুন-সটরিং-তৈরি-করা">নতুন স্ট্রিং তৈরি করা</a></h3>
<p><code>Vec&lt;T&gt;</code>-এর সাথে উপলব্ধ অনেক অপারেশন <code>String</code>-এর সাথেও উপলব্ধ, কারণ <code>String</code> আসলে বাইটের একটি vector-এর উপর একটি র‍্যাপার (wrapper) হিসাবে প্রয়োগ করা হয়েছে, যাতে কিছু অতিরিক্ত গ্যারান্টি, সীমাবদ্ধতা এবং ক্ষমতা রয়েছে। <code>Vec&lt;T&gt;</code> এবং <code>String</code>-এর সাথে একইভাবে কাজ করে এমন একটি ফাংশনের উদাহরণ হলো <code>new</code> ফাংশন, যা একটি ইনস্ট্যান্স তৈরি করতে ব্যবহৃত হয়, যেমনটি লিস্টিং ৮-১১-তে দেখানো হয়েছে।</p>
<Listing number="8-11" caption="একটি নতুন, খালি `String` তৈরি করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::new();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>এই লাইনটি <code>s</code> নামে একটি নতুন, খালি স্ট্রিং তৈরি করে, যেখানে আমরা পরে ডেটা লোড করতে পারব। প্রায়শই, আমাদের কাছে কিছু প্রাথমিক ডেটা থাকে যা দিয়ে আমরা স্ট্রিং শুরু করতে চাই। এর জন্য, আমরা <code>to_string</code> মেথড ব্যবহার করি, যা <code>Display</code> trait প্রয়োগকারী যেকোনো টাইপের উপর উপলব্ধ, যেমন স্ট্রিং লিটারেল। লিস্টিং ৮-১২ দুটি উদাহরণ দেখায়।</p>
<Listing number="8-12" caption="স্ট্রিং লিটারেল থেকে `String` তৈরি করতে `to_string` মেথড ব্যবহার করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let data = "initial contents";

    let s = data.to_string();

    // The method also works on a literal directly:
    let s = "initial contents".to_string();
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>এই কোডটি <code>initial contents</code> লেখা সহ একটি স্ট্রিং তৈরি করে।</p>
<p>আমরা <code>String::from</code> ফাংশন ব্যবহার করেও একটি স্ট্রিং লিটারেল থেকে <code>String</code> তৈরি করতে পারি। লিস্টিং ৮-১৩-এর কোডটি লিস্টিং ৮-১২-এর কোডের সমতুল্য যা <code>to_string</code> ব্যবহার করে।</p>
<Listing number="8-13" caption="স্ট্রিং লিটারেল থেকে `String` তৈরি করতে `String::from` ফাংশন ব্যবহার করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s = String::from("initial contents");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>যেহেতু স্ট্রিং অনেক কিছুর জন্য ব্যবহৃত হয়, আমরা স্ট্রিং-এর জন্য বিভিন্ন জেনেরিক API ব্যবহার করতে পারি, যা আমাদের অনেক বিকল্প সরবরাহ করে। তাদের মধ্যে কিছু অপ্রয়োজনীয় মনে হতে পারে, কিন্তু সবগুলোরই নিজস্ব স্থান আছে! এক্ষেত্রে, <code>String::from</code> এবং <code>to_string</code> একই কাজ করে, তাই আপনি কোনটি বেছে নেবেন তা আপনার স্টাইল এবং পঠনযোগ্যতার উপর নির্ভর করে।</p>
<p>মনে রাখবেন যে স্ট্রিংগুলো UTF-8 এনকোডেড, তাই আমরা সেগুলিতে যেকোনো সঠিকভাবে এনকোড করা ডেটা অন্তর্ভুক্ত করতে পারি, যেমনটি লিস্টিং ৮-১৪-তে দেখানো হয়েছে।</p>
<Listing number="8-14" caption="বিভিন্ন ভাষায় শুভেচ্ছা স্ট্রিং-এ স্টোর করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שלום");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>এগুলো সবই বৈধ <code>String</code> ভ্যালু।</p>
<h3 id="একটি-সটরিং-আপডেট-করা"><a class="header" href="#একটি-সটরিং-আপডেট-করা">একটি স্ট্রিং আপডেট করা</a></h3>
<p>একটি <code>String</code>-এর আকার বাড়তে পারে এবং এর বিষয়বস্তু পরিবর্তন হতে পারে, যেমন <code>Vec&lt;T&gt;</code>-এর বিষয়বস্তু পরিবর্তন করা যায়, যদি আপনি এতে আরও ডেটা পুশ করেন। এছাড়াও, আপনি সুবিধামত <code>+</code> অপারেটর বা <code>format!</code> ম্যাক্রো ব্যবহার করে <code>String</code> ভ্যালু সংযুক্ত (concatenate) করতে পারেন।</p>
<h4 id="push_str-এবং-push-দিযে-একটি-সটরিং-এ-যোগ-করা"><a class="header" href="#push_str-এবং-push-দিযে-একটি-সটরিং-এ-যোগ-করা"><code>push_str</code> এবং <code>push</code> দিয়ে একটি স্ট্রিং-এ যোগ করা</a></h4>
<p>আমরা <code>push_str</code> মেথড ব্যবহার করে একটি স্ট্রিং স্লাইস যোগ করে একটি <code>String</code> বড় করতে পারি, যেমনটি লিস্টিং ৮-১৫-তে দেখানো হয়েছে।</p>
<Listing number="8-15" caption="`push_str` মেথড ব্যবহার করে একটি `String`-এ স্ট্রিং স্লাইস যোগ করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("foo");
    s.push_str("bar");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>এই দুটি লাইনের পরে, <code>s</code>-এ <code>foobar</code> থাকবে। <code>push_str</code> মেথডটি একটি স্ট্রিং স্লাইস নেয় কারণ আমরা প্যারামিটারের মালিকানা (ownership) নিতে চাই না। উদাহরণস্বরূপ, লিস্টিং ৮-১৬-এর কোডে, আমরা <code>s1</code>-এ <code>s2</code>-এর বিষয়বস্তু যোগ করার পরেও <code>s2</code> ব্যবহার করতে চাই।</p>
<Listing number="8-16" caption="একটি `String`-এ এর বিষয়বস্তু যোগ করার পরে একটি স্ট্রিং স্লাইস ব্যবহার করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(s2);
    println!("s2 is {s2}");
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>যদি <code>push_str</code> মেথডটি <code>s2</code>-এর মালিকানা নিয়ে নিত, আমরা শেষ লাইনে এর ভ্যালু প্রিন্ট করতে পারতাম না। কিন্তু এই কোডটি আমাদের প্রত্যাশা অনুযায়ী কাজ করে!</p>
<p><code>push</code> মেথডটি একটি একক ক্যারেক্টার (character) প্যারামিটার হিসাবে নেয় এবং এটি <code>String</code>-এ যোগ করে। লিস্টিং ৮-১৭ <code>push</code> মেথড ব্যবহার করে একটি <code>String</code>-এ <em>l</em> অক্ষরটি যোগ করে।</p>
<Listing number="8-17" caption="`push` ব্যবহার করে একটি `String` ভ্যালুতে একটি ক্যারেক্টার যোগ করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let mut s = String::from("lo");
    s.push('l');
<span class="boring">}</span></code></pre></pre>
</Listing>
<p>এর ফলে, <code>s</code>-এ <code>lol</code> থাকবে।</p>
<h4 id="-অপারেটর-বা-format-মযাকরো-দিযে-concatenation"><a class="header" href="#-অপারেটর-বা-format-মযাকরো-দিযে-concatenation"><code>+</code> অপারেটর বা <code>format!</code> ম্যাক্রো দিয়ে Concatenation</a></h4>
<p>প্রায়শই, আপনি দুটি বিদ্যমান স্ট্রিং একত্রিত করতে চাইবেন। একটি উপায় হলো <code>+</code> অপারেটর ব্যবহার করা, যেমনটি লিস্টিং ৮-১৮-তে দেখানো হয়েছে।</p>
<Listing number="8-18" caption="দুটি `String` ভ্যালু একত্রিত করে একটি নতুন `String` ভ্যালু তৈরি করতে `+` অপারেটর ব্যবহার করা">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}</span></code></pre></pre>
</Listing>
<p><code>s3</code> স্ট্রিংটিতে <code>Hello, world!</code> থাকবে। <code>s1</code> যোগ করার পরে আর বৈধ থাকে না এবং আমরা <code>s2</code>-এর একটি রেফারেন্স ব্যবহার করেছি, এর কারণটি সেই মেথডের সিগনেচারের সাথে সম্পর্কিত যা <code>+</code> অপারেটর ব্যবহার করার সময় কল করা হয়। <code>+</code> অপারেটরটি <code>add</code> মেথড ব্যবহার করে, যার সিগনেচারটি প্রায় এরকম:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {</code></pre>
<p>Standard library-তে, আপনি <code>add</code> মেথডটি জেনেরিক এবং অ্যাসোসিয়েটেড টাইপ ব্যবহার করে সংজ্ঞায়িত দেখতে পাবেন। এখানে, আমরা সুনির্দিষ্ট টাইপ ব্যবহার করেছি, যা ঘটে যখন আমরা <code>String</code> ভ্যালু দিয়ে এই মেথডটি কল করি। আমরা অধ্যায় ১০-এ জেনেরিক নিয়ে আলোচনা করব। এই সিগনেচারটি আমাদের <code>+</code> অপারেটরের জটিল অংশগুলো বোঝার জন্য প্রয়োজনীয় সূত্র দেয়।</p>
<p>প্রথমত, <code>s2</code>-এর একটি <code>&amp;</code> আছে, যার মানে আমরা প্রথম স্ট্রিং-এর সাথে দ্বিতীয় স্ট্রিং-এর একটি <em>রেফারেন্স</em> যোগ করছি। এটি <code>add</code> ফাংশনের <code>s</code> প্যারামিটারের কারণে: আমরা শুধুমাত্র একটি <code>&amp;str</code> একটি <code>String</code>-এ যোগ করতে পারি; আমরা দুটি <code>String</code> ভ্যালু একসাথে যোগ করতে পারি না। কিন্তু অপেক্ষা করুন—<code>&amp;s2</code>-এর টাইপ হলো <code>&amp;String</code>, <code>&amp;str</code> নয়, যেমনটি <code>add</code>-এর দ্বিতীয় প্যারামিটারে নির্দিষ্ট করা আছে। তাহলে লিস্টিং ৮-১৮ কেন কম্পাইল হয়?</p>
<p><code>add</code> কলে <code>&amp;s2</code> ব্যবহার করতে পারার কারণ হলো কম্পাইলার <code>&amp;String</code> আর্গুমেন্টটিকে একটি <code>&amp;str</code>-এ <em>coerce</em> (রূপান্তর) করতে পারে। যখন আমরা <code>add</code> মেথডটি কল করি, Rust একটি <em>deref coercion</em> ব্যবহার করে, যা এখানে <code>&amp;s2</code>-কে <code>&amp;s2[..]</code>-তে পরিণত করে। আমরা অধ্যায় ১৫-এ deref coercion নিয়ে আরও বিস্তারিত আলোচনা করব। যেহেতু <code>add</code> <code>s</code> প্যারামিটারের মালিকানা নেয় না, তাই এই অপারেশনের পরেও <code>s2</code> একটি বৈধ <code>String</code> থাকবে।</p>
<p>দ্বিতীয়ত, আমরা সিগনেচারে দেখতে পাচ্ছি যে <code>add</code> <code>self</code>-এর মালিকানা নেয় কারণ <code>self</code>-এর আগে <code>&amp;</code> নেই। এর মানে লিস্টিং ৮-১৮-এর <code>s1</code> <code>add</code> কলের মধ্যে মুভ (move) হয়ে যাবে এবং তারপরে আর বৈধ থাকবে না। সুতরাং, যদিও <code>let s3 = s1 + &amp;s2;</code> দেখে মনে হচ্ছে এটি উভয় স্ট্রিং কপি করে একটি নতুন তৈরি করবে, এই স্টেটমেন্টটি আসলে <code>s1</code>-এর মালিকানা নেয়, <code>s2</code>-এর বিষয়বস্তুর একটি কপি যোগ করে এবং তারপর ফলাফলের মালিকানা ফেরত দেয়। অন্য কথায়, এটি দেখতে অনেক কপি করার মতো মনে হলেও, এর বাস্তবায়ন কপি করার চেয়ে অনেক বেশি কার্যকর।</p>
<p>যদি আমাদের একাধিক স্ট্রিং যুক্ত করতে হয়, তাহলে <code>+</code> অপারেটরের ব্যবহার বেশ громоздким (unwieldy) হয়ে যায়:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = s1 + "-" + &amp;s2 + "-" + &amp;s3;
<span class="boring">}</span></code></pre></pre>
<p>এই মুহুর্তে, <code>s</code> হবে <code>tic-tac-toe</code>। এতগুলো <code>+</code> এবং <code>"</code> অক্ষরের কারণে কী ঘটছে তা বোঝা কঠিন। আরও জটিল উপায়ে স্ট্রিং একত্রিত করার জন্য, আমরা এর পরিবর্তে <code>format!</code> ম্যাক্রো ব্যবহার করতে পারি:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span>    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{s1}-{s2}-{s3}");
<span class="boring">}</span></code></pre></pre>
<p>এই কোডটি <code>s</code>-কে <code>tic-tac-toe</code>-তে সেট করে। <code>format!</code> ম্যাক্রো <code>println!</code>-এর মতো কাজ করে, কিন্তু আউটপুট স্ক্রিনে প্রিন্ট করার পরিবর্তে, এটি বিষয়বস্তুসহ একটি <code>String</code> ফেরত দেয়। <code>format!</code> ব্যবহার করা কোডের সংস্করণটি পড়া অনেক সহজ, এবং <code>format!</code> ম্যাক্রো দ্বারা তৈরি কোড রেফারেন্স ব্যবহার করে যাতে এই কলটি তার কোনো প্যারামিটারের মালিকানা না নেয়।</p>
<h3 id="সটরিং-এ-ইনডেকসিং"><a class="header" href="#সটরিং-এ-ইনডেকসিং">স্ট্রিং-এ ইনডেক্সিং</a></h3>
<p>অন্যান্য অনেক প্রোগ্রামিং ল্যাঙ্গুয়েজে, ইনডেক্স দ্বারা একটি স্ট্রিং-এর স্বতন্ত্র অক্ষর অ্যাক্সেস করা একটি বৈধ এবং সাধারণ অপারেশন। যাইহোক, আপনি যদি Rust-এ ইনডেক্সিং সিনট্যাক্স ব্যবহার করে একটি <code>String</code>-এর অংশ অ্যাক্সেস করার চেষ্টা করেন, আপনি একটি এরর পাবেন। লিস্টিং ৮-১৯-এর অবৈধ কোডটি বিবেচনা করুন।</p>
<Listing number="8-19" caption="একটি String-এর সাথে ইনডেক্সিং সিনট্যাক্স ব্যবহার করার চেষ্টা">
<pre><code class="language-rust ignore does_not_compile"><span class="boring">fn main() {
</span>    let s1 = String::from("hi");
    let h = s1[0];
<span class="boring">}</span></code></pre>
</Listing>
<p>এই কোডটি নিম্নলিখিত এরর দেবে:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `str` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:16
  |
3 |     let h = s1[0];
  |                ^ string indices are ranges of `usize`
  |
  = note: you can use `.chars().nth()` or `.bytes().nth()`
          for more information, see chapter 8 in The Book: &lt;https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings&gt;
  = help: the trait `SliceIndex&lt;str&gt;` is not implemented for `{integer}`
          but trait `SliceIndex&lt;[_]&gt;` is implemented for `usize`
  = help: for that trait implementation, expected `[_]`, found `str`
  = note: required for `String` to implement `Index&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections` (bin "collections") due to 1 previous error
</code></pre>
<p>এরর এবং নোটটি পুরো গল্পটি বলে দেয়: Rust স্ট্রিং ইনডেক্সিং সমর্থন করে না। কিন্তু কেন নয়? এই প্রশ্নের উত্তর দিতে, আমাদের আলোচনা করতে হবে Rust কীভাবে মেমরিতে স্ট্রিং স্টোর করে।</p>
<h4 id="অভযনতরীণ-উপসথাপনা-internal-representation"><a class="header" href="#অভযনতরীণ-উপসথাপনা-internal-representation">অভ্যন্তরীণ উপস্থাপনা (Internal Representation)</a></h4>
<p>একটি <code>String</code> হলো <code>Vec&lt;u8&gt;</code>-এর উপর একটি র‍্যাপার। আসুন লিস্টিং ৮-১৪ থেকে আমাদের সঠিকভাবে এনকোড করা UTF-8 উদাহরণ স্ট্রিংগুলির কিছু দেখি। প্রথমত, এটি:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span><span class="boring">    let hello = String::from("Здравствуйте");
</span>    let hello = String::from("Hola");
<span class="boring">}</span></code></pre></pre>
<p>এই ক্ষেত্রে, <code>len</code> হবে <code>4</code>, যার মানে <code>"Hola"</code> স্ট্রিংটি স্টোর করা ভেক্টরটি ৪ বাইট দীর্ঘ। UTF-8-এ এনকোড করার সময় এই অক্ষরগুলির প্রতিটি এক বাইট করে জায়গা নেয়। তবে, নিম্নলিখিত লাইনটি আপনাকে অবাক করতে পারে (লক্ষ্য করুন যে এই স্ট্রিংটি ক্যাপিটাল সিরিলিক অক্ষর <em>Ze</em> দিয়ে শুরু হয়, সংখ্যা 3 দিয়ে নয়):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {
</span><span class="boring">    let hello = String::from("السلام عليكم");
</span><span class="boring">    let hello = String::from("Dobrý den");
</span><span class="boring">    let hello = String::from("Hello");
</span><span class="boring">    let hello = String::from("שלום");
</span><span class="boring">    let hello = String::from("नमस्ते");
</span><span class="boring">    let hello = String::from("こんにちは");
</span><span class="boring">    let hello = String::from("안녕하세요");
</span><span class="boring">    let hello = String::from("你好");
</span><span class="boring">    let hello = String::from("Olá");
</span>    let hello = String::from("Здравствуйте");
<span class="boring">    let hello = String::from("Hola");
</span><span class="boring">}</span></code></pre></pre>
<p>আপনাকে যদি জিজ্ঞাসা করা হয় স্ট্রিংটি কত দীর্ঘ, আপনি হয়তো বলবেন ১২। আসলে, Rust-এর উত্তর হলো ২৪: এটি "Здравствуйте" শব্দটি UTF-8-এ এনকোড করতে প্রয়োজনীয় বাইটের সংখ্যা, কারণ সেই স্ট্রিং-এর প্রতিটি ইউনিকোড স্কেলার ভ্যালু ২ বাইট স্টোরেজ নেয়। অতএব, স্ট্রিং-এর বাইটগুলিতে একটি ইনডেক্স সবসময় একটি বৈধ ইউনিকোড স্কেলার ভ্যালুর সাথে মিলবে না। এটি দেখানোর জন্য, এই অবৈধ Rust কোডটি বিবেচনা করুন:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = "Здравствуйте";
let answer = &amp;hello[0];</code></pre>
<p>আপনি ಈಗಾಗಲೇ জানেন যে <code>answer</code> <code>З</code> হবে না, যা প্রথম অক্ষর। UTF-8-এ এনকোড করা হলে, <code>З</code>-এর প্রথম বাইট হলো <code>208</code> এবং দ্বিতীয়টি হলো <code>151</code>, তাই মনে হতে পারে যে <code>answer</code> আসলে <code>208</code> হওয়া উচিত, কিন্তু <code>208</code> নিজে থেকে একটি বৈধ অক্ষর নয়। যদি কেউ এই স্ট্রিংয়ের প্রথম অক্ষরের জন্য জিজ্ঞাসা করে তবে <code>208</code> ফেরত দেওয়া সম্ভবত ব্যবহারকারীর কাঙ্ক্ষিত হবে না; তবে, বাইট ইনডেক্স ০-তে Rust-এর কাছে কেবল এই ডেটাই আছে। ব্যবহারকারীরা সাধারণত বাইট ভ্যালু ফেরত চান না, এমনকি যদি স্ট্রিংটিতে শুধুমাত্র ল্যাটিন অক্ষর থাকে: যদি <code>&amp;"hi"[0]</code> বৈধ কোড হতো যা বাইট ভ্যালু ফেরত দিত, তবে এটি <code>h</code>-এর পরিবর্তে <code>104</code> ফেরত দিত।</p>
<p>উত্তরটি হলো, একটি অপ্রত্যাশিত মান ফেরত দেওয়া এবং এমন বাগ তৈরি করা এড়াতে যা অবিলম্বে আবিষ্কৃত নাও হতে পারে, Rust এই কোডটি মোটেই কম্পাইল করে না এবং ডেভেলপমেন্ট প্রক্রিয়ার শুরুতেই ভুল বোঝাবুঝি প্রতিরোধ করে।</p>
<h4 id="বাইট-সকেলার-ভযালু-এবং-গরাফিম-কলাসটার-এলাহি-কাণড"><a class="header" href="#বাইট-সকেলার-ভযালু-এবং-গরাফিম-কলাসটার-এলাহি-কাণড">বাইট, স্কেলার ভ্যালু এবং গ্রাফিম ক্লাস্টার! এলাহি কাণ্ড!</a></h4>
<p>UTF-8 সম্পর্কে আরেকটি বিষয় হলো যে Rust-এর দৃষ্টিকোণ থেকে স্ট্রিং দেখার তিনটি প্রাসঙ্গিক উপায় রয়েছে: বাইট হিসাবে, স্কেলার ভ্যালু হিসাবে, এবং গ্রাফিম ক্লাস্টার হিসাবে (যাকে আমরা <em>অক্ষর</em> বলি তার সবচেয়ে কাছের জিনিস)।</p>
<p>যদি আমরা দেবনাগরী লিপিতে লেখা হিন্দি শব্দ "नमस्ते" দেখি, এটি <code>u8</code> ভ্যালুর একটি ভেক্টর হিসাবে স্টোর করা হয় যা দেখতে এইরকম:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>এটি ১৮ বাইট এবং কম্পিউটারগুলি এভাবেই ডেটা সঞ্চয় করে। যদি আমরা এগুলিকে ইউনিকোড স্কেলার ভ্যালু হিসাবে দেখি, যা Rust-এর <code>char</code> টাইপ, তবে সেই বাইটগুলি দেখতে এইরকম:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>এখানে ছয়টি <code>char</code> ভ্যালু রয়েছে, কিন্তু চতুর্থ এবং ষষ্ঠটি অক্ষর নয়: সেগুলি ডায়াক্রিটিক যা নিজে থেকে অর্থপূর্ণ নয়। অবশেষে, যদি আমরা এগুলিকে গ্রাফিম ক্লাস্টার হিসাবে দেখি, তবে আমরা সেই চারটি অক্ষর পাব যা একজন ব্যক্তি হিন্দি শব্দটি তৈরি করতে ব্যবহার করবে:</p>
<pre><code class="language-text">["न", "म", "स्", "ते"]
</code></pre>
<p>Rust কম্পিউটার দ্বারা সংরক্ষিত কাঁচা স্ট্রিং ডেটা ব্যাখ্যা করার বিভিন্ন উপায় সরবরাহ করে যাতে প্রতিটি প্রোগ্রাম তার প্রয়োজনীয় ব্যাখ্যা বেছে নিতে পারে, ডেটা যে কোনো মানব ভাষায়ই হোক না কেন।</p>
<p>Rust আমাদের একটি অক্ষর পেতে একটি <code>String</code>-এ ইনডেক্স করার অনুমতি না দেওয়ার একটি চূড়ান্ত কারণ হলো যে ইনডেক্সিং অপারেশনগুলি সর্বদা ধ্রুবক সময়ে (O(1)) সম্পন্ন হবে বলে আশা করা হয়। কিন্তু একটি <code>String</code>-এর সাথে সেই পারফরম্যান্সের গ্যারান্টি দেওয়া সম্ভব নয়, কারণ Rust-কে শুরু থেকে ইনডেক্স পর্যন্ত বিষয়বস্তুর মধ্যে দিয়ে হেঁটে যেতে হবে কতগুলি বৈধ অক্ষর ছিল তা নির্ধারণ করার জন্য।</p>
<h3 id="সটরিং-সলাইস-করা"><a class="header" href="#সটরিং-সলাইস-করা">স্ট্রিং স্লাইস করা</a></h3>
<p>একটি স্ট্রিং-এ ইনডেক্স করা প্রায়শই একটি খারাপ ধারণা কারণ এটি স্পষ্ট নয় যে স্ট্রিং-ইনডেক্সিং অপারেশনের রিটার্ন টাইপ কী হওয়া উচিত: একটি বাইট ভ্যালু, একটি অক্ষর, একটি গ্রাফিম ক্লাস্টার, বা একটি স্ট্রিং স্লাইস। অতএব, যদি আপনার সত্যিই স্ট্রিং স্লাইস তৈরি করার জন্য ইনডেক্স ব্যবহার করার প্রয়োজন হয়, Rust আপনাকে আরও নির্দিষ্ট হতে বলে।</p>
<p>একটি একক সংখ্যা দিয়ে <code>[]</code> ব্যবহার করে ইনডেক্স করার পরিবর্তে, আপনি নির্দিষ্ট বাইট ধারণকারী একটি স্ট্রিং স্লাইস তৈরি করতে একটি পরিসীমা (range) সহ <code>[]</code> ব্যবহার করতে পারেন:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "Здравствуйте";

let s = &amp;hello[0..4];
<span class="boring">}</span></code></pre></pre>
<p>এখানে, <code>s</code> একটি <code>&amp;str</code> হবে যা স্ট্রিং-এর প্রথম চারটি বাইট ধারণ করে। আগে, আমরা উল্লেখ করেছি যে এই অক্ষরগুলির প্রতিটি দুই বাইট করে ছিল, যার মানে <code>s</code> হবে <code>Зд</code>।</p>
<p>যদি আমরা <code>&amp;hello[0..1]</code>-এর মতো কিছু দিয়ে একটি অক্ষরের বাইটের কেবল একটি অংশ স্লাইস করার চেষ্টা করতাম, তাহলে Rust রানটাইমে প্যানিক করত, যেমন একটি ভেক্টরে একটি অবৈধ ইনডেক্স অ্যাক্সেস করা হলে হয়:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`

thread 'main' panicked at src/main.rs:4:19:
byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>রেঞ্জ ব্যবহার করে স্ট্রিং স্লাইস তৈরি করার সময় আপনার সতর্কতা অবলম্বন করা উচিত, কারণ এটি আপনার প্রোগ্রাম ক্র্যাশ করতে পারে।</p>
<h3 id="সটরিং-এর-উপর-ইটারেট-করার-মেথড"><a class="header" href="#সটরিং-এর-উপর-ইটারেট-করার-মেথড">স্ট্রিং-এর উপর ইটারেট করার মেথড</a></h3>
<p>স্ট্রিং-এর অংশে কাজ করার সেরা উপায় হলো আপনি অক্ষর চান নাকি বাইট চান সে সম্পর্কে স্পষ্ট হওয়া। স্বতন্ত্র ইউনিকোড স্কেলার ভ্যালুর জন্য, <code>chars</code> মেথড ব্যবহার করুন। "Зд"-এর উপর <code>chars</code> কল করা হলে এটি দুটি <code>char</code> টাইপের ভ্যালু আলাদা করে ফেরত দেয়, এবং আপনি প্রতিটি এলিমেন্ট অ্যাক্সেস করতে ফলাফলের উপর ইটারেট করতে পারেন:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for c in "Зд".chars() {
    println!("{c}");
}
<span class="boring">}</span></code></pre></pre>
<p>এই কোডটি নিম্নলিখিত আউটপুট প্রিন্ট করবে:</p>
<pre><code class="language-text">З
д
</code></pre>
<p>বিকল্পভাবে, <code>bytes</code> মেথড প্রতিটি কাঁচা বাইট ফেরত দেয়, যা আপনার ডোমেনের জন্য উপযুক্ত হতে পারে:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for b in "Зд".bytes() {
    println!("{b}");
}
<span class="boring">}</span></code></pre></pre>
<p>এই কোডটি এই স্ট্রিংটি গঠনকারী চারটি বাইট প্রিন্ট করবে:</p>
<pre><code class="language-text">208
151
208
180
</code></pre>
<p>তবে মনে রাখতে ভুলবেন না যে বৈধ ইউনিকোড স্কেলার ভ্যালু একাধিক বাইট দিয়ে গঠিত হতে পারে।</p>
<p>দেবনাগরী লিপির মতো স্ট্রিং থেকে গ্রাফিম ক্লাস্টার পাওয়া জটিল, তাই এই কার্যকারিতা standard library দ্বারা সরবরাহ করা হয় না। যদি আপনার এই কার্যকারিতার প্রয়োজন হয়, তাহলে <a href="https://crates.io/">crates.io</a><!-- ignore -->-তে ক্রেট উপলব্ধ আছে।</p>
<h3 id="সটরিং-অতটা-সহজ-নয"><a class="header" href="#সটরিং-অতটা-সহজ-নয">স্ট্রিং অতটা সহজ নয়</a></h3>
<p>সংক্ষেপে, স্ট্রিং বেশ জটিল। বিভিন্ন প্রোগ্রামিং ল্যাঙ্গুয়েজ প্রোগ্রামারদের কাছে এই জটিলতা কীভাবে উপস্থাপন করা হবে সে সম্পর্কে বিভিন্ন সিদ্ধান্ত নেয়। Rust <code>String</code> ডেটার সঠিক হ্যান্ডলিং-কে সমস্ত Rust প্রোগ্রামের জন্য ডিফল্ট আচরণ হিসাবে বেছে নিয়েছে, যার মানে প্রোগ্রামারদের UTF-8 ডেটা হ্যান্ডলিং নিয়ে আগে থেকেই আরও বেশি ভাবতে হবে। এই ট্রেড-অফটি অন্যান্য প্রোগ্রামিং ল্যাঙ্গুয়েজে দৃশ্যমান স্ট্রিং-এর জটিলতার চেয়ে বেশি প্রকাশ করে, তবে এটি আপনাকে আপনার ডেভেলপমেন্ট লাইফ সাইকেলের পরবর্তী পর্যায়ে নন-ASCII অক্ষর সম্পর্কিত এরর হ্যান্ডলিং করা থেকে বিরত রাখে।</p>
<p>সুখবর হলো, standard library <code>String</code> এবং <code>&amp;str</code> টাইপের উপর ভিত্তি করে অনেক কার্যকারিতা সরবরাহ করে যা এই জটিল পরিস্থিতিগুলি সঠিকভাবে পরিচালনা করতে সহায়তা করে। স্ট্রিং-এ অনুসন্ধানের জন্য <code>contains</code> এবং স্ট্রিং-এর অংশ অন্য স্ট্রিং দিয়ে প্রতিস্থাপনের জন্য <code>replace</code>-এর মতো দরকারি মেথডগুলির জন্য ডকুমেন্টেশন দেখতে ভুলবেন না।</p>
<p>চলুন এবার একটু কম জটিল কিছুতে যাওয়া যাক: hash maps</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-01-vectors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch08-03-hash-maps.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-01-vectors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch08-03-hash-maps.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
