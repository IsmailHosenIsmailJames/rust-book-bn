<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ডেটা টাইপ - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="ডেটা-টাইপ"><a class="header" href="#ডেটা-টাইপ">ডেটা টাইপ</a></h2>
<p>রাস্ট-এর প্রতিটি ভ্যালুর একটি নির্দিষ্ট <em>ডেটা টাইপ</em> থাকে, যা রাস্টকে বলে দেয় কী ধরনের ডেটা নির্দিষ্ট করা হচ্ছে যাতে এটি সেই ডেটার সাথে কীভাবে কাজ করতে হবে তা জানতে পারে। আমরা দুটি ডেটা টাইপের উপসেট দেখব: স্কেলার (scalar) এবং কম্পাউন্ড (compound)।</p>
<p>মনে রাখবেন যে রাস্ট একটি <em>স্ট্যাটিক্যালি টাইপড</em> ল্যাঙ্গুয়েজ, যার মানে হল কম্পাইল করার সময় এটিকে অবশ্যই সমস্ত ভ্যারিয়েবলের টাইপ জানতে হবে। কম্পাইলার সাধারণত আমরা কোন টাইপ ব্যবহার করতে চাই তা ভ্যালু এবং আমরা কীভাবে এটি ব্যবহার করি তার উপর ভিত্তি করে অনুমান করতে পারে। যখন অনেকগুলো টাইপ সম্ভব হয়, যেমন অধ্যায় ২-এর <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">"অনুমানের সাথে গোপন সংখ্যার তুলনা"</a> বিভাগে আমরা যখন <code>parse</code> ব্যবহার করে একটি <code>String</code>-কে একটি নিউমেরিক টাইপে রূপান্তর করেছিলাম, তখন আমাদের অবশ্যই একটি টাইপ অ্যানোটেশন যোগ করতে হবে, যেমন:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let guess: u32 = "42".parse().expect("Not a number!");
<span class="boring">}</span></code></pre></pre>
<p>যদি আমরা উপরের কোডে দেখানো <code>: u32</code> টাইপ অ্যানোটেশন যোগ না করি, রাস্ট নিম্নলিখিত এররটি প্রদর্শন করবে, যার মানে হল আমরা কোন টাইপ ব্যবহার করতে চাই তা জানার জন্য কম্পাইলারের আমাদের কাছ থেকে আরও তথ্য প্রয়োজন:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0284]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^        ----- type must be known at this point
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`
help: consider giving `guess` an explicit type
  |
2 |     let guess: /* Type */ = "42".parse().expect("Not a number!");
  |              ++++++++++++

For more information about this error, try `rustc --explain E0284`.
error: could not compile `no_type_annotations` (bin "no_type_annotations") due to 1 previous error
</code></pre>
<p>আপনি অন্যান্য ডেটা টাইপের জন্য বিভিন্ন টাইপ অ্যানোটেশন দেখতে পাবেন।</p>
<h3 id="সকেলার-টাইপ-scalar-types"><a class="header" href="#সকেলার-টাইপ-scalar-types">স্কেলার টাইপ (Scalar Types)</a></h3>
<p>একটি <em>স্কেলার</em> টাইপ একটি একক মান উপস্থাপন করে। রাস্টের চারটি প্রাথমিক স্কেলার টাইপ রয়েছে: ইন্টিজার (integers), ফ্লোটিং-পয়েন্ট নাম্বার (floating-point numbers), বুলিয়ান (Booleans) এবং ক্যারেক্টার (characters)। আপনি হয়তো অন্যান্য প্রোগ্রামিং ল্যাঙ্গুয়েজ থেকে এগুলোর সাথে পরিচিত। চলুন রাস্ট-এ এগুলো কীভাবে কাজ করে তা দেখা যাক।</p>
<h4 id="ইনটিজার-টাইপ-integer-types"><a class="header" href="#ইনটিজার-টাইপ-integer-types">ইন্টিজার টাইপ (Integer Types)</a></h4>
<p>একটি <em>ইন্টিজার</em> হল একটি সংখ্যা যার কোনো ভগ্নাংশ নেই। আমরা অধ্যায় ২-এ একটি ইন্টিজার টাইপ, <code>u32</code> টাইপ ব্যবহার করেছি। এই টাইপ ডিক্লারেশনটি নির্দেশ করে যে এর সাথে যুক্ত ভ্যালুটি একটি আনসাইন্ড ইন্টিজার (সাইনড ইন্টিজার টাইপগুলো <code>u</code> এর পরিবর্তে <code>i</code> দিয়ে শুরু হয়) যা ৩২ বিট জায়গা নেয়। সারণী ৩-১ রাস্টের বিল্ট-ইন ইন্টিজার টাইপগুলো দেখায়। আমরা একটি ইন্টিজার ভ্যালুর টাইপ ঘোষণা করতে এই ভ্যারিয়েন্টগুলোর যেকোনো একটি ব্যবহার করতে পারি।</p>
<p><span class="caption">সারণী ৩-১: রাস্ট-এ ইন্টিজার টাইপ</span></p>
<div class="table-wrapper"><table><thead><tr><th>দৈর্ঘ্য (Length)</th><th>সাইনড (Signed)</th><th>আনসাইনড (Unsigned)</th></tr></thead><tbody>
<tr><td>৮-বিট</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>১৬-বিট</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>৩২-বিট</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>৬৪-বিট</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>১২৮-বিট</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>আর্কিটেকচার নির্ভর</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
</div>
<p>প্রতিটি ভ্যারিয়েন্ট সাইনড বা আনসাইনড হতে পারে এবং এর একটি সুস্পষ্ট আকার রয়েছে। <em>সাইনড</em> এবং <em>আনসাইনড</em> বলতে বোঝায় যে সংখ্যাটি ঋণাত্মক হওয়া সম্ভব কিনা—অন্য কথায়, সংখ্যাটির সাথে একটি চিহ্ন (সাইন) থাকার প্রয়োজন আছে কিনা (সাইনড) অথবা এটি কেবল ধনাত্মক হবে এবং তাই কোনো চিহ্ন ছাড়াই উপস্থাপন করা যেতে পারে (আনসাইনড)। এটা কাগজে সংখ্যা লেখার মতো: যখন চিহ্ন গুরুত্বপূর্ণ, তখন একটি সংখ্যা প্লাস বা মাইনাস চিহ্ন দিয়ে দেখানো হয়; তবে, যখন সংখ্যাটি ধনাত্মক বলে ধরে নেওয়া নিরাপদ, তখন এটি কোনো চিহ্ন ছাড়াই দেখানো হয়। সাইনড সংখ্যা <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two’s complement</a> রিপ্রেজেন্টেশন ব্যবহার করে সংরক্ষণ করা হয়।</p>
<p>প্রতিটি সাইনড ভ্যারিয়েন্ট −(২<sup>n − ১</sup>) থেকে ২<sup>n − ১</sup> − ১ পর্যন্ত সংখ্যা সংরক্ষণ করতে পারে, যেখানে <em>n</em> হল সেই ভ্যারিয়েন্টটি যে বিট সংখ্যা ব্যবহার করে। তাই একটি <code>i8</code> −(২<sup>৭</sup>) থেকে ২<sup>৭</sup> − ১ পর্যন্ত, যা −১২৮ থেকে ১২৭ এর সমান, সংখ্যা সংরক্ষণ করতে পারে। আনসাইনড ভ্যারিয়েন্টগুলো ০ থেকে ২<sup>n</sup> − ১ পর্যন্ত সংখ্যা সংরক্ষণ করতে পারে, তাই একটি <code>u8</code> ০ থেকে ২<sup>৮</sup> − ১ পর্যন্ত, যা ০ থেকে ২৫৫ এর সমান, সংখ্যা সংরক্ষণ করতে পারে।</p>
<p>এছাড়াও, <code>isize</code> এবং <code>usize</code> টাইপগুলো আপনার প্রোগ্রাম যে কম্পিউটারের আর্কিটেকচারে চলছে তার উপর নির্ভর করে: ৬৪-বিট আর্কিটেকচারে থাকলে ৬৪ বিট এবং ৩২-বিট আর্কিটেকচারে থাকলে ৩২ বিট।</p>
<p>আপনি সারণী ৩-২-এ দেখানো যেকোনো ফর্মে ইন্টিজার লিটারেল লিখতে পারেন। মনে রাখবেন যে যেসব নাম্বার লিটারেল একাধিক নিউমেরিক টাইপ হতে পারে, সেগুলোতে টাইপ নির্দিষ্ট করার জন্য একটি টাইপ সাফিক্স, যেমন <code>57u8</code>, অনুমোদিত। নাম্বার লিটারেলগুলোতে সংখ্যাটি সহজে পড়ার জন্য একটি ভিজ্যুয়াল সেপারেটর হিসাবে <code>_</code> ব্যবহার করা যেতে পারে, যেমন <code>1_000</code>, যার মান <code>1000</code> নির্দিষ্ট করার মতোই হবে।</p>
<p><span class="caption">সারণী ৩-২: রাস্ট-এ ইন্টিজার লিটারেল</span></p>
<div class="table-wrapper"><table><thead><tr><th>নাম্বার লিটারেল</th><th>উদাহরণ</th></tr></thead><tbody>
<tr><td>ডেসিমেল</td><td><code>98_222</code></td></tr>
<tr><td>হেক্স</td><td><code>0xff</code></td></tr>
<tr><td>অক্টাল</td><td><code>0o77</code></td></tr>
<tr><td>বাইনারি</td><td><code>0b1111_0000</code></td></tr>
<tr><td>বাইট (<code>u8</code> কেবল)</td><td><code>b'A'</code></td></tr>
</tbody></table>
</div>
<p>তাহলে আপনি কীভাবে জানবেন কোন ধরনের ইন্টিজার ব্যবহার করবেন? আপনি যদি অনিশ্চিত হন, রাস্টের ডিফল্টগুলো সাধারণত শুরু করার জন্য ভাল জায়গা: ইন্টিজার টাইপগুলো ডিফল্টভাবে <code>i32</code> হয়। <code>isize</code> বা <code>usize</code> ব্যবহার করার প্রাথমিক পরিস্থিতি হল কোনো ধরনের কালেকশন ইনডেক্স করার সময়।</p>
<blockquote>
<h5 id="ইনটিজার-ওভারফলো-integer-overflow"><a class="header" href="#ইনটিজার-ওভারফলো-integer-overflow">ইন্টিজার ওভারফ্লো (Integer Overflow)</a></h5>
<p>ধরা যাক আপনার কাছে <code>u8</code> টাইপের একটি ভ্যারিয়েবল আছে যা ০ থেকে ২৫৫ এর মধ্যে মান ধারণ করতে পারে। আপনি যদি ভ্যারিয়েবলটিকে সেই পরিসরের বাইরের কোনো মানে পরিবর্তন করার চেষ্টা করেন, যেমন ২৫৬, তাহলে <em>ইন্টিজার ওভারফ্লো</em> ঘটবে, যা দুটি আচরণের একটির কারণ হতে পারে। আপনি যখন ডিবাগ মোডে কম্পাইল করছেন, তখন রাস্ট ইন্টিজার ওভারফ্লোর জন্য চেক অন্তর্ভুক্ত করে যা এই আচরণ ঘটলে আপনার প্রোগ্রামকে রানটাইমে <em>প্যানিক</em> (panic) করায়। রাস্ট <em>প্যানিকিং</em> শব্দটি ব্যবহার করে যখন একটি প্রোগ্রাম একটি এরর সহ বন্ধ হয়ে যায়; আমরা অধ্যায় ৯-এর <a href="ch09-01-unrecoverable-errors-with-panic.html">"Unrecoverable Errors with <code>panic!</code>"</a> বিভাগে প্যানিক নিয়ে আরও गहराई से আলোচনা করব।</p>
<p>আপনি যখন <code>--release</code> ফ্ল্যাগ দিয়ে রিলিজ মোডে কম্পাইল করছেন, তখন রাস্ট প্যানিক সৃষ্টিকারী ইন্টিজার ওভারফ্লোর জন্য চেক অন্তর্ভুক্ত করে <em>না</em>। পরিবর্তে, যদি ওভারফ্লো ঘটে, রাস্ট <em>টু'স কমপ্লিমেন্ট র‍্যাপিং</em> (two’s complement wrapping) করে। সংক্ষেপে, টাইপটি যে সর্বোচ্চ মান ধারণ করতে পারে তার চেয়ে বড় মানগুলো "র‍্যাপ অ্যারাউন্ড" করে টাইপটি যে সর্বনিম্ন মান ধারণ করতে পারে সেখানে চলে আসে। একটি <code>u8</code>-এর ক্ষেত্রে, মান ২৫৬ হয়ে যায় ০, মান ২৫৭ হয়ে যায় ১, এবং এভাবেই চলতে থাকে। প্রোগ্রামটি প্যানিক করবে না, কিন্তু ভ্যারিয়েবলটির একটি এমন মান থাকবে যা সম্ভবত আপনি যা আশা করেছিলেন তা নয়। ইন্টিজার ওভারফ্লোর র‍্যাপিং আচরণের উপর নির্ভর করা একটি এরর হিসাবে বিবেচিত হয়।</p>
<p>ওভারফ্লোর সম্ভাবনা স্পষ্টভাবে পরিচালনা করার জন্য, আপনি প্রিমিটিভ নিউমেরিক টাইপগুলোর জন্য স্ট্যান্ডার্ড লাইব্রেরি দ্বারা প্রদত্ত এই মেথডগুলোর পরিবার ব্যবহার করতে পারেন:</p>
<ul>
<li><code>wrapping_*</code> মেথড, যেমন <code>wrapping_add</code>, দিয়ে সমস্ত মোডে র‍্যাপ করুন।</li>
<li><code>checked_*</code> মেথড দিয়ে ওভারফ্লো হলে <code>None</code> মান প্রদান করুন।</li>
<li><code>overflowing_*</code> মেথড দিয়ে মান এবং একটি বুলিয়ান যা নির্দেশ করে ওভারফ্লো হয়েছে কিনা তা প্রদান করুন।</li>
<li><code>saturating_*</code> মেথড দিয়ে মানের সর্বনিম্ন বা সর্বোচ্চ মানে স্যাচুরেট করুন।</li>
</ul>
</blockquote>
<h4 id="ফলোটিং-পযেনট-টাইপ-floating-point-types"><a class="header" href="#ফলোটিং-পযেনট-টাইপ-floating-point-types">ফ্লোটিং-পয়েন্ট টাইপ (Floating-Point Types)</a></h4>
<p>রাস্ট-এ <em>ফ্লোটিং-পয়েন্ট নাম্বার</em>, যা দশমিক বিন্দুযুক্ত সংখ্যা, এর জন্য দুটি প্রিমিটিভ টাইপও রয়েছে। রাস্টের ফ্লোটিং-পয়েন্ট টাইপগুলো হল <code>f32</code> এবং <code>f64</code>, যা যথাক্রমে ৩২ বিট এবং ৬৪ বিট আকারের। ডিফল্ট টাইপ হল <code>f64</code> কারণ আধুনিক সিপিইউগুলিতে, এটি <code>f32</code>-এর মতো প্রায় একই গতির কিন্তু আরও বেশি নির্ভুলতা (precision) দিতে সক্ষম। সমস্ত ফ্লোটিং-পয়েন্ট টাইপ সাইনড।</p>
<p>এখানে একটি উদাহরণ যা ফ্লোটিং-পয়েন্ট নাম্বারগুলোকে কার্যকর অবস্থায় দেখায়:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}</code></pre></pre>
<p>ফ্লোটিং-পয়েন্ট নাম্বারগুলো IEEE-754 স্ট্যান্ডার্ড অনুযায়ী উপস্থাপিত হয়।</p>
<h4 id="নিউমেরিক-অপারেশনস-numeric-operations"><a class="header" href="#নিউমেরিক-অপারেশনস-numeric-operations">নিউমেরিক অপারেশনস (Numeric Operations)</a></h4>
<p>রাস্ট সমস্ত নাম্বার টাইপের জন্য আপনার প্রত্যাশিত মৌলিক গাণিতিক অপারেশনগুলো সমর্থন করে: যোগ, বিয়োগ, গুণ, ভাগ এবং ভাগশেষ (remainder)। ইন্টিজার ডিভিশন নিকটতম পূর্ণসংখ্যার দিকে শূন্যের দিকে ছেঁটে (truncates) ফেলে। নিম্নলিখিত কোডটি দেখায় যে আপনি কীভাবে একটি <code>let</code> স্টেটমেন্টে প্রতিটি নিউমেরিক অপারেশন ব্যবহার করবেন:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;
    let truncated = -5 / 3; // Results in -1

    // remainder
    let remainder = 43 % 5;
}</code></pre></pre>
<p>এই স্টেটমেন্টগুলোর প্রতিটি এক্সপ্রেশন একটি গাণিতিক অপারেটর ব্যবহার করে এবং একটি একক মানে মূল্যায়ন করে, যা তারপর একটি ভ্যারিয়েবলের সাথে বাইন্ড করা হয়। <a href="appendix-02-operators.html">পরিশিষ্ট বি</a> তে রাস্ট দ্বারা প্রদত্ত সমস্ত অপারেটরের একটি তালিকা রয়েছে।</p>
<h4 id="বুলিযান-টাইপ-the-boolean-type"><a class="header" href="#বুলিযান-টাইপ-the-boolean-type">বুলিয়ান টাইপ (The Boolean Type)</a></h4>
<p>অন্যান্য বেশিরভাগ প্রোগ্রামিং ল্যাঙ্গুয়েজের মতোই, রাস্ট-এ একটি বুলিয়ান টাইপের দুটি সম্ভাব্য মান রয়েছে: <code>true</code> এবং <code>false</code>। বুলিয়ানগুলো এক বাইট আকারের। রাস্ট-এ বুলিয়ান টাইপ <code>bool</code> ব্যবহার করে নির্দিষ্ট করা হয়। উদাহরণস্বরূপ:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}</code></pre></pre>
<p>বুলিয়ান মান ব্যবহার করার প্রধান উপায় হল কন্ডিশনাল, যেমন একটি <code>if</code> এক্সপ্রেশন। আমরা <a href="ch03-05-control-flow.html#control-flow">"কন্ট্রোল ফ্লো"</a> বিভাগে রাস্ট-এ <code>if</code> এক্সপ্রেশন কীভাবে কাজ করে তা কভার করব।</p>
<h4 id="কযারেকটার-টাইপ-the-character-type"><a class="header" href="#কযারেকটার-টাইপ-the-character-type">ক্যারেক্টার টাইপ (The Character Type)</a></h4>
<p>রাস্টের <code>char</code> টাইপ হল ভাষার সবচেয়ে আদিম বর্ণানুক্রমিক টাইপ। এখানে <code>char</code> মান ঘোষণা করার কিছু উদাহরণ দেওয়া হল:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}</code></pre></pre>
<p>লক্ষ্য করুন যে আমরা <code>char</code> লিটারেলগুলোকে একক উদ্ধৃতি (single quotes) দিয়ে নির্দিষ্ট করি, স্ট্রিং লিটারেলের বিপরীতে, যা দ্বৈত উদ্ধৃতি (double quotes) ব্যবহার করে। রাস্টের <code>char</code> টাইপ চার বাইট আকারের এবং একটি ইউনিকোড স্কেলার মান (Unicode Scalar Value) উপস্থাপন করে, যার মানে এটি শুধু ASCII-এর চেয়ে অনেক বেশি কিছু উপস্থাপন করতে পারে। অ্যাকসেন্টেড অক্ষর; চীনা, জাপানি এবং কোরিয়ান অক্ষর; ইমোজি; এবং শূন্য-প্রস্থের স্পেস সবই রাস্ট-এ বৈধ <code>char</code> মান। ইউনিকোড স্কেলার মান <code>U+0000</code> থেকে <code>U+D7FF</code> এবং <code>U+E000</code> থেকে <code>U+10FFFF</code> পর্যন্ত অন্তর্ভুক্ত। তবে, ইউনিকোডে "ক্যারেক্টার" realmente একটি ধারণা নয়, তাই "ক্যারেক্টার" বলতে আপনার মানবিক অনুভূতি রাস্ট-এ একটি <code>char</code> যা তার সাথে নাও মিলতে পারে। আমরা এই বিষয়টি অধ্যায় ৮-এর <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">"Storing UTF-8 Encoded Text with Strings"</a> বিভাগে বিস্তারিতভাবে আলোচনা করব।</p>
<h3 id="কমপাউনড-টাইপ-compound-types"><a class="header" href="#কমপাউনড-টাইপ-compound-types">কম্পাউন্ড টাইপ (Compound Types)</a></h3>
<p><em>কম্পাউন্ড টাইপ</em> একাধিক মানকে একটি টাইপে গ্রুপ করতে পারে। রাস্টের দুটি প্রিমিটিভ কম্পাউন্ড টাইপ রয়েছে: টাপল (tuples) এবং অ্যারে (arrays)।</p>
<h4 id="টাপল-টাইপ-the-tuple-type"><a class="header" href="#টাপল-টাইপ-the-tuple-type">টাপল টাইপ (The Tuple Type)</a></h4>
<p>একটি <em>টাপল</em> হল বিভিন্ন টাইপের একাধিক মানকে একটি কম্পাউন্ড টাইপে একত্রিত করার একটি সাধারণ উপায়। টাপলগুলোর একটি নির্দিষ্ট দৈর্ঘ্য থাকে: একবার ঘোষণা করা হলে, তারা আকারে বাড়তে বা কমতে পারে না।</p>
<p>আমরা প্রথম বন্ধনীর ভিতরে কমা দ্বারা পৃথক করা মানের একটি তালিকা লিখে একটি টাপল তৈরি করি। টাপলের প্রতিটি অবস্থানের একটি টাইপ থাকে, এবং টাপলের বিভিন্ন মানের টাইপ একই হতে হবে এমন কোনো কথা নেই। আমরা এই উদাহরণে ঐচ্ছিক টাইপ অ্যানোটেশন যোগ করেছি:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}</code></pre></pre>
<p><code>tup</code> ভ্যারিয়েবলটি পুরো টাপলের সাথে বাইন্ড করে কারণ একটি টাপলকে একটি একক কম্পাউন্ড উপাদান হিসাবে বিবেচনা করা হয়। একটি টাপল থেকে পৃথক মানগুলো পেতে, আমরা প্যাটার্ন ম্যাচিং ব্যবহার করে একটি টাপল মানকে ডিস্ট্রাকচার (destructure) করতে পারি, এভাবে:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {y}");
}</code></pre></pre>
<p>এই প্রোগ্রামটি প্রথমে একটি টাপল তৈরি করে এবং এটিকে <code>tup</code> ভ্যারিয়েবলের সাথে বাইন্ড করে। তারপরে এটি <code>let</code> এর সাথে একটি প্যাটার্ন ব্যবহার করে <code>tup</code> কে নিয়ে তিনটি পৃথক ভ্যারিয়েবল, <code>x</code>, <code>y</code>, এবং <code>z</code> তে পরিণত করে। একে <em>ডিস্ট্রাকচারিং</em> বলা হয় কারণ এটি একক টাপলকে তিনটি অংশে ভেঙে দেয়। অবশেষে, প্রোগ্রামটি <code>y</code>-এর মান প্রিন্ট করে, যা <code>6.4</code>।</p>
<p>আমরা একটি পিরিয়ড (<code>.</code>) এবং তারপরে আমরা যে মানটি অ্যাক্সেস করতে চাই তার ইনডেক্স ব্যবহার করে সরাসরি একটি টাপল উপাদান অ্যাক্সেস করতে পারি। উদাহরণস্বরূপ:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}</code></pre></pre>
<p>এই প্রোগ্রামটি <code>x</code> টাপল তৈরি করে এবং তারপরে তাদের নিজ নিজ ইনডেক্স ব্যবহার করে টাপলের প্রতিটি উপাদান অ্যাক্সেস করে। বেশিরভাগ প্রোগ্রামিং ল্যাঙ্গুয়েজের মতোই, একটি টাপলের প্রথম ইনডেক্স হল ০।</p>
<p>কোনো মান ছাড়াই টাপলটির একটি বিশেষ নাম আছে, <em>ইউনিট</em>। এই মান এবং এর সংশ্লিষ্ট টাইপ উভয়ই <code>()</code> লেখা হয় এবং একটি খালি মান বা একটি খালি রিটার্ন টাইপ উপস্থাপন করে। এক্সপ্রেশনগুলো যদি অন্য কোনো মান রিটার্ন না করে তবে তারা অন্তর্নিহিতভাবে ইউনিট মান রিটার্ন করে।</p>
<h4 id="অযারে-টাইপ-the-array-type"><a class="header" href="#অযারে-টাইপ-the-array-type">অ্যারে টাইপ (The Array Type)</a></h4>
<p>একাধিক মানের একটি সংগ্রহ থাকার আরেকটি উপায় হল একটি <em>অ্যারে</em>। একটি টাপলের বিপরীতে, একটি অ্যারের প্রতিটি উপাদানের একই টাইপ থাকতে হবে। অন্য কিছু ভাষার অ্যারের বিপরীতে, রাস্ট-এ অ্যারেগুলোর একটি নির্দিষ্ট দৈর্ঘ্য থাকে।</p>
<p>আমরা একটি অ্যারের মানগুলো বর্গাকার বন্ধনীর ভিতরে কমা দ্বারা পৃথক করা তালিকা হিসাবে লিখি:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];
}</code></pre></pre>
<p>অ্যারেগুলো দরকারী যখন আপনি চান আপনার ডেটা স্ট্যাকে (stack) বরাদ্দ করা হোক, যেমন আমরা এখন পর্যন্ত দেখেছি অন্যান্য টাইপের মতো, হিপের (heap) পরিবর্তে (আমরা <a href="ch04-01-what-is-ownership.html#the-stack-and-the-heap">অধ্যায় ৪</a>-এ স্ট্যাক এবং হিপ নিয়ে আরও আলোচনা করব) অথবা যখন আপনি নিশ্চিত করতে চান যে আপনার কাছে সর্বদা একটি নির্দিষ্ট সংখ্যক উপাদান রয়েছে। একটি অ্যারে ভেক্টর টাইপের মতো নমনীয় নয়। একটি <em>ভেক্টর</em> হল স্ট্যান্ডার্ড লাইব্রেরি দ্বারা প্রদত্ত একটি অনুরূপ সংগ্রহ টাইপ যা আকারে বাড়তে বা কমতে <em>পারে</em> কারণ এর বিষয়বস্তু হিপে থাকে। আপনি যদি অ্যারে বা ভেক্টর ব্যবহার করবেন কিনা তা নিয়ে অনিশ্চিত হন, তবে সম্ভাবনা হল আপনার একটি ভেক্টর ব্যবহার করা উচিত। <a href="ch08-01-vectors.html">অধ্যায় ৮</a> ভেক্টর নিয়ে আরও বিস্তারিত আলোচনা করে।</p>
<p>তবে, অ্যারেগুলো আরও বেশি দরকারী যখন আপনি জানেন যে উপাদানের সংখ্যা পরিবর্তন করার প্রয়োজন হবে না। উদাহরণস্বরূপ, আপনি যদি একটি প্রোগ্রামে মাসের নাম ব্যবহার করেন, তবে আপনি সম্ভবত একটি ভেক্টরর পরিবর্তে একটি অ্যারে ব্যবহার করবেন কারণ আপনি জানেন যে এটিতে সর্বদা ১২টি উপাদান থাকবে:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
<span class="boring">}</span></code></pre></pre>
<p>আপনি একটি অ্যারের টাইপ বর্গাকার বন্ধনী ব্যবহার করে প্রতিটি উপাদানের টাইপ, একটি সেমিকোলন এবং তারপরে অ্যারের উপাদানের সংখ্যা দিয়ে লিখেন, এভাবে:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}</span></code></pre></pre>
<p>এখানে, <code>i32</code> প্রতিটি উপাদানের টাইপ। সেমিকোলনের পরে, <code>5</code> সংখ্যাটি নির্দেশ করে যে অ্যারেটিতে পাঁচটি উপাদান রয়েছে।</p>
<p>আপনি প্রতিটি উপাদানের জন্য একই মান ধারণ করার জন্য একটি অ্যারে ইনিশিয়ালাইজ করতে পারেন, প্রাথমিক মান নির্দিষ্ট করে, তারপর একটি সেমিকোলন, এবং তারপর বর্গাকার বন্ধনীতে অ্যারের দৈর্ঘ্য, যেমনটি এখানে দেখানো হয়েছে:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}</span></code></pre></pre>
<p><code>a</code> নামের অ্যারেটিতে <code>5</code> টি উপাদান থাকবে যা সব প্রাথমিকভাবে <code>3</code> মানে সেট করা হবে। এটি <code>let a = [3, 3, 3, 3, 3];</code> লেখার মতোই কিন্তু আরও সংক্ষিপ্ত উপায়ে।</p>
<h5 id="অযারে-উপাদান-অযাকসেস-করা"><a class="header" href="#অযারে-উপাদান-অযাকসেস-করা">অ্যারে উপাদান অ্যাক্সেস করা</a></h5>
<p>একটি অ্যারে হল একটি পরিচিত, নির্দিষ্ট আকারের মেমরির একক খণ্ড যা স্ট্যাকে বরাদ্দ করা যেতে পারে। আপনি ইনডেক্সিং ব্যবহার করে একটি অ্যারের উপাদান অ্যাক্সেস করতে পারেন, এভাবে:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}</code></pre></pre>
<p>এই উদাহরণে, <code>first</code> নামের ভ্যারিয়েবলটি <code>1</code> মান পাবে কারণ এটি অ্যারের <code>[0]</code> ইনডেক্সে থাকা মান। <code>second</code> নামের ভ্যারিয়েবলটি অ্যারের <code>[1]</code> ইনডেক্স থেকে <code>2</code> মান পাবে।</p>
<h5 id="অবৈধ-অযারে-উপাদান-অযাকসেস"><a class="header" href="#অবৈধ-অযারে-উপাদান-অযাকসেস">অবৈধ অ্যারে উপাদান অ্যাক্সেস</a></h5>
<p>চলুন দেখি আপনি যদি একটি অ্যারের শেষ প্রান্তের বাইরের কোনো উপাদান অ্যাক্সেস করার চেষ্টা করেন তবে কী ঘটে। ধরা যাক আপনি অধ্যায় ২-এর অনুমান করার গেমের মতো এই কোডটি চালান, ব্যবহারকারীর কাছ থেকে একটি অ্যারে ইনডেক্স পেতে:</p>
<p><span class="filename">ফাইলের নাম: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">use std::io;

fn main() {
    let a = [1, 2, 3, 4, 5];

    println!("Please enter an array index.");

    let mut index = String::new();

    io::stdin()
        .read_line(&amp;mut index)
        .expect("Failed to read line");

    let index: usize = index
        .trim()
        .parse()
        .expect("Index entered was not a number");

    let element = a[index];

    println!("The value of the element at index {index} is: {element}");
}</code></pre>
<p>এই কোডটি সফলভাবে কম্পাইল হয়। আপনি যদি <code>cargo run</code> ব্যবহার করে এই কোডটি চালান এবং <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, বা <code>4</code> প্রবেশ করান, প্রোগ্রামটি অ্যারের সেই ইনডেক্সে থাকা সংশ্লিষ্ট মানটি প্রিন্ট করবে। আপনি যদি পরিবর্তে অ্যারের শেষের বাইরের কোনো সংখ্যা প্রবেশ করান, যেমন <code>10</code>, আপনি এই ধরনের আউটপুট দেখতে পাবেন:</p>
<!-- manual-regeneration
cd listings/ch03-common-programming-concepts/no-listing-15-invalid-array-access
cargo run
10
-->
<pre><code class="language-console">thread 'main' panicked at src/main.rs:19:19:
index out of bounds: the len is 5 but the index is 10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>ইনডেক্সিং অপারেশনে একটি অবৈধ মান ব্যবহার করার সময় প্রোগ্রামটি একটি <em>রানটাইম</em> এররের সম্মুখীন হয়েছিল। প্রোগ্রামটি একটি এরর বার্তা দিয়ে প্রস্থান করেছে এবং চূড়ান্ত <code>println!</code> স্টেটমেন্টটি কার্যকর করেনি। আপনি যখন ইনডেক্সিং ব্যবহার করে একটি উপাদান অ্যাক্সেস করার চেষ্টা করেন, রাস্ট পরীক্ষা করবে যে আপনি যে ইনডেক্সটি নির্দিষ্ট করেছেন তা অ্যারের দৈর্ঘ্যের চেয়ে কম কিনা। যদি ইনডেক্সটি দৈর্ঘ্যের চেয়ে বড় বা সমান হয়, রাস্ট প্যানিক করবে। এই পরীক্ষাটি রানটাইমে হতে হবে, বিশেষ করে এই ক্ষেত্রে, কারণ কম্পাইলারের পক্ষে সম্ভব নয় জানা যে একজন ব্যবহারকারী পরে কোডটি চালানোর সময় কী মান প্রবেশ করাবে।</p>
<p>এটি রাস্টের মেমরি সেফটি নীতির একটি উদাহরণ। অনেক নিম্ন-স্তরের ভাষায়, এই ধরনের পরীক্ষা করা হয় না, এবং যখন আপনি একটি ভুল ইনডেক্স প্রদান করেন, তখন অবৈধ মেমরি অ্যাক্সেস করা হতে পারে। রাস্ট আপনাকে এই ধরনের ত্রুটির বিরুদ্ধে সুরক্ষা দেয়, মেমরি অ্যাক্সেসের অনুমতি দিয়ে এবং চালিয়ে যাওয়ার পরিবর্তে অবিলম্বে প্রস্থান করে। অধ্যায় ৯ রাস্টের এরর হ্যান্ডলিং সম্পর্কে আরও আলোচনা করে এবং কীভাবে আপনি পঠনযোগ্য, নিরাপদ কোড লিখতে পারেন যা প্যানিকও করে না বা অবৈধ মেমরি অ্যাক্সেসের অনুমতিও দেয় না।</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch03-01-variables-and-mutability.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch03-01-variables-and-mutability.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch03-03-how-functions-work.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
