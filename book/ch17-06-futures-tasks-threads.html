<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ফিউচার, টাস্ক, এবং থ্রেড - The Rust Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="সবকিছু-একতরিত-করা-ফিউচার-টাসক-এবং-থরেড"><a class="header" href="#সবকিছু-একতরিত-করা-ফিউচার-টাসক-এবং-থরেড">সবকিছু একত্রিত করা: ফিউচার, টাস্ক, এবং থ্রেড</a></h2>
<p>যেমনটি আমরা <a href="http://localhost:3000/ch16-00-concurrency.html">চ্যাপ্টার ১৬</a><!-- ignore -->-এ দেখেছি, থ্রেডগুলি কনকারেন্সির (concurrency) জন্য একটি পদ্ধতি সরবরাহ করে। আমরা এই অধ্যায়ে আরেকটি পদ্ধতি দেখেছি: ফিউচার এবং স্ট্রীমের সাথে অ্যাসিঙ্ক (async) ব্যবহার করা। আপনি যদি ভাবেন যে কোনটির উপর কোন পদ্ধতি বেছে নেবেন, উত্তর হলো: এটি নির্ভর করে! এবং অনেক ক্ষেত্রে, পছন্দটি থ্রেড <em>অথবা</em> অ্যাসিঙ্ক নয় বরং থ্রেড <em>এবং</em> অ্যাসিঙ্ক।</p>
<p>অনেক অপারেটিং সিস্টেম এখন কয়েক দশক ধরে থ্রেড-ভিত্তিক কনকারেন্সি মডেল সরবরাহ করেছে, এবং ফলস্বরূপ অনেক প্রোগ্রামিং ভাষা সেগুলি সমর্থন করে। যাইহোক, এই মডেলগুলি ট্রেড-অফ (trade-off) ছাড়া নয়। অনেক অপারেটিং সিস্টেমে, তারা প্রতিটি থ্রেডের জন্য বেশ কিছুটা মেমরি ব্যবহার করে, এবং সেগুলি শুরু এবং বন্ধ করার জন্য কিছু ওভারহেড নিয়ে আসে। থ্রেডগুলি কেবল তখনই একটি বিকল্প যখন আপনার অপারেটিং সিস্টেম এবং হার্ডওয়্যার সেগুলি সমর্থন করে। মূলধারার ডেস্কটপ এবং মোবাইল কম্পিউটারের মতো নয়, কিছু এমবেডেড সিস্টেমের কোনো ওএস (OS) নেই, তাই তাদের থ্রেডও নেই।</p>
<p>অ্যাসিঙ্ক মডেল একটি ভিন্ন—এবং শেষ পর্যন্ত পরিপূরক—ট্রেড-অফের সেট সরবরাহ করে। অ্যাসিঙ্ক মডেলে, কনকারেন্ট অপারেশনগুলির নিজস্ব থ্রেডের প্রয়োজন হয় না। পরিবর্তে, তারা টাস্কগুলিতে চলতে পারে, যেমনটি আমরা স্ট্রীম বিভাগে একটি সিঙ্ক্রোনাস ফাংশন থেকে কাজ শুরু করার জন্য <code>trpl::spawn_task</code> ব্যবহার করেছি। একটি টাস্ক একটি থ্রেডের অনুরূপ, কিন্তু অপারেটিং সিস্টেম দ্বারা পরিচালিত হওয়ার পরিবর্তে, এটি লাইব্রেরি-স্তরের কোড দ্বারা পরিচালিত হয়: রানটাইম (runtime)।</p>
<p>পূর্ববর্তী বিভাগে, আমরা দেখেছি যে আমরা একটি অ্যাসিঙ্ক চ্যানেল ব্যবহার করে এবং একটি অ্যাসিঙ্ক টাস্ক তৈরি করে একটি স্ট্রীম তৈরি করতে পারি যা আমরা সিঙ্ক্রোনাস কোড থেকে কল করতে পারি। আমরা একটি থ্রেডের সাথে ঠিক একই কাজ করতে পারি। লিস্টিং ১৭-৪০-এ, আমরা <code>trpl::spawn_task</code> এবং <code>trpl::sleep</code> ব্যবহার করেছি। লিস্টিং ১৭-৪১-এ, আমরা <code>get_intervals</code> ফাংশনে সেগুলিকে স্ট্যান্ডার্ড লাইব্রেরি থেকে <code>thread::spawn</code> এবং <code>thread::sleep</code> API দিয়ে প্রতিস্থাপন করি।</p>
<Listing number="17-41" caption="`get_intervals` ফাংশনের জন্য অ্যাসিঙ্ক `trpl` API-এর পরিবর্তে `std::thread` API ব্যবহার করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // required for mdbook test
</span><span class="boring">
</span><span class="boring">use std::{pin::pin, thread, time::Duration};
</span><span class="boring">
</span><span class="boring">use trpl::{ReceiverStream, Stream, StreamExt};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::run(async {
</span><span class="boring">        let messages = get_messages().timeout(Duration::from_millis(200));
</span><span class="boring">        let intervals = get_intervals()
</span><span class="boring">            .map(|count| format!("Interval #{count}"))
</span><span class="boring">            .throttle(Duration::from_millis(500))
</span><span class="boring">            .timeout(Duration::from_secs(10));
</span><span class="boring">        let merged = messages.merge(intervals).take(20);
</span><span class="boring">        let mut stream = pin!(merged);
</span><span class="boring">
</span><span class="boring">        while let Some(result) = stream.next().await {
</span><span class="boring">            match result {
</span><span class="boring">                Ok(item) =&gt; println!("{item}"),
</span><span class="boring">                Err(reason) =&gt; eprintln!("Problem: {reason:?}"),
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_messages() -&gt; impl Stream&lt;Item = String&gt; {
</span><span class="boring">    let (tx, rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">    trpl::spawn_task(async move {
</span><span class="boring">        let messages = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"];
</span><span class="boring">
</span><span class="boring">        for (index, message) in messages.into_iter().enumerate() {
</span><span class="boring">            let time_to_sleep = if index % 2 == 0 { 100 } else { 300 };
</span><span class="boring">            trpl::sleep(Duration::from_millis(time_to_sleep)).await;
</span><span class="boring">
</span><span class="boring">            if let Err(send_error) = tx.send(format!("Message: '{message}'")) {
</span><span class="boring">                eprintln!("Cannot send message '{message}': {send_error}");
</span><span class="boring">                break;
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    ReceiverStream::new(rx)
</span><span class="boring">}
</span><span class="boring">
</span>fn get_intervals() -&gt; impl Stream&lt;Item = u32&gt; {
    let (tx, rx) = trpl::channel();

    // This is *not* `trpl::spawn` but `std::thread::spawn`!
    thread::spawn(move || {
        let mut count = 0;
        loop {
            // Likewise, this is *not* `trpl::sleep` but `std::thread::sleep`!
            thread::sleep(Duration::from_millis(1));
            count += 1;

            if let Err(send_error) = tx.send(count) {
                eprintln!("Could not send interval {count}: {send_error}");
                break;
            };
        }
    });

    ReceiverStream::new(rx)
}</code></pre></pre>
</Listing>
<p>আপনি যদি এই কোডটি চালান, আউটপুটটি লিস্টিং ১৭-৪০-এর মতোই হবে। এবং লক্ষ্য করুন কলিং কোডের দৃষ্টিকোণ থেকে এখানে কত কম পরিবর্তন হয়েছে। আরও কী, যদিও আমাদের একটি ফাংশন রানটাইমে একটি অ্যাসিঙ্ক টাস্ক তৈরি করেছে এবং অন্যটি একটি ওএস থ্রেড তৈরি করেছে, ফলস্বরূপ স্ট্রীমগুলি পার্থক্য দ্বারা প্রভাবিত হয়নি।</p>
<p>তাদের মিল থাকা সত্ত্বেও, এই দুটি পদ্ধতি খুব ভিন্নভাবে আচরণ করে, যদিও আমরা এই খুব সাধারণ উদাহরণে এটি পরিমাপ করতে কিছুটা বেগ পেতে পারি। আমরা যেকোনো আধুনিক ব্যক্তিগত কম্পিউটারে লক্ষ লক্ষ অ্যাসিঙ্ক টাস্ক তৈরি করতে পারতাম। যদি আমরা থ্রেডের সাথে এটি করার চেষ্টা করতাম, তাহলে আমাদের আক্ষরিক অর্থেই মেমরি ফুরিয়ে যেত!</p>
<p>যাইহোক, এই API-গুলি এত অনুরূপ হওয়ার একটি কারণ আছে। থ্রেডগুলি সিঙ্ক্রোনাস অপারেশনগুলির সেটের জন্য একটি সীমানা হিসাবে কাজ করে; কনকারেন্সি থ্রেডগুলির <em>মধ্যে</em> সম্ভব। টাস্কগুলি <em>অ্যাসিঙ্ক্রোনাস</em> অপারেশনগুলির সেটের জন্য একটি সীমানা হিসাবে কাজ করে; কনকারেন্সি টাস্কগুলির <em>মধ্যে</em> এবং <em>ভিতরে</em> উভয়ই সম্ভব, কারণ একটি টাস্ক তার বডিতে ফিউচারগুলির মধ্যে স্যুইচ করতে পারে। অবশেষে, ফিউচারগুলি হলো রাস্টের কনকারেন্সির সবচেয়ে ক্ষুদ্রতম একক, এবং প্রতিটি ফিউচার অন্যান্য ফিউচারের একটি ট্রি (tree) প্রতিনিধিত্ব করতে পারে। রানটাইম—বিশেষত, এর এক্সিকিউটর (executor)—টাস্কগুলি পরিচালনা করে, এবং টাস্কগুলি ফিউচারগুলি পরিচালনা করে। সেই ক্ষেত্রে, টাস্কগুলি লাইটওয়েট, রানটাইম-পরিচালিত থ্রেডের মতো যা অপারেটিং সিস্টেম দ্বারা পরিচালিত হওয়ার পরিবর্তে একটি রানটাইম দ্বারা পরিচালিত হওয়ার কারণে অতিরিক্ত ক্ষমতা পায়।</p>
<p>এর মানে এই নয় যে অ্যাসিঙ্ক টাস্কগুলি সবসময় থ্রেডের চেয়ে ভালো (বা বিপরীত)। থ্রেডের সাথে কনকারেন্সি কিছু উপায়ে <code>async</code>-এর সাথে কনকারেন্সির চেয়ে একটি সহজ প্রোগ্রামিং মডেল। এটি একটি শক্তি বা দুর্বলতা হতে পারে। থ্রেডগুলি কিছুটা "ফায়ার অ্যান্ড ফরগেট" (fire and forget); তাদের ফিউচারের কোনো নেটিভ সমতুল্য নেই, তাই তারা অপারেটিং সিস্টেম নিজে ছাড়া অন্য কোনো কিছু দ্বারা বাধাগ্রস্ত না হয়ে কেবল সম্পূর্ণ না হওয়া পর্যন্ত চলে। অর্থাৎ, তাদের <em>ইন্ট্রা-টাস্ক কনকারেন্সি</em> (intratask concurrency)-র জন্য কোনো বিল্ট-ইন সমর্থন নেই যেমনটি ফিউচারের আছে। রাস্টে থ্রেডগুলির ক্যান্সেলেশনের (cancellation) জন্য কোনো মেকানিজমও নেই—একটি বিষয় যা আমরা এই অধ্যায়ে স্পষ্টভাবে কভার করিনি তবে এটি অন্তর্নিহিত ছিল যে যখনই আমরা একটি ফিউচার শেষ করেছি, তার স্টেট সঠিকভাবে পরিষ্কার হয়ে গেছে।</p>
<p>এই সীমাবদ্ধতাগুলি থ্রেডগুলিকে ফিউচারের চেয়ে কম্পোজ করা কঠিন করে তোলে। উদাহরণস্বরূপ, এই অধ্যায়ের শুরুতে আমরা যে <code>timeout</code> এবং <code>throttle</code> মেথডগুলি তৈরি করেছি সেগুলির মতো হেল্পার তৈরি করতে থ্রেড ব্যবহার করা অনেক বেশি কঠিন। ফিউচারগুলি যে আরও সমৃদ্ধ ডেটা স্ট্রাকচার, তার মানে হলো সেগুলি আরও স্বাভাবিকভাবে একসাথে কম্পোজ করা যেতে পারে, যেমন আমরা দেখেছি।</p>
<p>টাস্কগুলি, তাহলে, আমাদের ফিউচারগুলির উপর <em>অতিরিক্ত</em> নিয়ন্ত্রণ দেয়, যা আমাদের কোথায় এবং কীভাবে সেগুলিকে গ্রুপ করতে হবে তা বেছে নেওয়ার সুযোগ দেয়। এবং দেখা যাচ্ছে যে থ্রেড এবং টাস্কগুলি প্রায়শই খুব ভালোভাবে একসাথে কাজ করে, কারণ টাস্কগুলি (অন্তত কিছু রানটাইমে) থ্রেডগুলির মধ্যে সরানো যেতে পারে। আসলে, পর্দার আড়ালে, আমরা যে রানটাইমটি ব্যবহার করে আসছি—<code>spawn_blocking</code> এবং <code>spawn_task</code> ফাংশন সহ—ডিফল্টরূপে মাল্টিথ্রেডেড! অনেক রানটাইম সিস্টেমের সামগ্রিক পারফরম্যান্স উন্নত করার জন্য থ্রেডগুলির মধ্যে স্বচ্ছভাবে টাস্কগুলি সরানোর জন্য <em>ওয়ার্ক স্টিলিং</em> (work stealing) নামে একটি পদ্ধতি ব্যবহার করে, যা থ্রেডগুলি বর্তমানে কীভাবে ব্যবহৃত হচ্ছে তার উপর ভিত্তি করে। সেই পদ্ধতির জন্য আসলে থ্রেড <em>এবং</em> টাস্ক, এবং তাই ফিউচার প্রয়োজন।</p>
<p>কোন পদ্ধতি কখন ব্যবহার করতে হবে তা নিয়ে ভাবার সময়, এই সাধারণ নিয়মগুলি বিবেচনা করুন:</p>
<ul>
<li>যদি কাজটি <em>খুবই প্যারালাল করা যায়</em> (very parallelizable), যেমন একগুচ্ছ ডেটা প্রসেস করা যেখানে প্রতিটি অংশ আলাদাভাবে প্রসেস করা যায়, তবে থ্রেডগুলি একটি ভালো পছন্দ।</li>
<li>যদি কাজটি <em>খুবই কনকারেন্ট</em> (very concurrent) হয়, যেমন বিভিন্ন উৎস থেকে আসা বার্তাগুলি পরিচালনা করা যা বিভিন্ন ব্যবধানে বা বিভিন্ন হারে আসতে পারে, তবে অ্যাসিঙ্ক একটি ভালো পছন্দ।</li>
</ul>
<p>এবং যদি আপনার প্যারালালিসম এবং কনকারেন্সি উভয়ই প্রয়োজন হয়, তবে আপনাকে থ্রেড এবং অ্যাসিঙ্কের মধ্যে বেছে নিতে হবে না। আপনি সেগুলিকে অবাধে একসাথে ব্যবহার করতে পারেন, প্রত্যেকটিকে তার সেরা কাজটি করতে দিয়ে। উদাহরণস্বরূপ, লিস্টিং ১৭-৪২ বাস্তব-বিশ্বের রাস্ট কোডে এই ধরনের মিশ্রণের একটি মোটামুটি সাধারণ উদাহরণ দেখায়।</p>
<Listing number="17-42" caption="একটি থ্রেডে ব্লকিং কোড দিয়ে বার্তা পাঠানো এবং একটি অ্যাসিঙ্ক ব্লকে বার্তাগুলি await করা" file-name="src/main.rs">
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">extern crate trpl; // for mdbook test
</span><span class="boring">
</span>use std::{thread, time::Duration};

fn main() {
    let (tx, mut rx) = trpl::channel();

    thread::spawn(move || {
        for i in 1..11 {
            tx.send(i).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    trpl::run(async {
        while let Some(message) = rx.recv().await {
            println!("{message}");
        }
    });
}</code></pre></pre>
</Listing>
<p>আমরা একটি অ্যাসিঙ্ক চ্যানেল তৈরি করে শুরু করি, তারপরে একটি থ্রেড তৈরি করি যা চ্যানেলের প্রেরক (sender) দিকের মালিকানা নেয়। থ্রেডের মধ্যে, আমরা ১ থেকে ১০ পর্যন্ত সংখ্যা পাঠাই, প্রতিটির মধ্যে এক সেকেন্ড ঘুমিয়ে। অবশেষে, আমরা অধ্যায় জুড়ে যেমন করেছি ঠিক তেমনই <code>trpl::run</code>-এ পাস করা একটি অ্যাসিঙ্ক ব্লক দিয়ে তৈরি একটি ফিউচার চালাই। সেই ফিউচারে, আমরা সেই বার্তাগুলি await করি, ঠিক যেমন আমরা দেখেছি অন্যান্য বার্তা-প্রেরণের উদাহরণগুলিতে।</p>
<p>অধ্যায়ের শুরুতে আমরা যে পরিস্থিতি দিয়ে শুরু করেছিলাম সেটিতে ফিরে যেতে, কল্পনা করুন একটি ডেডিকেটেড থ্রেড ব্যবহার করে একগুচ্ছ ভিডিও এনকোডিং টাস্ক চালানো হচ্ছে (কারণ ভিডিও এনকোডিং কম্পিউট-বাউন্ড) কিন্তু একটি অ্যাসিঙ্ক চ্যানেল দিয়ে UI-কে জানানো হচ্ছে যে সেই অপারেশনগুলি শেষ হয়েছে। বাস্তব-বিশ্বের ব্যবহারের ক্ষেত্রে এই ধরনের সংমিশ্রণের অগণিত উদাহরণ রয়েছে।</p>
<h2 id="সারসংকষেপ"><a class="header" href="#সারসংকষেপ">সারসংক্ষেপ</a></h2>
<p>এই বইয়ে কনকারেন্সির বিষয়ে এটিই শেষ নয়। <a href="ch21-00-final-project-a-web-server.html">চ্যাপ্টার ২১</a>-এর প্রকল্পটি এখানে আলোচনা করা সহজ উদাহরণগুলির চেয়ে আরও বাস্তবসম্মত পরিস্থিতিতে এই ধারণাগুলি প্রয়োগ করবে এবং থ্রেডিং বনাম টাস্কের সাথে সমস্যা-সমাধানের আরও সরাসরি তুলনা করবে।</p>
<p>আপনি এই পদ্ধতিগুলির মধ্যে যেটিই বেছে নিন না কেন, রাস্ট আপনাকে নিরাপদ, দ্রুত, কনকারেন্ট কোড লেখার জন্য প্রয়োজনীয় টুলস সরবরাহ করে—সেটি একটি উচ্চ-থ্রুপুট ওয়েব সার্ভারের জন্য হোক বা একটি এমবেডেড অপারেটিং সিস্টেমের জন্য।</p>
<p>এরপরে, আমরা আপনার রাস্ট প্রোগ্রামগুলি বড় হওয়ার সাথে সাথে সমস্যা মডেলিং এবং সমাধান কাঠামোবদ্ধ করার ইডিওম্যাটিক উপায়গুলি নিয়ে আলোচনা করব। এছাড়াও, আমরা আলোচনা করব কীভাবে রাস্টের ইডিওমগুলি অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং থেকে আপনার পরিচিত হতে পারে এমন ইডিওমগুলির সাথে সম্পর্কিত।</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-05-traits-for-async.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch18-00-oop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-05-traits-for-async.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch18-00-oop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>



    </div>
    </body>
</html>
